---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Package load/unload

```{r}
.onUnload <- function(libpath) {
  
  pkgpins::deregister(pkg = this_pkg)
}

.onLoad <- function(libname, pkgname) {
  
  pkgpins::clear(pkg = pkgname,
                 max_age = getOption(paste0(pkgname, ".global_cache_lifespan"),
                                     default = global_cache_lifespan))
}
```

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "all_of",
                                 "everything",
                                 # other
                                 "alignment",
                                 "allowed",
                                 "has_same_length",
                                 "has_auto_fallback",
                                 "n_cantonal_majoritarian_elections",
                                 "n_cantonal_proportional_elections",
                                 "n_cantonal_proposals",
                                 "n_char_short",
                                 "n_federal_majoritarian_elections",
                                 "n_federal_proportional_elections",
                                 "n_federal_proposals",
                                 "name",
                                 "nr",
                                 "question",
                                 "response_options",
                                 "separator",
                                 "string",
                                 "topic",
                                 "value_labels",
                                 "variable_values",
                                 "who",
                                 "width"))

# avoid notes about "possible error"s when using non-exported rex shortcuts, cf. https://github.com/kevinushey/rex#using-rex-in-other-packages
rex::register_shortcuts(pkg_name = utils::packageName())
```

## Functions

### Basic

#### `path_private`

Assemble a FOKUS private working directory path

```{r}
path_private <- function(rel_path) {
  
  dir_private <- getOption("fokus.path_private",
                           default = switch(EXPR = Sys.info()[["user"]],
                                            "salim" = "~/Arbeit/ZDA/Git/zdaarau/private/fokus_private/",
                                            # fall back to current working directory
                                            getwd()))
  
  # ensure path is valid (read access plus file `data/aargau/survey_data_2018-09-23.xlsx` exists)
  is_valid_path <-
    checkmate::test_directory(dir_private, access = "r") && fs::file_exists(path = fs::path(dir_private, "data/aargau/survey_data_2018-09-23.xlsx"))
  
  if (!is_valid_path) {
    
    is_opt_set <- !is.null(getOption("fokus.path_private"))
    
    cli::cli_abort(paste0(dplyr::if_else(is_opt_set,
                                         "The option {.field fokus.path_private} is set to: {.path {dir_private}}\n\n",
                                         "The option {.field fokus.path_private} is unset, thus we fall back to: {.path {dir_private}}\n\n"),
                          "This doesn't seem to be a valid FOKUS working directory. Please correct this in order for this package to work properly."))
  }
  
  fs::path(dir_private, rel_path)
}
```

#### `opts`

List package-specific options

```{r}
opts <- function(pretty_colnames = FALSE) {
  
  tibble::tibble(name = "fokus.path_private",
                 description = paste0("the path to the working directory (the local instance of the ",
                                      "[`fokus_private` repository](https://gitlab.com/zdaarau/private/fokus_private)); initialized automatically for ",
                                      "user=salim, otherwise defaults to the current working directory"),
                 has_auto_fallback = TRUE) |>
    tibble::add_row(name = "fokus.global_cache_lifespan",
                    description = glue::glue("the default cache lifespan for all functions taking a `cache_lifespan` argument; defaults to ",
                                             global_cache_lifespan),
                    has_auto_fallback = TRUE) |>
    purrr::when(checkmate::assert_flag(pretty_colnames) ~ dplyr::rename(.data = .,
                                                                        "automatic fallback if unset" = has_auto_fallback),
                ~ .)
}
```

#### `print_opts`

Pretty-print package-specific options

```{r}
print_opts <- function() {
  
  opts(pretty_colnames = TRUE) |>
    dplyr::mutate(name = paste0("`", name, "`"),
                  dplyr::across(all_of("automatic fallback if unset"),
                                lgl_to_unicode)) |>
    pal::pipe_table()
}
```

### Raw questionnaire data

#### DESCRIPTION

Functions to access the raw questionnaire data as defined in the [TOML](https://toml.io/) files found under
[`data-raw/questionnaire`](https://gitlab.com/zdaarau/rpkgs/fokus/-/tree/master/data-raw/questionnaire/).

#### `raw_q`

```{r}
#' Raw FOKUS questionnaire data
#'
#' A structured list of the raw questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @seealso [`raw_qx_suppl`][raw_qx_suppl] [`raw_q_suppl`][raw_q_suppl] [`raw_q_suppl_lvl`][raw_q_suppl_lvl] [`raw_q_suppl_lvl_canton`][raw_q_suppl_lvl_canton] 
#'   [`raw_q_suppl_proposal`][raw_q_suppl_proposal] [`raw_q_suppl_election`][raw_q_suppl_election] [`raw_q_suppl_skill_questions`][raw_q_suppl_skill_questions]
#'   [`raw_q_suppl_skill_question`][raw_q_suppl_skill_question]
#' @keywords internal
"raw_q"
```

#### `raw_qx_suppl`

```{r}
#' Raw supplemental date-specific FOKUS questionnaire data
#'
#' A structured list of raw supplemental date-specific questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @seealso [`raw_q`][raw_q] [`raw_q_suppl`][raw_q_suppl] [`raw_q_suppl_lvl`][raw_q_suppl_lvl] [`raw_q_suppl_lvl_canton`][raw_q_suppl_lvl_canton]
#'   [`raw_q_suppl_proposal`][raw_q_suppl_proposal] [`raw_q_suppl_election`][raw_q_suppl_election] [`raw_q_suppl_skill_questions`][raw_q_suppl_skill_questions]
#'   [`raw_q_suppl_skill_question`][raw_q_suppl_skill_question]
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qx_suppl[["2018-09-23"]]$mode
"raw_qx_suppl"
```

#### `raw_q_suppl`

```{r}
#' Get raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][raw_qx_suppl] for the specified ballot date.
#'
#' @inheritParams ballot_type
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl(ballot_date = "2018-09-23") %$% mode
raw_q_suppl <- function(ballot_date = ballot_dates) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  raw_qx_suppl[[ballot_date]]
}
```

#### `raw_q_suppl_lvl`

```{r}
#' Get a political level's raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl] for the specified ballot date and political level.
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return seealso
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_lvl(ballot_date = "2018-09-23",
#'                         lvl = "cantonal") |>
#'   names()
raw_q_suppl_lvl <- function(ballot_date = ballot_dates,
                            lvl = c("cantonal", "federal")) {
  
  lvl <- rlang::arg_match(lvl)
  
  result <- raw_q_suppl(ballot_date = ballot_date) %>% purrr::pluck(lvl)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    
    cli::cli_abort("No {.val {lvl}} level present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  result
}
```

#### `raw_q_suppl_lvl_canton`

```{r}
#' Get a canton's political-level-specific raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data for the specified ballot date and political level][raw_q_suppl_lvl]
#' that applies for the specified canton only.
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_lvl_canton(ballot_date = "2018-09-23",
#'                                lvl = "cantonal",
#'                                canton = "aargau") |>
#'   names()
raw_q_suppl_lvl_canton <- function(ballot_date = ballot_dates,
                                   lvl = c("cantonal", "federal"),
                                   canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  
  result <-
    raw_q_suppl_lvl(ballot_date = ballot_date,
                    lvl = lvl) %>%
    purrr::pluck(canton)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    
    cli::cli_abort("No {.val {lvl}} supplemental {.val {ballot_date}} FOKUS questionnaire data present for canton {.val {canton}}.")
  }
  
  result
}
```

#### `raw_q_suppl_proposal`

```{r}
#' Get raw proposal supplemental questionnaire data
#'
#' Returns a structured list of a proposal's data from the [supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_proposal(ballot_date = "2018-09-23",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              proposal_nr = 1) %$%
#'   name
raw_q_suppl_proposal <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr) {
  
  lvl <- rlang::arg_match(lvl)
  proposal_nr <- assert_countish(proposal_nr)
  
  proposals <-
    lvl %>%
    purrr::when(. == "federal" ~
                  raw_q_suppl_lvl(ballot_date = ballot_date,
                                  lvl = .),
                ~ raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                                         lvl = .,
                                         canton = canton)) %>%
    purrr::pluck("proposal")
  
  if (is.null(proposals)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} proposals present",
                          " for {.val {canton}}"[lvl == "cantonal"],
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  proposal <- proposals %>% purrr::pluck(as.character(proposal_nr))
  
  if (is.null(proposal)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} proposal {.val {proposal_nr}} present",
                          " for {.val {canton}}"[lvl == "cantonal"],
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  proposal
}
```

#### `raw_q_suppl_proposal_name`

```{r}
#' Get a proposal's raw name supplemental questionnaire data
#'
#' Returns a structured list of proposal name data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_proposal_name(ballot_date = "2018-11-25",
#'                                   lvl = "cantonal",
#'                                   canton = "aargau",
#'                                   proposal_nr = 2)
raw_q_suppl_proposal_name <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("name")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No names present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_arguments`

```{r}
#' Get a proposal's raw argument supplemental questionnaire data
#'
#' Returns a structured list of argument data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::proposal_main_motives(ballot_date = "2018-11-25",
#'                               lvl = "cantonal",
#'                               canton = "aargau",
#'                               proposal_nr = 2)
raw_q_suppl_arguments <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("argument")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No arguments present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_main_motives`

```{r}
#' Get a proposal's raw main motive supplemental questionnaire data
#'
#' Returns a structured list of main motive data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::proposal_main_motives(ballot_date = "2018-11-25",
#'                               lvl = "cantonal",
#'                               canton = "aargau",
#'                               proposal_nr = 2)
raw_q_suppl_main_motives <- function(ballot_date = ballot_dates,
                                     lvl = c("cantonal", "federal"),
                                     canton = cantons,
                                     proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("main_motive")
  
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No main motives present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_elections`

```{r}
#' Get raw supplemental election questionnaire data
#'
#' Returns a structured list of election data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl_canton].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_elections(ballot_date = "2019-10-20",
#'                               lvl = "cantonal",
#'                               canton = "aargau") %$%
#'   skill_questions_source
raw_q_suppl_elections <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons) {
  result <-
    raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton) %>%
    purrr::pluck("election")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_election`

NOTES:

-   Since *federal* elections in Switzerland are also organized per canton (the cantons are the electoral constituencies), the relevant data always stems from
    `raw_q_suppl_lvl_canton()` and never from `raw_q_suppl_lvl()`.

```{r}
#' Get an election's raw supplemental questionnaire data
#'
#' Returns a structured list of an election's data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl_canton].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_election(ballot_date = "2019-10-20",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              prcd = "majoritarian") %$%
#'   n_seats
raw_q_suppl_election <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 prcd = c("proportional", "majoritarian"),
                                 election_nr = 1L) {
  
  prcd <- rlang::arg_match(prcd)
  election_nr <- assert_countish(election_nr)
  
  result <-
    raw_q_suppl_elections(ballot_date = ballot_date,
                          lvl = lvl,
                          canton = canton) %>%
    purrr::pluck(prcd)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS ",
                          "questionnaire data."))
  }
  
  result %<>% purrr::pluck(as.character(election_nr))
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} election {.val {election_nr}} for canton {.val {canton}} present in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_election_name`

```{r}
#' Get raw supplemental election name questionnaire data
#'
#' Returns a structured list of an election's name data from the [political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_election_name(ballot_date = "2019-10-20",
#'                                   lvl = "cantonal",
#'                                   canton = "aargau",
#'                                   prcd = "majoritarian")
raw_q_suppl_election_name <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      prcd = c("proportional", "majoritarian"),
                                      election_nr = 1L) {
  lvl <- rlang::arg_match(lvl)
  prcd <- rlang::arg_match(prcd)
  election_nr <- assert_countish(election_nr)
  
  # federal proportional election names are defined once for all cantons together
  if (lvl == "federal" && prcd == "proportional") {
    
    result <-
      raw_q_suppl_lvl(ballot_date = ballot_date,
                      lvl = lvl) %>%
      purrr::chuck("election", prcd, as.character(election_nr))
    
  } else {
    
    result <- raw_q_suppl_election(ballot_date = ballot_date,
                                   lvl = lvl,
                                   canton = canton,
                                   prcd = prcd,
                                   election_nr = election_nr)
  }
  
  result %<>% purrr::pluck("name")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No names present for {.val {lvl}} {.val {prcd}} election {.val {election_nr}} in canton {.val {canton}} in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_skill_questions`

```{r}
#' Get raw supplemental skill question questionnaire data
#'
#' Returns a structured list of skill question data from the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, non-proposal-specific skill question data is returned.
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_skill_questions(ballot_date = "2018-09-23",
#'                                     lvl = "cantonal",
#'                                     canton = "aargau",
#'                                     proposal_nr = 1) |>
#'   purrr::map_depth(1L, "de") |>
#'   purrr::flatten_chr()
raw_q_suppl_skill_questions <- function(ballot_date = ballot_dates,
                                        lvl = c("cantonal", "federal"),
                                        canton = cantons,
                                        proposal_nr = NULL) {
  lvl <- rlang::arg_match(lvl)
  
  result <-
    lvl %>%
    purrr::when(
      
      # federal non-proposal-specific skill questions (e.g. at federal elections)
      length(proposal_nr) == 0L && . == "federal" ~
        raw_q_suppl_lvl(ballot_date = ballot_date,
                        lvl = .),
      # cantonal non-proposal-specific skill questions (e.g. at cantonal elections)
      length(proposal_nr) == 0L && . == "cantonal" ~
        raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                               lvl = .,
                               canton = canton),
      # federal or cantonal proposal-specific skill questions
      ~ raw_q_suppl_proposal(ballot_date = ballot_date,
                             lvl = .,
                             canton = canton,
                             proposal_nr = proposal_nr)) %>%
    purrr::pluck("skill_question")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No skill questions present",
                          dplyr::if_else(length(proposal_nr) == 0L,
                                         paste0(" on the {.val {lvl}} level",
                                                " for {.val {canton}}"[lvl == "cantonal"]),
                                         " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_skill_question`

```{r}
#' Get a single skill question's raw supplemental questionnaire data
#'
#' Returns a structured list of a single skill question's data from the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_skill_question(ballot_date = "2018-09-23",
#'                                    lvl = "cantonal",
#'                                    canton = "aargau",
#'                                    proposal_nr = 1,
#'                                    skill_question_nr = 1)
raw_q_suppl_skill_question <- function(ballot_date = ballot_dates,
                                       lvl = c("cantonal", "federal"),
                                       canton = cantons,
                                       proposal_nr = NULL,
                                       skill_question_nr) {
  
  skill_question_nr <- assert_countish(skill_question_nr)
  
  result <-
    raw_q_suppl_skill_questions(ballot_date = ballot_date,
                                lvl = lvl,
                                canton = canton,
                                proposal_nr = proposal_nr) %>%
    purrr::pluck(skill_question_nr)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No skill question {.val {skill_question_nr}} present",
                          dplyr::if_else(length(proposal_nr) == 0L,
                                         paste0(" on the {.val {lvl}} level", " for {.val {canton}}"[lvl == "cantonal"]),
                                         " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data. Only {length(skill_questions)} skill questions included."))
  }
  
  result
}
```

#### `raw_pick_right`

TODO:

-   Currently, when no matching subkey is found, `pick_right_helper()` only properly falls back to default value for key `include` (it's hardcoded). Instead, we
    should always fall back to default value (from `init_heritable_map()$KEY`)!

NOTES:

-   The recursion is performed because it's allowed to nest `.default`, `.true`, `false`, `.YYYYMMDD` etc. subkeys under `ballot_type`-subkeys (`.election`,
    `.referendum` etc.).

```{r}
#' Pick right raw questionnaire value
#'
#' Picks the right value of a certain raw questionnaire key based on ballot date and canton (recursively).
#'
#' @param x Questionnaire key. A list object.
#' @inheritParams ballot_type
#'
#' @return Value of `x` that corresponds to `canton` and `ballot_date`.
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
raw_pick_right <- function(x,
                           ballot_date,
                           canton) {
  
  if (purrr::vec_depth(x) > 1L) {
    
    x <-
      pick_right_helper(x = x,
                        ballot_date = ballot_date,
                        canton = canton) %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton)
    
  }
  
  x
}

pick_right_helper <- function(x,
                              ballot_date,
                              canton) {
  
  if (purrr::is_list(x) && (length(x) > 1L || purrr::vec_depth(x) > 1L)) {
    
    # create plain ballot date as in subkeys
    ballot_date_squeezed <- stringr::str_remove_all(string = ballot_date,
                                                    pattern = "-")
    # convert ballot date to type date
    ballot_date %<>% lubridate::as_date()
    
    # handle begin-end date subkeys
    begin_end_subkeys <-
      names(x) %>%
      stringr::str_subset(pattern = "^\\d+_\\d+$")
    
    matches_begin_end_subkeys <-
      begin_end_subkeys %>%
      purrr::map_lgl(function(x) {
        
        begin <- x %>% stringr::str_extract(pattern = "^\\d+") %>% lubridate::as_date()
        end <- x %>% stringr::str_extract(pattern = "\\d+$") %>% lubridate::as_date()
        
        begin <= ballot_date && ballot_date <= end
      })
    
    # integrity check: ensure there aren't any overlapping intervals
    if (length(which(matches_begin_end_subkeys)) > 1L) {
      
      cli::cli_abort("Illegal overlapping interval subkeys found: {.var {begin_end_subkeys[matches_begin_end_subkeys]}}\n\nPlease fix this and run again.")
    }
    
    x <- names(x) %>% purrr::when(
      
      # consider overrides for binary keys
      ballot_date %in% x[["false"]] ~ FALSE,
      ballot_date %in% x[["true"]] ~ TRUE,
      
      # consider overrides for non-binary keys
      ## single date subkey
      ballot_date_squeezed %in% . ~ x[[ballot_date_squeezed]],
      ## begin-end date subkey
      length(which(matches_begin_end_subkeys)) > 0L ~ x[[begin_end_subkeys[matches_begin_end_subkeys]]],
      
      # consider overrides for ballot types
      ballot_type(ballot_date = ballot_date, canton = canton) %in% . ~ x[[ballot_type(ballot_date = ballot_date, canton = canton)]],
      
      # return default value if defined
      "default" %in% . ~ x[["default"]],
      
      # return TRUE in any remaining cases (implicit `include`)
      ~ TRUE
    )
  }
  
  x
}
```

### Questionnaire generation

TODO:

-   Feed questionnaire keys to `cli::pluralize()` instead of `glue::glue()`, allowing for [cli's pluralization
    syntax](https://cli.r-lib.org/articles/pluralization.html).

#### `add_who_constraint`

Add the who constraint wrapped in parentheses to the end of a string (e.g. `variable_label`)

```{r}
add_who_constraint <- function(x,
                               who) {
  if (who != "all") {
    
    who %>%
      purrr::when(stringr::str_detect(string = x,
                                      pattern = "\\)$") ~ stringr::str_replace(string = x,
                                                                               pattern = "\\)$",
                                                                               replacement = paste0("; only ", ., ")")),
                  ~ paste0(x, " (only ", ., ")"))
  } else x
}
```

#### `assemble_deep`

Traverse questionnaire recursively and assemble questionnaire block

Default is to generate Markdown table rows (strings). If `generate_md = FALSE`, a tibble will be returned instead.

```{r}
assemble_deep <- function(data_q,
                          lvl_name,
                          heritable_map,
                          generate_md = TRUE,
                          verbose = FALSE) {
  
  heritable_map %<>% complement_heritable_map(from = data_q)
  result <- NULL
  
  if ("variable_name" %in% names(data_q)) {
    
    if (verbose) cli::cli_text("ITEM: {.val {data_q$variable_name}}")
    
    result <- process_item(v_name = data_q$variable_name,
                           heritable_map = heritable_map,
                           generate_md = generate_md)
    
  } else if (purrr::vec_depth(data_q) > 2L) {
    
    result <-
      purrr::map2(.x = data_q,
                  .y = names(data_q),
                  .f = ~ {
                    
                    if (verbose) cli::cli_h2("SUB-BLOCK: {.val {.y}}")
                    
                    assemble_deep(data_q = .x,
                                  lvl_name = .y,
                                  heritable_map = heritable_map,
                                  generate_md = generate_md,
                                  verbose = verbose)
                  }) %>%
      purrr::compact()
  }
  
  result
}
```

#### `assemble_md_ref_item`

```{r}
assemble_item <- function() {
  
}
```

#### `assemble_md_ref_item`

Assemble a footnote or reference-style link for Markdown questionnaire

```{r}
assemble_md_ref_item <- function(x,
                                 canton,
                                 ballot_date) {
  
  # avoid partial matching
  x %<>% xfun::as_strict_list()
  
  if ("id" %in% names(x)
      && ("text" %in% names(x) || "url" %in% names(x))) {
    
    x$include %<>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical() %>%
      purrr::when(length(.) == 0L ~ TRUE,
                  ~ .) %>%
      checkmate::assert_flag(.var.name = "include")
    
    # return NULL if item isn't included @ ballot date
    if (!x$include) {
      
      result <- NULL
      
    } else {
      
      # determine if item is footnote or reference-style link
      is_footnote <- "text" %in% names(x)
      has_link_title <- !is_footnote & "title" %in% names(x)
      val <- dplyr::if_else(is_footnote,
                            "text",
                            "url")
      
      result <- paste0("[",
                       dplyr::if_else(is_footnote,
                                      "^",
                                      ""),
                       glue::glue(x$id,
                                  .trim = FALSE),
                       "]: ",
                       glue::glue(x[[val]],
                                  .trim = FALSE),
                       dplyr::if_else(has_link_title,
                                      paste0(" '", x$title, "'"),
                                      ""))
    }
  } else {
    cli::cli_abort("At least one of the keys {.field id} or {.field text}/{.field url} is missing from this reference item.")
  }
  
  result
}
```

#### `assemble_subitem`

Assemble a single (or template) subitem to a tibble

```{r}
assemble_subitem <- function(i = NULL,
                             j = NULL,
                             v_name,
                             heritable_map,
                             canton,
                             ballot_date) {
  # parse the variable name
  v_name %<>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.trim = FALSE)
  
  # special case: if no `question_common` is defined, use `question.default` instead if it exists
  question <-
    heritable_map %>%
    purrr::pluck("question",
                 .default = NA_character_)
  
  question_common <-
    heritable_map %>%
    purrr::pluck("question_common",
                 .default = NA_character_) %>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.na = NULL,
               .trim = FALSE) %>%
    pal::strip_md()
  
  if (is.na(question_common) && "default" %in% names(question)) {
    
    question_common <-
      question$default %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      pal::strip_md()
  }
  
  # special case: if no `variable_label_common` is defined, use `variable_label.default` instead if it exists
  variable_name <-
    v_name %>%
    pal::strip_md()
  
  who <-
    heritable_map %>%
    purrr::chuck("who") %>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.trim = FALSE) %>%
    pal::strip_md()
  
  who_en <-
    raw_q$who %>%
    purrr::detect(~ .x$value$de == stringr::str_replace(string = who,
                                                        pattern = "\\d+",
                                                        replacement = "{i}")) %>%
    purrr::chuck("value", "en") %>%
    glue::glue(.trim = FALSE) %>%
    pal::strip_md()
  
  variable_label <-
    heritable_map %>%
    purrr::chuck("variable_label")
  
  variable_label_common <-
    heritable_map %>%
    purrr::pluck("variable_label_common",
                 .default = NA_character_) %>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.na = NULL,
               .trim = FALSE) %>%
    pal::strip_md()
  
  if (is.na(variable_label_common) && "default" %in% names(variable_label)) {
    
    # integrity check: ensure there haven't been any changes to `who` over time (if so, an explcicit `variable_label_common` has to be defined!)
    if (length(heritable_map$who) > 1L) {
      
      cli::cli_abort(paste0("{.field who} of variable {.var {variable_name}} has changed over time. Thus a custom {.field variable_label_common} must be ",
                            "defined in {.file questionnaire/questionnaire.toml}."))
    } else {
      
      variable_label_common <-
        variable_label$default %>%
        raw_pick_right(ballot_date = ballot_date,
                       canton = canton) %>%
        glue::glue(.na = NULL,
                   .trim = FALSE) %>%
        pal::strip_md() %>%
        add_who_constraint(who = who_en)
    }
    # add who constraint if necessary
  } else if (!is.na(variable_label_common)
             && !stringr::str_detect(string = variable_label_common,
                                     pattern = "(\\(|; )only .*?\\)$")) {
    
    if (length(heritable_map$who) > 1L) {
      
      cli::cli_abort(paste0("{.field who} of variable {.var {variable_name}} has changed over time. Thus the {.field who} constraint has to be explicitly ",
                            "specified at the end of {.field variable_label_common} in {.file questionnaire/questionnaire.toml}."))
      
    } else variable_label_common %<>% add_who_constraint(who = who_en)
  }
  
  tibble::tibble(
    topic =
      heritable_map %>%
      purrr::pluck("topic",
                   .default = NA_character_) %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      pal::strip_md(),
    who = who,
    question =
      question %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      pal::strip_md(),
    question_common = question_common,
    multiple_answers_allowed =
      heritable_map %>%
      purrr::chuck("multiple_answers_allowed") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical(),
    variable_name = variable_name,
    variable_name_32 =
      variable_name %>%
      # we set `max_n_char = 30L` to account for additional `time_*` vx which will be shortened to `t_*`, i.e. add 2 additional chars to the original v name
      # (except the special-block vx which won't have `time_*` siblings and certain exceptions which will share a common `time_*` v)
      shorten_v_names(max_n_char = dplyr::if_else(heritable_map$block %in% c("x_publitest", "y_generated", "z_generated")
                                                  || stringr::str_detect(string = .,
                                                                         pattern = rex::rex(start, or(c("agreement_contra_argument_",
                                                                                                        "information_source_",
                                                                                                        "reason_non_participation_",
                                                                                                        "political_occasions_")))),
                                                  32L,
                                                  30L)),
    variable_label =
      variable_label %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE) %>%
      pal::strip_md() %>%
      add_who_constraint(who = who_en),
    variable_label_common = variable_label_common,
    response_options =
      heritable_map %>%
      purrr::pluck("response_options",
                   .default = NA_character_) %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      purrr::map(.f = glue::glue,
                 .envir = environment(),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::flatten_chr() %>%
      list(),
    variable_values =
      heritable_map %>%
      purrr::pluck("variable_values",
                   .default = rep(x = NA_integer_,
                                  times =
                                    purrr::pluck(.x = heritable_map,
                                                 "response_options",
                                                 .default = NA_character_) %>%
                                    raw_pick_right(ballot_date = ballot_date,
                                                   canton = canton) %>%
                                    purrr::map(.f = glue::glue,
                                               .envir = environment(),
                                               .na = NULL,
                                               .trim = FALSE) %>%
                                    purrr::flatten_chr() %>%
                                    length())) %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      purrr::map(.f = glue::glue,
                 .envir = environment(),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::map(.f = as.integer) %>%
      purrr::flatten_int() %>%
      list(),
    value_labels =
      heritable_map %>%
      purrr::pluck("value_labels",
                   .default = NA_character_) %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      purrr::map(.f = glue::glue,
                 .envir = environment(),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::flatten_chr() %>%
      list(),
    value_scale =
      heritable_map %>%
      purrr::chuck("value_scale") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE) %>%
      pal::strip_md(),
    randomize_response_options =
      heritable_map %>%
      purrr::chuck("randomize_response_options") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical()
  )
}
```

#### `assemble_table_row`

Assemble a single (or template) table body row for Markdown questionnaire

```{r}
assemble_table_row <- function(i = NULL,
                               j = NULL,
                               v_name,
                               heritable_map,
                               canton,
                               ballot_date) {
  # parse the variable name
  v_name %<>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.trim = FALSE)
  
  who <-
    heritable_map %>%
    purrr::chuck("who") %>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.trim = FALSE)
  
  who_en <-
    raw_q$who %>%
    purrr::detect(~ .x$value$de == stringr::str_replace(string = who,
                                                        pattern = "\\d+",
                                                        replacement = "{i}")) %>%
    purrr::chuck("value", "en") %>%
    glue::glue(.trim = FALSE)
  
  paste(
    # topic
    heritable_map %>%
      purrr::pluck("topic",
                   .default = "-") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE,
                 .na = "-"),
    # who
    who,
    # question
    heritable_map %>%
      purrr::pluck("question",
                   .default = "-") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE,
                 .na = "-"),
    # multiple answers allowed?
    heritable_map %>%
      purrr::chuck("multiple_answers_allowed") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical() %>%
      purrr::when(isTRUE(.) ~ "ja",
                  ~ "nein"),
    # variable name
    v_name %>%
      wrap_backtick() %>%
      collapse_break(),
    # variable_name_32,
    v_name %>%
      # we set `max_n_char = 30L` to account for additional `time_*` vx which will be shortened to `t_*`, i.e. add 2 additional chars to the original v name
      # (except the special-block vx which won't have `time_*` siblings and certain exceptions which will share a common `time_*` v)
      shorten_v_names(max_n_char = dplyr::if_else(heritable_map$block %in% c("x_publitest", "y_generated", "z_generated")
                                                  || stringr::str_detect(string = .,
                                                                         pattern = rex::rex(start, or(c("agreement_contra_argument_",
                                                                                                        "information_source_",
                                                                                                        "reason_non_participation_",
                                                                                                        "political_occasions_")))),
                                                  32L,
                                                  30L)) %>%
      wrap_backtick() %>%
      collapse_break(),
    # variable label
    heritable_map %>%
      purrr::chuck("variable_label") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE) %>%
      add_who_constraint(who = who_en),
    # response options
    heritable_map %>%
      purrr::pluck("response_options",
                   .default = "-") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      purrr::map(.envir = environment(),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      purrr::when(is_skill_question(v_name) ~ md_emphasize(x = .,
                                                           which = skill_question_answer_nr(ballot_date = ballot_date,
                                                                                            lvl = v_lvls(v_name = v_name),
                                                                                            canton = canton,
                                                                                            proposal_nr = i,
                                                                                            skill_question_nr = ifelse(has_election(ballot_date = ballot_date,
                                                                                                                                    canton = canton),
                                                                                                                       i,
                                                                                                                       j))),
                  ~ .) %>%
      collapse_break(),
    # variable values
    heritable_map %>%
      purrr::pluck("variable_values",
                   .default = "-") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      purrr::map(.envir = environment(),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      collapse_break(),
    # value labels
    heritable_map %>%
      purrr::pluck("value_labels",
                   .default = "-") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      purrr::map(.envir = environment(),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      collapse_break(),
    # randomize response options?
    heritable_map %>%
      purrr::chuck("randomize_response_options") %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical() %>%
      purrr::when(isTRUE(.) ~ "ja",
                  ~ "nein"),
    sep = " | "
  )
}
```

#### `assert_heritable_map_complete`

Check heritable map for completeness

NOTES:

-   It's assumed that all fields are present. The only property asserted is that *present* fields are not `NULL`.

```{r}
assert_heritable_map_complete <- function(heritable_map) {
  
  heritable_map_essential <-
    heritable_map %>%
    purrr::list_modify(i = rlang::zap(),
                       j = rlang::zap(),
                       lvl = rlang::zap(),
                       topic = rlang::zap(),
                       question = rlang::zap(),
                       question_common = rlang::zap(),
                       variable_label_common = rlang::zap(),
                       response_options = rlang::zap(),
                       variable_values = rlang::zap(),
                       value_labels = rlang::zap())
  
  if (heritable_map_essential %>%
      purrr::map_lgl(.f = is.null) %>%
      any()) {
    
    unset_keys <-
      heritable_map_essential %>%
      purrr::keep(.p = is.null) %>%
      names()
    
    v_name <-
      heritable_map_essential %>%
      purrr::pluck("variable_name") %>%
      raw_pick_right() %>%
      glue::glue(.trim = FALSE)
    
    cli::cli_abort("{cli::qty(unset_keys)}The key{?s} {unset_keys} {?is/are} not set for variable {.var {v_name}}.")
  }
  
  heritable_map
}
```

#### `expand_q_tibble`

Expand questionnaire tibble to long format

This function takes an (unexpanded, but well structured) FOKUS Aargau questionnaire tibble, performs various integrity checks, expands it to proper [long
format](https://en.wikipedia.org/wiki/Wide_and_narrow_data) and returns it as a tibble.

```{r}
expand_q_tibble <- function(q_tibble) {
  
  # integrity check 1: ensure there are no duplicated topics, variable names and variable labels
  c("topic",
    "variable_name",
    "variable_label") %>%
    purrr::walk(.f = function(v) {
      
      is_dup <- duplicated(q_tibble[[v]])
      
      if (any(is_dup)) {
        
        dup_indices <- which(is_dup)
        
        for (i in dup_indices) {
          
          dup_v <- q_tibble[[v]][i]
          
          cli::cli_warn(paste0("{.var {v}} {.val {dup_v}} is included more than once in the questionnaire. Please fix this and run the script again."))
        }
      }
    })
  
  # integrity check 2: ensure the columns `response_options`, `variable_values` and `value_labels` have the same length and if not, tell which ones don't
  lengths <-
    q_tibble %>%
    dplyr::select(response_options,
                  variable_values,
                  value_labels) %>%
    purrr::map_depth(.depth = 2L,
                     .f = length) %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::flatten_int) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(has_same_length = response_options == variable_values) %>%
    dplyr::mutate(has_same_length = has_same_length & response_options == value_labels)
  
  if (any(!lengths$has_same_length)) {
    
    diff_indices <- which(!lengths$has_same_length)
    
    cli::cli_warn(paste0("The number of {.var {c('response_options', 'variable_values', 'value_labels')}} differs for ",
                         dplyr::if_else(length(diff_indices) > 1L,
                                        "multiple variables. Affected are: {.var {q_tibble$variable_name[diff_indices]}}",
                                        "the variable {.var {q_tibble$variable_name[diff_indices]}}."),
                         "\n\nPlease fix this first and then run the script again."))
  }
  
  # expand questionnaire data to long format ...
  # note that `tidyr::unnest` also performs an implicit integrity check: it ensures that the number of response options, variable values and value labels 
  # for each variable name is either one or of the same length (or otherwise throws an error); obviously this assertion still isn't as strict as integrity
  # check 2 above
  q_tibble %>%
    tidyr::unnest(cols = c(response_options,
                           variable_values,
                           value_labels)) %>%
    # ... and remove footnote references from topic, question and who
    dplyr::mutate(dplyr::across(.cols = c(topic,
                                          question,
                                          who),
                                .fns = stringr::str_remove_all,
                                pattern = "\\[\\^[^\\]]+\\](&nbsp;)?"))
}
```

#### `gen_table_header`

Generate table header for Markdown questionnaire

```{r}
gen_table_header <- function() {
  
  tibble::tribble(
    ~name,                                         ~width, ~alignment,
    "\\#",                                         2L,     "left",
    "Thema",                                       5L,     "left",
    "Wer",                                         3L,     "left",
    "Frage",                                       15L,    "left",
    "Mehrfachnennungen",                           3L,     "left",
    "Variablenname",                               5L,     "left",
    "Variablenname (gek\u00fcrzt auf 32 Zeichen)", 5L,     "left",
    "Variablenlabel",                              15L,    "left",
    "Antwortoptionen",                             5L,     "left",
    "Variablenauspr\u00e4gungen",                  5L,     "left",
    "Auspr\u00e4gungslabels",                      5L,     "left",
    "Antwortoptionen in Zufallsreihenfolge",       3L,     "left"
  ) %>%
    dplyr::mutate(separator =
                    purrr::map2_chr(.x = width,
                                    .y = alignment,
                                    .f = ~
                                      rep(x = "-",
                                          times = .x) %>%
                                      paste0(collapse = "") %>%
                                      purrr::when(.y == "left" ~ stringr::str_replace(string = .,
                                                                                      pattern = "^.",
                                                                                      replacement = ":"),
                                                  .y == "right" ~ stringr::str_replace(string = .,
                                                                                       pattern = ".$",
                                                                                       replacement = ":"),
                                                  .y == "center" ~ stringr::str_replace_all(string = .,
                                                                                            pattern = "(^.|.$)",
                                                                                            replacement = ":"),
                                                  ~ .))) %$%
    c(paste0(name, collapse = " | "),
      paste0(separator, collapse = " | "))
}
```

#### `gen_table_body`

Generate table body for Markdown questionnaire

```{r}
gen_table_body <- function(raw_q,
                           block,
                           enumeration_start = 1L) {
  # ensure `block` exists
  if (is.null(raw_q[[block]])) {
    cli::cli_abort("The block {.field {block}} doesn't exist in {.var raw_q}.")
  }
  
  # traverse list `raw_q` recursively to assemble questionnaire body
  body <- assemble_deep(data_q = raw_q[[block]],
                        heritable_map = init_heritable_map(block = block))
  
  if (length(body) > 0L) {
    
    # "unpack" results list
    while (purrr::vec_depth(body) > 2L) {
      body %<>% purrr::flatten()
    }
    body %<>% purrr::flatten_chr()
    
    # get block enumeration prefix
    prefix <- raw_q %>% purrr::pluck(block, "prefix",
                                     .default = 0L)
    
    # enumerate body rows
    body %<>% paste(seq(from = enumeration_start + prefix,
                        to = enumeration_start + prefix + length(.) - 1L,
                        by = 1L), .,
                    sep = " | ")
    
  } else body <- NULL
  
  body
}
```

#### `process_item`

Process an "atomic" questionnaire item

```{r}
process_item <- function(v_name,
                         heritable_map,
                         generate_md = TRUE,
                         ballot_date,
                         canton) {
  
  # ensure nothing indispensable is missing
  assert_heritable_map_complete(heritable_map = heritable_map)
  
  # choose correct include iterator and keys and evaluate them
  heritable_map[["include"]] %<>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.trim = FALSE) %>%
    as.logical() %>%
    checkmate::assert_flag(.var.name = "include")
  
  heritable_map[["ballot_type"]] %<>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.trim = FALSE) %>%
    checkmate::assert_string(.var.name = "ballot_type")
  
  heritable_map[["i"]] %<>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.trim = FALSE) %>%
    purrr::when(length(.) == 0L ~ NULL,
                .) %>%
    checkmate::assert_character(any.missing = FALSE,
                                min.len = 0L,
                                .var.name = "i")
  
  heritable_map[["j"]] %<>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    glue::glue(.trim = FALSE) %>%
    purrr::when(length(.) == 0L ~ NULL,
                .) %>%
    checkmate::assert_character(any.missing = FALSE,
                                min.len = 0L,
                                .var.name = "j")
  
  # return NULL if item isn't included @ ballot date
  if (!heritable_map[["include"]]
      || (heritable_map$ballot_type != "both_referendum_and_election"
          && heritable_map$ballot_type != ballot_type(ballot_date = ballot_date, canton = canton))) {
    
    result <- NULL
    
  } else {
    
    # assemble "normal" questionnaire items
    if (is.null(heritable_map[["i"]]) && is.null(heritable_map[["j"]])) {
      
      if (generate_md) {
        result <- assemble_table_row(v_name = v_name,
                                     heritable_map = heritable_map,
                                     canton = canton,
                                     ballot_date = ballot_date)
      } else {
        result <- assemble_subitem(v_name = v_name,
                                   heritable_map = heritable_map,
                                   canton = canton,
                                   ballot_date = ballot_date)
      }
    } else if (is.null(heritable_map[["j"]])) {
      
      if (generate_md) {
        result <- purrr::map_chr(.x = heritable_map[["i"]],
                                 .f = assemble_table_row,
                                 v_name = v_name,
                                 heritable_map = heritable_map,
                                 canton = canton,
                                 ballot_date = ballot_date)
      } else {
        result <- purrr::map_dfr(.x = heritable_map[["i"]],
                                 .f = assemble_subitem,
                                 v_name = v_name,
                                 heritable_map = heritable_map,
                                 canton = canton,
                                 ballot_date = ballot_date)
      }
      
      # validity check
    } else if (is.null(heritable_map[["i"]])) {
      
      # this combo doesn't really make sense and should never occur
      cli::cli_abort("This should not happen ({.var j} set, but {.var i} not set).")
      
      # "template" items resulting in multiple questionnaire items
    } else {
      
      if (generate_md) {
        result <-
          purrr::map(.x = heritable_map[["i"]],
                     .f = function(x) {
                       
                       i <- x
                       purrr::map_chr(i = x,
                                      .x = heritable_map[["j"]],
                                      .f = assemble_table_row,
                                      v_name = v_name,
                                      heritable_map = heritable_map,
                                      canton = canton,
                                      ballot_date = ballot_date)
                     }) %>%
          purrr::flatten_chr()
        
      } else {
        result <- purrr::map_dfr(.x = heritable_map[["i"]],
                                 .f = function(x) {
                                   
                                   i <- x
                                   purrr::map_dfr(i = x,
                                                  .x = heritable_map[["j"]],
                                                  .f = assemble_subitem,
                                                  v_name = v_name,
                                                  heritable_map = heritable_map,
                                                  canton = canton,
                                                  ballot_date = ballot_date)
                                 })
      }
    }
  }
  
  result
}
```

#### `gen_q_tibble`

```{r}
gen_q_tibble <- function(ballot_date = ballot_dates,
                         canton = cantons,
                         verbose = FALSE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  checkmate::assert_flag(verbose)
  
  if (!verbose) {
    status_msg <- "Generating questionnaire tibble for canton {.val {canton}} @ {.val {ballot_date}}..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  purrr::map2_dfr(.x = raw_q,
                  .y = names(raw_q),
                  .f = ~ {
                    
                    if (verbose && !(.y %in% q_non_item_lvls)) cli::cli_h1("BLOCK: {.val {.y}}")
                    
                    assemble_q_tibble(ballot_date = ballot_date,
                                      canton = canton,
                                      raw_q_branch = .x,
                                      q_lvl = .y,
                                      heritable_map = init_heritable_map(block = .y),
                                      verbose = verbose)
                  })
}
```

#### `assemble_q_tibble`

Traverse questionnaire recursively and assemble questionnaire block tibble.

```{r}
assemble_q_tibble <- function(ballot_date,
                              canton,
                              raw_q_branch,
                              q_lvl,
                              heritable_map,
                              verbose) {
  
  map <- heritable_map %>% complement_heritable_map(from = raw_q_branch)
  result <- NULL
  
  if ("variable_name" %in% names(raw_q_branch)) {
    
    if (verbose) cli::cli_progress_step(".. ITEM: {.var {map$variable_name}}")
    
    result <- assemble_q_item_tibble(ballot_date = ballot_date,
                                     canton = canton,
                                     item_map = map,
                                     verbose = verbose)
    
  } else if (purrr::vec_depth(raw_q_branch) > 2L) {
    
    if (verbose && dplyr::last(stringr::str_split(q_lvl, "\\.")[[1L]]) == "item") {
      cli::cli_progress_step("Q TABLE LVL: {.val {q_lvl}}")
    }
    
    result <- purrr::map2_dfr(.x = raw_q_branch,
                              .y = names(raw_q_branch) %||% seq_along(raw_q_branch),
                              .f = ~ assemble_q_tibble(ballot_date = ballot_date,
                                                       canton = canton,
                                                       raw_q_branch = .x,
                                                       q_lvl = paste(q_lvl, .y,
                                                                     sep = "."),
                                                       heritable_map = map,
                                                       verbose = verbose))
  }
  
  result
}
```

#### `assemble_q_item_tibble`

```{r}
assemble_q_item_tibble <- function(ballot_date,
                                   canton,
                                   item_map,
                                   verbose) {
  
  purrr::map_dfr(
    .x = resolve_q_val(x = item_map$lvl,
                       ballot_date = ballot_date,
                       canton = canton,
                       key = "lvl",
                       lvl = "",
                       i = "",
                       j = ""),
    .f = function(lvl) {
      
      purrr::map_dfr(
        .x = resolve_q_val(x = item_map$i,
                           ballot_date = ballot_date,
                           canton = canton,
                           key = "i",
                           lvl = lvl,
                           i = "",
                           j = ""),
        lvl = lvl,
        .f = function(i,
                      lvl) {
          
          purrr::map_dfr(
            .x = resolve_q_val(x = item_map$j,
                               ballot_date = ballot_date,
                               canton = canton,
                               key = "j",
                               lvl = lvl,
                               i = i,
                               j = ""),
            i = i,
            lvl = lvl,
            .f = function(j,
                          i,
                          lvl) {
              
              # respect keys `include` and `ballot_types`
              is_incl <- resolve_q_val(x = item_map$include,
                                       ballot_date = ballot_date,
                                       canton = canton,
                                       key = "include",
                                       lvl = lvl,
                                       i = i,
                                       j = j)
              has_ballot_type <-
                resolve_q_val(x = item_map$ballot_types,
                              ballot_date = ballot_date,
                              canton = canton,
                              key = "ballot_types",
                              lvl = lvl,
                              i = i,
                              j = j) %>%
                intersect(ballot_types(ballot_date = ballot_date,
                                       canton = canton)) %>%
                rlang::is_empty() %>%
                magrittr::not()
              
              result <- NULL
              
              if (is_incl && has_ballot_type) {
                result <-
                  names(item_map) %>%
                  setdiff(c("lvl",
                            "i",
                            "j",
                            "ballot_types",
                            "include")) %>%
                  magrittr::set_names(x = .,
                                      value = .) %>%
                  purrr::map(~ {
                    
                    if (verbose) cli::cli_progress_step(".. .. KEY: {.field {.x}}")
                    
                    resolve_q_val(x = item_map[[.x]],
                                  ballot_date = ballot_date,
                                  canton = canton,
                                  key = .x,
                                  lvl = lvl,
                                  i = i,
                                  j = j) %>%
                      purrr::when(
                        # replace empty scalars with NA
                        length(.) == 0L && .x %in% q_item_keys$key[q_item_keys$is_scalar] ~
                          .[NA],
                        # wrap vectors in list
                        .x %in% q_item_keys$key[!q_item_keys$is_scalar] ~
                          list(.),
                        ~ .
                      )
                  })
              }
              
              tibble::as_tibble(result)
            })
        })
    })
}
```

#### `init_heritable_map`

Initialize heritable map of key-value pairs that can be valid for multiple questions (set hierarchically)

```{r}
init_heritable_map <- function(block) {
  
  xfun::strict_list(lvl = "?",
                    i = "?",
                    j = "?",
                    block = block,
                    variable_name = "???",
                    topic = NULL,
                    who = NULL,
                    question = NULL,
                    question_common = NULL,
                    multiple_answers_allowed = FALSE,
                    variable_label = NULL,
                    variable_label_common = NULL,
                    response_options = NULL,
                    variable_values = NULL,
                    value_labels = NULL,
                    value_scale = "nominal",
                    randomize_response_options = FALSE,
                    ballot_types = c("referendum", "election"),
                    include = TRUE)
}
```

#### `complement_heritable_map`

Complement `map` with key-values from top level of list

```{r}
complement_heritable_map <- function(x,
                                     from) {
  names <- names(x)
  
  x %>%
    purrr::map2(.x = names,
                .y = .,
                .f = function(k, v) purrr::pluck(.x = from,
                                                 k,
                                                 .default = v)) %>%
    magrittr::set_names(names)
}
```

#### `resolve_q_val`

```{r}
resolve_q_val <- function(x,
                          ballot_date,
                          canton,
                          key,
                          lvl,
                          i,
                          j) {
  
  checkmate::assert_scalar(lvl, null.ok = TRUE)
  checkmate::assert_scalar(i, null.ok = TRUE)
  checkmate::assert_scalar(j, null.ok = TRUE)
  
  x %>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    purrr::when(is.character(.) ~ interpolate_q_val(.,
                                                    ballot_date = ballot_date,
                                                    canton = canton,
                                                    key = key,
                                                    lvl = lvl,
                                                    i = i,
                                                    j = j),
                ~ .) %>%
    # convert to proper type
    purrr::when(
      # character
      key %in% q_item_keys$key[q_item_keys$type == "character"] ~
        as.character(.),
      # logical
      key %in% q_item_keys$key[q_item_keys$type == "logical"] ~
        as.logical(.),
      # integer
      key %in% q_item_keys$key[q_item_keys$type == "integer"] ~
        as.integer(.),
      # double (theoretical only, none present so far)
      key %in% q_item_keys$key[q_item_keys$type == "double"] ~
        as.double(.),
      # undefined behaviour
      ~ cli::cli_abort("Undefined behaviour in {.fun resolve_q_val}. Please debug.")
    )
}
```

#### `interpolate_q_val`

NOTES:

-   `cli::pluralize()` collapses substituted vectors into a comma separated string, so we have to fall back to `glue::glue()` for arrays.

```{r}
interpolate_q_val <- function(vals,
                              ballot_date,
                              canton,
                              key,
                              lvl,
                              i,
                              j) {
  
  if (key %in% q_item_keys$key[q_item_keys$is_scalar]) {
    
    vals <- cli::pluralize(vals,
                           .trim = FALSE)
  } else {
    
    vals %<>%
      purrr::map(.f = glue::glue,
                 .envir = environment(),
                 .trim = FALSE) %>%
      unlist()
  }
  
  vals
}
```

#### Questionnaire-internal

##### `q_item_val`

```{r}
#' Extract questionnaire item field value
#'
#' Extracts a single questionnaire item field value for every first- for every second-level iterator from the [raw FOKUS questionnaire data][raw_q] based on the
#' specified variable name and branch path.
#' 
#' When used in questionnaire item field values via [string interpolation][glue::glue], be careful to not create infinite loops via circular references.
#'
#' @inheritParams ballot_type
#' @param v_name Variable name, without resolved string interpolation, i.e. 1:1 as stated in the raw FOKUS questionnaire data. A character scalar.
#' @param branch_path Sequence of questionnaire table levels that lead to the `item` leaf node where `v_name` is defined. A character vector.
#' @param key Questionnaire item key. One of
#' `r pal::as_md_list(paste0('"', q_item_keys$key, '"'), wrap = '``')`
#' @param i First-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. A character vector.
#' @param j Second-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. A character vector.
#'
#' @return A vector of the resolved item field values. Type and length resolved values depend on `key`.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_item_val(ballot_date = "2018-09-23",
#'                    canton = "aargau",
#'                    branch_path = c("03_proposal_specific", "004_participants"),
#'                    v_name = "appeal_federal_proposals",
#'                    key = "include")
#'
#' fokus:::q_item_val(
#'   ballot_date = "2019-10-20",
#'   canton = "aargau",
#'   branch_path = c("02_political_start", "002_non_participation",
#'                   "003_election", "z01_hypothetical"),
#'   v_name = "hypothetical_voting_decision_federal_majoritarian_election_{i}_seat_{j}",
#'   key = "topic",
#'   i = 1:2,
#'   j = 1:3
#' )
q_item_val <- function(ballot_date = ballot_dates,
                       canton = cantons,
                       branch_path,
                       v_name,
                       key = q_item_keys$key,
                       lvl = "?",
                       i = "?",
                       j = "?") {
  
  checkmate::assert_character(branch_path,
                              any.missing = FALSE,
                              min.len = 1L)
  checkmate::assert_string(v_name)
  key <- rlang::arg_match(key)
  
  # traverse questionnaire branch path and complement inheritable map
  parent_map <- init_heritable_map(block = branch_path[1L])
  
  for (branch_depth in purrr::accumulate(branch_path, c)) {
    
    parent_map %<>% complement_heritable_map(from = purrr::chuck(raw_q, !!!branch_depth))
  }
  
  item_map <-
    raw_q %>%
    purrr::chuck(!!!branch_path, "item") %>%
    purrr::keep(.p = ~ isTRUE(.x$variable_name == v_name)) %>%
    purrr::flatten()
  
  if (!rlang::has_name(x = item_map, name = "variable_name")) {
    cli::cli_abort(paste0("There is no item with {.arg variable_name} {.val {v_name}} defined under the questionnaire branch path {.field ",
                          pal::prose_ls(x = branch_path,
                                        separator = " -> ",
                                        last_separator = " -> "),
                          "}."))
  }
  
  raw_val <-
    parent_map %>%
    complement_heritable_map(from = item_map) %>%
    purrr::chuck(key)
  
  lvl %>%
    purrr::map(function(lvl) {
      
      purrr::map(.x = i,
                 lvl = lvl,
                 .f = function(i,
                               lvl) {
                   
                   purrr::map(.x = j,
                              i = i,
                              lvl = lvl,
                              .f = function(j,
                                            i,
                                            lvl) {
                                
                                resolve_q_val(x = raw_val,
                                              ballot_date = ballot_date,
                                              canton = canton,
                                              key = key,
                                              lvl = lvl,
                                              i = i,
                                              j = j)
                              })
                 })
    }) %>%
    unlist()
}
```

##### `q_parties`

This fn is used inside the TOML questionnaire only.

```{r}
#' Political parties
#'
#' A tibble of political party metadata defined in the [raw FOKUS questionnaire data][raw_q].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family q_internal
#' @keywords internal
q_parties <- function() {
  
  raw_q %>%
    purrr::chuck("party") %>%
    purrr::map(as_flat_list) %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

##### `q_response_options`

```{r}
#' Extract response options
#'
#' Extracts response options of the specified type and optionally subtype(s) from the [raw FOKUS questionnaire data][raw_q].
#'
#' Note that only recurring response options are returned which are defined under the `response_options` top-level key in the file
#' `data-raw/questionnaire/questionnaire.toml`.
#'
#' @inheritParams election_name
#' @param type Response option type. One of
#' `r pal::as_md_list(paste0('"', response_option_types, '"'), wrap = '``')`
#' @param subtypes Hierarchical response option subtypes as a character vector, or `NULL`. If `NULL`, all subtypes are returned.
#'
#' @return A character vector.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de")
#'
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de",
#'                            subtypes = "election")
#'
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de",
#'                            subtypes = c("election", "proportional"))
q_response_options <- function(type = response_option_types,
                               lang = c("de", "en"),
                               subtypes = NULL) {
  
  type <- rlang::arg_match(type)
  lang <- rlang::arg_match(lang)
  checkmate::assert_character(subtypes,
                              any.missing = FALSE,
                              min.len = 1L,
                              null.ok = TRUE)
  raw_q %>%
    purrr::chuck("response_options", type, lang, !!!subtypes) %>%
    pal::as_chr()
}
```

##### `q_response_option_codes`

```{r}
#' Extract response option codes
#'
#' Extracts response option codes of the specified type(s) from the [raw FOKUS questionnaire data][raw_q].
#'
#' Note that only codes of recurring response options are returned which are defined under the `response_options` top-level key in the file
#' `data-raw/questionnaire/questionnaire.toml`.
#'
#' @param types Response option types. One or more of
#' `r pal::as_md_list(paste0('"', response_option_types, '"'), wrap = '``')`
#'
#' @return An integer vector.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_response_option_codes(types = "abstain")
#'
#' fokus:::q_response_option_codes(types = c("dunno",
#'                                           "custom",
#'                                           "abstain"))
q_response_option_codes <- function(types = response_option_types) {
  
  types <- unique(checkmate::assert_subset(types,
                                           choices = response_option_types,
                                           empty.ok = FALSE))
  
  types %>% purrr::map_int(~ raw_q %>% purrr::chuck("response_options", .x, "code"))
}
```

### Miscellaneous

#### `assert_countish`

Assertion that

-   allows a count as a character-scalar and converts its input to an integer scalar.
-   checks for `positive = TRUE` *by default*.

```{r}
assert_countish <- function(x,
                            positive = TRUE,
                            null_ok = FALSE) {
  
  if (null_ok && is.null(x)) {
    x
    
  } else {
    checkmate::assert_count(as.integer(x),
                            positive = positive)
  }
}
```

#### `assert_integerish`

Assertion that

-   allows integers as characters and converts its input to type integer.
-   forbids missing values *by default*.

```{r}
assert_integerish <- function(x,
                              lower = -Inf,
                              upper = Inf,
                              any_missing = FALSE,
                              all_missing = FALSE,
                              null_ok = FALSE) {
  
  if (null_ok && is.null(x)) {
    x
    
  } else {
    checkmate::assert_integerish(x,
                                 lower = lower,
                                 upper = upper,
                                 any.missing = any_missing,
                                 all.missing = all_missing,
                                 coerce = TRUE)
  }
}
```

#### `as_flat_list`

NOTES:

-   This differs substantially from `pal::as_flat_list()`; it preserves all (sub)names by concatenating them but doesn't preserve any attributes, so data frames
    & co. are destroyed.

```{r}
as_flat_list <- function(x) {
  
  result <- x
  depth <- purrr::vec_depth(result)
  
  # unlist until only a single list level remains
  while (depth > 2L) {
    
    result %<>% unlist(recursive = FALSE)
    depth <- purrr::vec_depth(result)
  }
  
  # wrap in list if necessary
  if (depth < 2L && !is.list(x)) {
    
    result <- list(x)
  }
  
  result
}
```

#### `collapse_break`

Collapse char vector into single string separated by single HTML line breaks (`<br>` tags)

```{r}
collapse_break <- function(s) {
  
  paste0(s, collapse = "<br>")
}
```

#### `wrap_backtick`

Wrap a char vector in backticks

```{r}
wrap_backtick <- function(s) {
  
  purrr::map_chr(.x = s,
                 .f = ~ dplyr::if_else(.x == "-" | stringr::str_detect(string = .x,
                                                                       pattern = "^(_.*_|\\*.*\\*)$"),
                                       as.character(.x),
                                       paste0("`", .x, "`")))
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

### Messages

```{r}
```

### Unicode sequences

```{r}
unicode_checkmark <- "\u2705"
unicode_crossmark <- "\u274C"
unicode_ellipsis  <- "\u2026"
```

### Miscellaneous

```{r}
global_cache_lifespan <- "30 days"

# questionnaire item subkeys (lowest level only, i.e. without ballot types)
q_item_subkeys <- c("true",
                    "false",
                    "default",
                    "YYYYMMDD",
                    "YYYYMMDD_YYYYMMDD")
```

# EXPORTED

## FOKUS metadata

### DESCRIPTION

Metadata about the FOKUS surveys, generated from the raw supplemental date-specific questionnaire data files found under
[`data-raw/questionnaire/YYYY-MM-DD.toml`](https://gitlab.com/zdaarau/rpkgs/fokus/-/tree/master/data-raw/questionnaire/) that serve as the "source of truth" for
the [predicate functions](#section-predicates).

### `ballot_dates`

TODO:

-   Unfortunately, the roxygen2 `@family` tag doesn't seem to work for datasets. Thus, we manually specify the documentation links using `@seealso` ->
    investigate the underlying cause and ideally file a bug report.

```{r}
#' List FOKUS-covered ballot dates
#'
#' A vector of ballot dates covered by FOKUS surveys up until `r max(ballot_dates)`.
#'
#' @format `r pkgsnip::return_label("dates")`
#' @seealso [`cantons`][cantons] [`ballot_metadata`][ballot_metadata] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys]
#'   [`proposal_types`][proposal_types]
#' @export
"ballot_dates"
```

### `cantons`

```{r}
#' List cantons that are covered in *any* FOKUS survey
#'
#' A vector of cantons that were part of at least one FOKUS survey up until `r max(ballot_dates)`.
#'
#' @format A character vector.
#' @seealso [`ballot_dates`][ballot_dates] [`ballot_metadata`][ballot_metadata] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys]
#'   [`proposal_types`][proposal_types]
#' @export
"cantons"
```

### `ballot_metadata`

```{r}
#' FOKUS ballot-date-canton metadata
#'
#' A tibble of FOKUS-survey-related ballot-date-canton metadata, valid up until `r max(ballot_dates)`.
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys]
#'   [`proposal_types`][proposal_types]
#' @export
"ballot_metadata"
```

### `proposal_types`

```{r}
#' Referendum proposal types
#'
#' A vector of all [referendum proposal types][proposal_type].
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`ballot_metadata`][ballot_metadata] [`response_option_types`][response_option_types]
#'   [`q_item_keys`][q_item_keys]
#' @export
"proposal_types"
```

### `response_option_types`

```{r}
#' List available response option types
#'
#' A vector of all response option types defined in the [raw FOKUS questionnaire data][raw_q].
#'
#' @format A character vector.
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`ballot_metadata`][ballot_metadata] [`proposal_types`][proposal_types]
#'   [`q_item_keys`][q_item_keys]
#' @export
"response_option_types"
```

### `q_item_keys`

```{r}
#' List supported questionnaire item keys
#'
#' A tibble of item keys supported in the [raw FOKUS questionnaire data][raw_q].
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`ballot_metadata`][ballot_metadata] [`response_option_types`][response_option_types]
#'   [`proposal_types`][proposal_types]
#' @export
"q_item_keys"
```

## Predicates

### DESCRIPTION

Predicate functions based on the [metadata](#section-fokus-metadata).

### Fundamental predicates

#### `ballot_types`

```{r}
#' Determine ballot types
#'
#' Determines the types of the ballot for the specified canton at the specified date.
#'
#' @inheritParams ballot_type
#'
#' @return A character vector of ballot types. One or more of
#'   - `"referendum"`
#'   - `"election"`
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::ballot_types(ballot_date = "2018-09-23",
#'                     canton = "aargau")
ballot_types <- function(ballot_date = ballot_dates,
                         canton = cantons) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  has_election <- has_election(ballot_date = ballot_date,
                               canton = canton)
  
  has_referendum <- has_referendum(ballot_date = ballot_date,
                                   canton = canton)
  
  c("referendum"[has_referendum],
    "election"[has_election])
}
```

#### `ballot_type`

```{r}
#' Determine ballot type
#'
#' Determines the type of the ballot for the specified canton at the specified date.
#'
#' @param ballot_date A valid FOKUS-covered cantonal ballot date. One of
#' `r pal::as_md_list(paste0('"', ballot_dates, '"'), wrap = '``')`
#' @param canton A valid FOKUS canton. One of
#' `r pal::as_md_list(paste0('"', cantons, '"'), wrap = '``')`
#'
#' @return Ballot type as a character scalar. One of
#' `r pal::as_md_list(paste0('"', q_ballot_types, '"'), wrap = '``')`
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::ballot_type(ballot_date = "2018-09-23",
#'                    canton = "aargau")
ballot_type <- function(ballot_date = ballot_dates,
                        canton = cantons) {
  
  ballot_types(ballot_date = ballot_date,
               canton = canton) %>%
    purrr::when(length(.) > 1L ~ "both_referendum_and_election",
                ~ .)
}
```

#### `n_proposals`

```{r}
#' Get number of referendum proposals
#'
#' Determines the number of referendum proposals for a canton at the specified ballot date on the specified political level(s).
#'
#' Technically, the number of *federal* proposals is independent from the canton, but this function still expects a valid `canton`. Nonetheless, the returned
#' number of *federal* proposals at a specific ballot date is always the same regardless of `canton`.
#'
#' @inheritParams n_elections
#'
#' @inherit n_elections return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::n_proposals(ballot_date = "2018-09-23",
#'                    canton = "aargau")
n_proposals <- function(ballot_date = ballot_dates,
                        lvls = c("cantonal", "federal"),
                        canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = c("cantonal", "federal"),
                                          empty.ok = FALSE))
  
  data_subset <-
    ballot_metadata %>%
    dplyr::filter(ballot_date == !!ballot_date,
                  canton == !!canton)
  
  glue::glue("n_{lvls}_proposals") %>%
    purrr::map_int(~ data_subset[[.x]]) %>%
    sum()
}
```

#### `n_elections`

```{r}
#' Get number of elections
#'
#' Determines the number of elections for a canton at the specified ballot date on the specified political level(s) and of the specified election procedure(s).
#'
#' @inheritParams ballot_type
#' @param lvls Political level(s). One or more of
#'   - `"cantonal"`
#'   - `"federal"`
#' @param prcds Election procedure(s). One or more of
#'   - `"proportional"`
#'   - `"majoritarian"`
#'
#' @return An integer.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::n_elections(ballot_date = "2018-09-23",
#'                    canton = "aargau")
n_elections <- function(ballot_date = ballot_dates,
                        lvls = c("cantonal", "federal"),
                        canton = cantons,
                        prcds = c("proportional", "majoritarian")) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = c("cantonal", "federal"),
                                          empty.ok = FALSE))
  canton <- rlang::arg_match(canton)
  prcds <- unique(checkmate::assert_subset(prcds,
                                           choices = c("proportional", "majoritarian"),
                                           empty.ok = FALSE))
  
  data_subset <-
    ballot_metadata %>%
    dplyr::filter(ballot_date == !!ballot_date,
                  canton == !!canton)
  
  lvls %>%
    purrr::map(function(lvls) {
      glue::glue("n_{lvls}_{prcds}_elections")
    }) %>%
    purrr::flatten_chr() %>%
    purrr::map_int(~ data_subset[[.x]]) %>%
    sum()
}
```

#### `has_referendum`

```{r}
#' Determine whether ballot type includes a referendum
#'
#' Determines whether or not the ballot in the specified canton at the specified date on the specified political level(s) includes a referendum.
#'
#' Note that if more than one `lvls` are provided (the default), they are interpreted according to the rules of [logical
#' disjunction](https://en.wikipedia.org/wiki/Logical_disjunction), i.e. `TRUE` is returned if *any* `lvls` are included in the specified ballot.
#' 
#' For [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction), use `has_referendum(lvls = "cantonal") && has_referendum(lvls = "federal")`.
#'
#' @inheritParams n_elections
#'
#' @inherit has_election return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_referendum(ballot_date = "2018-09-23",
#'                       lvls = "federal",
#'                       canton = "aargau")
has_referendum <- function(ballot_date = ballot_dates,
                           lvls = c("cantonal", "federal"),
                           canton = cantons) {
  
  n_proposals(ballot_date = ballot_date,
              lvls = lvls,
              canton = canton) > 0L
}
```

#### `has_election`

```{r}
#' Determine whether ballot type includes an election
#'
#' Determines whether or not the ballot for the specified canton at the specified date on the specified political level(s) includes an election of the specified
#' election procedure(s).
#'
#' Note that if more than one `lvls`/`prcds` are provided (the default), they are interpreted according to the rules of [logical
#' disjunction](https://en.wikipedia.org/wiki/Logical_disjunction), i.e. `TRUE` is returned if *any* `lvls`/`prcds` are included in the specified ballot.
#' 
#' For [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction), use e.g. `has_election(lvls = "cantonal") && has_election(lvls = "federal")`.
#'
#' @inheritParams n_elections
#'
#' @return A logical scalar.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_election(ballot_date = "2018-09-23",
#'                     canton = "aargau")
has_election <- function(ballot_date = ballot_dates,
                         lvls = c("cantonal", "federal"),
                         canton = cantons,
                         prcds = c("proportional", "majoritarian")) {
  
  n_elections(ballot_date = ballot_date,
              lvls = lvls,
              canton = canton,
              prcds = prcds) > 0L
}
```

#### `has_lvl`

```{r}
#' Determine whether ballot includes a political level
#'
#' Determines whether or not the ballot in the specified canton at the specified date includes the specified political level.
#'
#' @inheritParams election_name
#'
#' @inherit has_election return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_lvl(ballot_date = "2018-09-23",
#'                lvl = "federal",
#'                canton = "aargau")
has_lvl <- function(ballot_date = ballot_dates,
                    lvl = c("cantonal", "federal"),
                    canton = cantons) {
  
  lvl <- rlang::arg_match(lvl)
  
  has_election(ballot_date = ballot_date,
               lvls = lvl,
               canton = canton) ||
    has_referendum(ballot_date = ballot_date,
                   lvls = lvl,
                   canton = canton)
}
```

### Proposal predicates

#### `proposal_type`

```{r}
#' Get proposal type
#'
#' @inheritParams proposal_name
#'
#' @return Proposal type. One of
#' `r pal::as_md_list(paste0('"', proposal_types, '"'), wrap = '``')`
#' 
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_type(ballot_date = "2018-09-23",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      proposal_nr = 1)
proposal_type <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          proposal_nr = 1L) {
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::chuck("type")
}
```

#### `proposal_name`

```{r}
#' Get proposal name
#'
#' Returns the name of the specified proposal in the specified language.
#'
#' @inheritParams ballot_type
#' @param lvl Political level. One of
#'   - `"cantonal"`
#'   - `"federal"`
#' @param proposal_nr Proposal number. A positive integer scalar.
#' @param lang Language. One of
#'   - `"de"`
#'   - `"en"`
#' @param type Name type. One of
#'   - `"short"`
#'   - `"long"`
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_name(ballot_date = "2018-09-23",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      proposal_nr = 1,
#'                      type = "long")
proposal_name <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          proposal_nr = 1L,
                          lang = c("de", "en"),
                          type = c("short", "long")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            proposal_nr = proposal_nr) %>%
    purrr::chuck(lang, type, "text")
}
```

#### `proposal_name_gender`

```{r}
#' Get German proposal name's grammatical gender
#'
#' Returns the grammatical gender of the German name of the specified proposal.
#'
#' @inheritParams proposal_name
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_name_gender(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1,
#'                             type = "short")
proposal_name_gender <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr = 1L,
                                 type = c("short", "long")) {
  
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            proposal_nr = proposal_nr) %>%
    purrr::chuck("de", type, "gender")
}
```

#### `proposal_arguments`

```{r}
#' Get proposal's arguments
#'
#' Returns text, side and number of all arguments on the specified proposal.
#'
#' @inheritParams proposal_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_arguments(ballot_date = "2018-09-23",
#'                           lvl = "cantonal",
#'                           canton = "aargau",
#'                           proposal_nr = 1)
proposal_arguments <- function(ballot_date = ballot_dates,
                               lvl = c("cantonal", "federal"),
                               canton = cantons,
                               proposal_nr = 1L) {
  
  raw_q_suppl_arguments(ballot_date = ballot_date,
                        lvl = lvl,
                        canton = canton,
                        proposal_nr = proposal_nr) %>%
    purrr::map(as_flat_list) %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `proposal_main_motives`

```{r}
#' Get proposal's main motives
#'
#' Returns text and code number of all main motives on the specified proposal.
#'
#' @inheritParams proposal_name
#' @param type Main motive type. One of
#'   - `"yes"`
#'   - `"no"`
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_main_motives(ballot_date = "2018-09-23",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              proposal_nr = 1,
#'                              type = "no")
proposal_main_motives <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  proposal_nr = 1L,
                                  type = c("yes",
                                           "no")) {
  type <- rlang::arg_match(type)
  
  raw_q_suppl_main_motives(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           proposal_nr = proposal_nr) %>%
    purrr::chuck(type) %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `n_proposal_main_motives`

```{r}
#' Get proposal's number of main motives
#'
#' Determines the number of main motives on the specified proposal.
#'
#' @inheritParams proposal_main_motives
#'
#' @return An integer scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::n_proposal_main_motives(ballot_date = "2018-09-23",
#'                                lvl = "cantonal",
#'                                canton = "aargau",
#'                                proposal_nr = 1,
#'                                type = "no")
n_proposal_main_motives <- function(ballot_date = ballot_dates,
                                    lvl = c("cantonal", "federal"),
                                    canton = cantons,
                                    proposal_nr = 1L,
                                    type = c("yes",
                                             "no")) {
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::pluck("main_motive") %>%
    purrr::pluck(type) %>%
    length()
}
```

#### `n_proposal_arguments`

```{r}
#' Get proposal's number of arguments
#'
#' Determines the number of arguments on the specified proposal.
#'
#' @inheritParams proposal_main_motives
#'
#' @return An integer scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::n_proposal_arguments(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1)
n_proposal_arguments <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr = 1L) {
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::pluck("argument") %>%
    length()
}
```

### Election predicates

#### `n_election_candidates`

```{r}
#' Get number of (officially registered) majoritarian election candidates
#'
#' Determines the number of (officially registered) candidates of a majoritarian election at the specified ballot date on the specified political level.
#'
#' @inheritParams election_name
#'
#' @return An integer scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::n_election_candidates(ballot_date = "2019-10-20",
#'                              lvl = "cantonal",
#'                              canton = "aargau")
n_election_candidates <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    length()
}
```

#### `n_election_seats`

```{r}
#' Get number of majoritarian election seats
#'
#' Determines the number of election seats of the specified type for the specified majoritarian election.
#'
#' @inheritParams election_name
#' @param type Seat type. One of
#'  - `"vacant"`
#'  - `"total"`
#'
#' @return An integer scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::n_election_seats(ballot_date = "2019-10-20",
#'                         lvl = "cantonal",
#'                         canton = "aargau",
#'                         type = "total")
n_election_seats <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L,
                             type = c("vacant", "total")) {
  
  type <- rlang::arg_match(type)
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("n_seats", type)
}
```

#### `election_name`

```{r}
#' Get election name
#'
#' Returns the name of the specified election in the specified language.
#'
#' @inheritParams proposal_name
#' @param prcd Election procedure. One of
#'   - `"proportional"`
#'   - `"majoritarian"`
#' @param election_nr Election number. A positive integer scalar (in almost all cases `1L`).
#' @param type Name type. One of
#'   - `"short"`
#'   - `"long"`
#'   - `"body"`
#'   - `"body_alt"`
#'
#' @return A character scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_name(ballot_date = "2019-10-20",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      prcd = "majoritarian",
#'                      election_nr = 1,
#'                      type = "body")
election_name <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          prcd = c("proportional", "majoritarian"),
                          election_nr = 1L,
                          lang = c("de", "en"),
                          type = c("short", "long", "body", "body_alt")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  
  raw_q_suppl_election_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            prcd = prcd,
                            election_nr = election_nr) %>%
    purrr::chuck(lang, type, "text")
}
```

#### `election_names_combined`

```{r}
#' Get combined elections name
#'
#' Returns the combined name of all elections at the specified date on the specified level for the specified canton.
#'
#' @inheritParams election_name
#'
#' @return A character scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_names_combined(ballot_date = "2019-10-20",
#'                                lvl = "cantonal",
#'                                canton = "aargau")
election_names_combined <- function(ballot_date = ballot_dates,
                                    lvl = c("cantonal", "federal"),
                                    canton = cantons) {
  
  raw_q_suppl_elections(ballot_date = ballot_date,
                        lvl = lvl,
                        canton = canton) %>%
    purrr::chuck("names_combined", "de", "short")
}
```

#### `election_candidates`

```{r}
#' Get majoritarian election's candidates
#'
#' Returns the name and party of all candidates running for the specified majoritarian election.
#'
#' @inheritParams election_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_candidates(ballot_date = "2019-10-20",
#'                            lvl = "cantonal",
#'                            canton = "aargau")
election_candidates <- function(ballot_date = ballot_dates,
                                lvl = c("cantonal", "federal"),
                                canton = cantons,
                                election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `election_candidate_string`

```{r}
#' Assemble majoritarian election's candidate string(s)
#'
#' Assembles one or more majoritarian election candidate string(s) consisting of the candidate's first name, last name and optionally political party (in
#' parentheses).
#'
#' @inheritParams election_name
#' @param candidate_nrs Election candidate numbers to include. A vector of positive integers or `NULL`. If `NULL`, all candidates will be included.
#' @param incl_party Whether or not to include the candidate's political party in the resulting string (in parentheses).
#'
#' @return A character vector.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_candidate_string(ballot_date = "2019-10-20",
#'                                  lvl = "cantonal",
#'                                  canton = "aargau",
#'                                  candidate_nrs = 1:3)
election_candidate_string <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      election_nr = 1L,
                                      candidate_nrs = NULL,
                                      incl_party = TRUE) {
  
  data_candidates <- election_candidates(ballot_date = ballot_date,
                                         lvl = lvl,
                                         canton = canton,
                                         election_nr = election_nr)
  
  candidate_nrs <- assert_integerish(candidate_nrs,
                                     lower = 1L,
                                     upper = nrow(data_candidates),
                                     null_ok = TRUE)
  checkmate::assert_flag(incl_party)
  
  if (length(candidate_nrs)) {
    data_candidates %<>% dplyr::filter(dplyr::row_number() %in% candidate_nrs)
  }
  
  data_candidates %>% purrr::pmap_chr(incl_party = incl_party,
                                      .f = function(first_name, last_name, party, incl_party) {
                                        paste0(first_name, " ", last_name, paste0(" (", party, ")")[incl_party])
                                      })
}
```

#### `election_parties`

```{r}
#' Get proportional election's political parties
#'
#' Returns the questionnaire code as well as different versions of the name of all parties for the specified proportional election.
#'
#' @inheritParams election_name
#' @param past Whether to extract the current or the predecessor election's parties.
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_parties(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau")
#'
#' fokus::election_parties(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau",
#'                         past = TRUE)
election_parties <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L,
                             past = FALSE) {
  
  checkmate::assert_flag(past)
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "proportional",
                       election_nr = election_nr) %>%
    purrr::chuck(dplyr::if_else(past,
                                "past_party",
                                "party")) %>%
    purrr::map(as_flat_list) %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `election_tickets`

```{r}
#' Get proportional election's tickets
#'
#' Returns the name, number and party of all tickets for the specified proportional election.
#'
#' @inheritParams election_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_tickets(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau")
election_tickets <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "proportional",
                       election_nr = election_nr) %>%
    purrr::chuck("ticket") %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `requires_candidate_registration`

```{r}
#' Determine whether majoritarian election requires candidate registration
#'
#' Determines whether or not candidates must be officially registered prior to the specified majority election.
#' 
#' The absence of a candidate registration requirement usually means that every eligible citizen can be elected, i.e. receive valid votes.
#'
#' @inheritParams election_name
#'
#' @return A logical scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::requires_candidate_registration(ballot_date = "2019-10-20",
#'                                        lvl = "federal",
#'                                        canton = "aargau")
requires_candidate_registration <- function(ballot_date = ballot_dates,
                                            lvl = c("cantonal", "federal"),
                                            canton = cantons,
                                            election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("requires_candidate_registration")
}
```

### Skill question predicates

#### `n_skill_questions`

```{r}
#' Get number of skill questions
#'
#' Determines the number of skill questions at the specified ballot date on the specified political level.
#'
#' @inheritParams election_name
#' @param canton A valid FOKUS canton. One of
#' `r pal::as_md_list(paste0('"', cantons, '"'), wrap = '``')`
#' 
#' Only relevant if `lvl = "cantonal"`.
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, the number of non-proposal-specific skill questions is returned.
#'
#' @return An integer scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::n_skill_questions(ballot_date = "2018-09-23",
#'                          lvl = "cantonal",
#'                          canton = "aargau",
#'                          proposal_nr = 1)
n_skill_questions <- function(ballot_date = ballot_dates,
                              lvl = c("cantonal", "federal"),
                              canton = cantons,
                              proposal_nr = NULL) {
  
  lvl <- rlang::arg_match(lvl)
  canton <- rlang::arg_match(canton)
  proposal_nr <- assert_countish(proposal_nr,
                                 null_ok = TRUE)
  lvl %>%
    purrr::when(
      
      # federal non-proposal-specific skill questions (e.g. at federal elections)
      length(proposal_nr) == 0L && . == "federal" ~
        raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl),
      # cantonal non-proposal-specific skill questions (e.g. at cantonal elections)
      length(proposal_nr) == 0L && . == "cantonal" ~
        raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl) %>%
        purrr::pluck(canton),
      # federal or cantonal proposal-specific skill questions
      ~ raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl) %>%
        purrr::when(lvl == "cantonal" ~ purrr::pluck(., canton),
                    ~ .) %>%
        purrr::pluck("proposal") %>%
        purrr::pluck(proposal_nr)
    ) %>%
    purrr::pluck("skill_question") %>%
    length()
}
```

#### `skill_question`

```{r}
#' Get skill question
#'
#' Returns the skill question text in the specified language.
#'
#' @inheritParams proposal_name
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, it is considered to be a non-proposal-specific skill question 
#'   (the case at elections).
#' @param skill_question_nr Skill question number. A positive integer scalar.
#'
#' @return A character scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question(ballot_date = "2018-09-23",
#'                       lvl = "cantonal",
#'                       canton = "aargau",
#'                       proposal_nr = 1,
#'                       skill_question_nr = 2,
#'                       lang = "en")
skill_question <- function(ballot_date = ballot_dates,
                           lvl = c("cantonal", "federal"),
                           canton = cantons,
                           proposal_nr = NULL,
                           skill_question_nr,
                           lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck(lang)
}
```

#### `skill_question_response_options`

```{r}
#' Get skill question response options
#'
#' Returns the response options of the specified skill question together with the information whether they are correct or not.
#'
#' @inheritParams skill_question
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_response_options(ballot_date = "2018-09-23",
#'                                        lvl = "cantonal",
#'                                        canton = "aargau",
#'                                        proposal_nr = 1,
#'                                        skill_question_nr = 2)
skill_question_response_options <- function(ballot_date = ballot_dates,
                                            lvl = c("cantonal", "federal"),
                                            canton = cantons,
                                            proposal_nr = NULL,
                                            skill_question_nr) {
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `skill_question_answer_nr`

```{r}
#' Get correct skill question answer number
#'
#' Returns the sequential number of the correct answer for the specified skill question.
#'
#' @inheritParams skill_question
#'
#' @return An integer scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_answer_nr(ballot_date = "2018-09-23",
#'                                 lvl = "cantonal",
#'                                 canton = "aargau",
#'                                 proposal_nr = 1,
#'                                 skill_question_nr = 2)
skill_question_answer_nr <- function(ballot_date = ballot_dates,
                                     lvl = c("cantonal", "federal"),
                                     canton = cantons,
                                     proposal_nr = NULL,
                                     skill_question_nr) {
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map_depth(.depth = 1L,
                     .f = ~ .x$is_correct) %>%
    purrr::flatten_lgl() %>%
    which()
}
```

### Other predicates

#### `political_issues`

```{r}
#' Get political issues
#'
#' Returns the political issues in the specified language.
#'
#' @inheritParams proposal_name
#'
#' @return A character vector.
#' @family predicate_other
#' @export
#'
#' @examples
#' fokus::political_issues(ballot_date = "2019-10-20",
#'                         lang = "en")
political_issues <- function(ballot_date = ballot_dates,
                             lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  result <-
    raw_q_suppl(ballot_date = ballot_date) %>%
    purrr::pluck("political_issues")
  
  if (is.null(result)) {
    
    # reduce to proper arg value for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    
    cli::cli_abort("No political issues present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  result %>%
    purrr::chuck("issue") %>%
    purrr::map_depth(1L, purrr::chuck, lang) %>%
    purrr::flatten_chr()
}
```

## Questionnaire

### DESCRIPTION

Functions to process the raw FOKUS questionnaire data.

### `gen_q`

```{r}
#' Generate questionnaire
#'
#' This is the main questionnaire generation interface that's doing all the magic. This function is only called for its side effects, it doesn't return
#' anything.
#'
#' @inheritParams ballot_type
#' @param quiet `r pkgsnip::param_label("quiet")`
#'   
#' Either as a character or a [date][base::Date] scalar.
#'
#' @return `NULL`, invisibly.
#' @family q_gen
#' @export
gen_q <- function(ballot_date = ballot_dates,
                  canton = cantons,
                  quiet = FALSE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  checkmate::assert_flag(quiet)
  
  # generate questionnaire tibble
  if (!quiet) {
    status_msg <- "Generating questionnaire data..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  q_tibble <- q_tibble(ballot_date = ballot_date,
                       canton = canton)
  
  # expand questionnaire tibble to long data format
  if (!quiet) {
    status_msg <- "Expanding questionnaire data to long format..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  q_tibble %<>% expand_q_tibble()
  
  readr::write_rds(file = path_private(glue::glue("output/data/internal/r/questionnaire_{ballot_date}_{canton}.rds")),
                   compress = "xz",
                   compression = 9L)
  
  # generate Markdown questionnaire
  if (!quiet) {
    status_msg <- "Generating Markdown questionnaire..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  knitr::knit2pandoc(input = path_private("rmd/questionnaire.Rmd"),
                     output = path_private(glue::glue("output/questionnaires/questionnaire_{ballot_date}_{canton}.md")),
                     quiet = TRUE,
                     tangle = FALSE,
                     to = "gfm",
                     encoding = "UTF-8")
  
  invisible(NULL)
}
```

### `q_tibble`

```{r}
#' Generate questionnaire tibble
#'
#' @inheritParams ballot_type
#' @param verbose Whether or not to print progress information during questionnaire generation.
#'
#' @return `r pkgsnip::return_label("data")`
#' @family q_gen
#' @export
q_tibble <- function(ballot_date = ballot_dates,
                     canton = cantons,
                     verbose = FALSE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  raw_q_suppl <- raw_q_suppl(ballot_date = ballot_date)
  
  # initialize across-block item enumerator
  item_enumerator <- 1L
  
  # assemble questionnaire
  purrr::map_dfr(.x = names(raw_q),
                 verbose = verbose,
                 .f = function(block, verbose) {
                   
                   if (verbose) cli::cli_h1("MAIN BLOCK: {.val {block}}")
                   
                   # determine item enumeration prefix
                   prefix <- raw_q %>% purrr::pluck(block, "prefix",
                                                    .default = 0L)
                   
                   # determine item enumeration start
                   item_enumeration_start <- dplyr::if_else(prefix == 0L,
                                                            item_enumerator,
                                                            1L)
                   
                   # traverse list `raw_q` recursively and assemble items
                   questionnaire <- assemble_deep(data_q = raw_q[[block]],
                                                  lvl_name = block,
                                                  heritable_map = init_heritable_map(block = block),
                                                  generate_md = FALSE,
                                                  verbose = verbose)
                   
                   # only proceed if it is an actual questionnaire block (i.e. contains table items)
                   if (length(questionnaire)) {
                     
                     questionnaire %<>%
                       # "unpack" results list
                       pal::reduce_df_list() %>%
                       # add item enumeration
                       dplyr::mutate(nr = seq(from = item_enumeration_start + prefix,
                                              to = item_enumeration_start + prefix + nrow(.) - 1L,
                                              by = 1L),
                                     block = block) %>%
                       # reorder cols
                       dplyr::select(nr, block, everything())
                     
                     # update item enumerator
                     if (prefix == 0L) item_enumerator <<- item_enumerator + nrow(questionnaire)
                     
                   } else questionnaire <- NULL
                   
                   questionnaire
                 })
}
```

### `q_md`

```{r}
#' Generate Markdown questionnaire
#'
#' @inheritParams ballot_type
#'
#' @return A character vector.
#' @family q_gen
#' @export
q_md <- function(ballot_date = ballot_dates,
                 canton = cantons) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  raw_q_suppl <- raw_qx_suppl[[ballot_date]]
  
  # initialize block enumerator
  block_enumerator <- 1L
  
  # initialize across-block item enumerator
  item_enumerator <- 1L
  
  # traverse list `raw_q` recursively to assemble questionnaire
  purrr::map(.x = names(raw_q),
             .f = function(block) {
               
               # determine item enumeration prefix
               prefix <- purrr::pluck(.x = raw_q,
                                      block, "prefix",
                                      .default = 0L)
               
               # determine item enumeration start
               item_enumeration_start <- dplyr::if_else(prefix == 0L,
                                                        item_enumerator,
                                                        1L)
               
               # generate table body
               table_body <- gen_table_body(raw_q = raw_q,
                                            block = block,
                                            enumeration_start = item_enumeration_start)
               
               # only proceed if it is an actual questionnaire block (i.e. contains table items)
               if (length(table_body)) {
                 
                 # update item enumerator
                 if (prefix == 0L) item_enumerator <<- item_enumerator + length(table_body)
                 
                 # determine block "number"
                 block_nr <-
                   raw_q %>%
                   purrr::pluck(block, "nr") %>%
                   glue::glue(.trim = FALSE)
                 
                 # handle auto-enumeration
                 if (length(block_nr) == 0L) {
                   
                   block_nr <- block_enumerator
                   block_enumerator <<- block_enumerator + 1L
                 }
                 
                 # assemble block header
                 whole_block <-
                   purrr::pluck(raw_q,
                                block, "title") %>%
                   glue::glue(.trim = FALSE) %>%
                   purrr::when(is.null(.) ~ "",
                               ~ paste0(": ", .)) %>%
                   paste0("## Block ", block_nr, ., "\n")
                 
                 # add block intro and table
                 whole_block <-
                   purrr::pluck(raw_q,
                                block, "intro") %>%
                   raw_pick_right(ballot_date = ballot_date,
                                  canton = canton) %>%
                   purrr::when(is.null(.) ~ character(),
                               ~ glue::glue(., "\n",
                                            .trim = FALSE)) %>%
                   c(whole_block,
                     .,
                     gen_table_header(),
                     table_body) %>%
                   paste0(collapse = "\n") %>%
                   paste0("\n\n")
                 
                 return(whole_block)
                 
               } else return(NULL)
             }) %>%
    purrr::flatten_chr() %>%
    cat(sep = "\n")
  
  # assemble footnotes
  raw_q$footnote %>%
    purrr::map(.f = assemble_md_ref_item,
               canton = canton,
               ballot_date = ballot_date) %>%
    purrr::flatten_chr() %>%
    cat("",
        sep = "\n\n")
  
  # assemble reference-style links
  raw_q$link %>%
    purrr::map(.f = assemble_md_ref_item,
               canton = canton,
               ballot_date = ballot_date) %>%
    purrr::flatten_chr() %>%
    cat("",
        sep = "\n\n")
}
```

## Variable-related

### `is_skill_question`

```{r}
#' Determine whether variable is skill question
#'
#' Determines whether or not a variable is a skill question. Vectorized.
#'
#' @param v_names A character vector of FOKUS variable names.
#'
#' @return A logical vector.
#' @family variable
#' @export
is_skill_question <- function(v_names) {
  
  stringr::str_detect(string = v_names,
                      pattern = "^skill_question_\\d+_(cantonal|federal)(_proposal_\\d+)?$")
}
```

### `v_lvls`

```{r}
#' Determine variable's political level(s)
#'
#' Determines a variable's political level(s).
#' 
#' Note that the political levels are determined by simply parsing `v_name`.
#'
#' @param v_name Variable name. A character scalar.
#'
#' @return A character vector of political levels, of length 0 if no specific levels could be determined.
#' @family variable
#' @export
#'
#' @examples
#' fokus::v_lvls("skill_question_1_cantonal_proposal_1")
v_lvls <- function(v_name) {
  
  is_cantonal <- v_name %>% stringr::str_detect(pattern = "cantonal")
  is_federal <- v_name %>% stringr::str_detect(pattern = "federal")
  
  c("cantonal"[is_cantonal], "federal"[is_federal])
}
```

### Variable name shortening

#### `shorten_v_names`

**Remarks:**

-   To display a comparison between original and shortened column names and their respective lengths after applying `shorten_v_names()`, use:

    ``` r
    fa_data() %>%
      colnames() %>%
      tibble::tibble(original = .,
                     shortened = shorten_v_names(v_names = .,
                                                 max_n_char = NULL)) %>%
      dplyr::mutate(n_char_original = nchar(original),
                    n_char_shortened = nchar(shortened)) %>%
      dplyr::arrange(-n_char_shortened) %>%
      print(n = Inf)
    ```

```{r}
#' Shorten variable names to a maximum length of 32 characters
#'
#' @param v_names A character vector of variable names.
#' @param reverse Whether to apply the inversion of the shortening logic, i.e. to restore original/unshortened variable names.
#' @param max_n_char Maximum allowed number of characters. Either `NULL` to skip the check or otherwise an integer scalar in which case it is ensured that the
#'   maximum resulting variable name length doesn't exceed it. Doesn't have any influence on the applied shortening logic.
#'
#' @return A character vector of the same length as `v_names`.
#' @family variable
#' @seealso [shorten_colnames()], [restore_colnames()]
#' @export
shorten_v_names <- function(v_names,
                            reverse = FALSE,
                            max_n_char = 32L) {
  
  checkmate::assert_character(v_names,
                              any.missing = FALSE)
  checkmate::assert_flag(reverse)
  checkmate::assert_count(max_n_char)
  rules <- shortening_rules

  if (reverse) colnames(rules) %<>% .[c(2L, 1L, 3L)]
  
  rules %<>% dplyr::mutate(pattern =
                             allowed %>%
                             purrr::map_chr(function(allowed) {
                               
                               allowed %>% purrr::when(. %in% c("begin-middle", "begin-middle-end") ~ "(?<=(^|_))",
                                                       . %in% c("middle", "middle-end") ~ "(?<=_)",
                                                       . %in% c("begin", "begin-end") ~ "^",
                                                       ~ "")
                             }) %>%
                             paste0(string) %>%
                             purrr::map2_chr(.x = allowed,
                                             .f = ~ {
                                               
                                               .x %>% purrr::when(. == "begin" ~ .y,
                                                                  . %in% c("begin-middle-end", "middle-end") ~ paste0(.y, "(?=(_|$))"),
                                                                  . %in% c("begin-middle", "middle") ~ paste0(.y, "(?=_)"),
                                                                  . == "begin-end" ~ paste0(.y, "$"),
                                                                  . == "end" ~ paste0("(?<=_)", .y, "$"),
                                                                  ~ cli::cli_abort("This should not happen."))
                                             }))
  
  pattern_replacement <- rules$replacement
  names(pattern_replacement) <- rules$pattern
  
  v_names_new <- v_names %>% stringr::str_replace_all(pattern = pattern_replacement)
  
  # ensure we did our job
  if (!is.null(max_n_char) && !reverse && any(nchar(v_names_new) > max_n_char)) {
    
    # NOTE: `cli::cli_abort()` doesn't properly print the output of `pal::capture_print()` because:
    #        - it just seems to ignore the output if it includes ANSI escape sequences (this can be worked around by an additional `cli::ansi_strip()`)
    #        - it normalizes whitespace chars **incl. tabs** to a single regular whitespace, thus breaking the formatting
    rlang::abort(glue::glue("There are still variable names left of a length greater than {max_n_char} characters after applying `shorten_v_names()`. ",
                            "Affected are the following (shortened) variable names:\n\n",
                            tibble::tibble(v_name = v_names,
                                           v_name_short = v_names_new,
                                           n_char = nchar(v_names),
                                           n_char_short = nchar(v_names_new)) %>%
                              dplyr::filter(n_char_short > max_n_char) %>%
                              pal::capture_print(collapse = "\n")))
  }
  
  v_names_new
}
```

#### `shorten_colnames`

```{r}
#' Shorten column names to a maximum length of 32 characters
#'
#' This is useful for DTA export since Stata has a built-in variable name length limit of [32
#' characters](https://www.stata.com/manuals/r.pdf#rLimits) (see also
#' [here](https://www.statalist.org/forums/forum/general-stata-discussion/general/1452366-number-of-characters-in-variable-names)).
#'
#' @param x `r pkgsnip::param_label("tabular_data")`
#' @inheritParams shorten_v_names
#'
#' @return `x` with column names shortened to a maximum length of 32 characters.
#' @seealso [shorten_v_names()], [restore_colnames()]
#' @export
shorten_colnames <- function(x,
                             max_n_char = 32L) {
  
  x %>% magrittr::set_colnames(value = shorten_v_names(v_names = colnames(x),
                                                       max_n_char = max_n_char))
}
```

#### `restore_colnames`

```{r}
#' Restore original/unshortened column names
#'
#' Applies the inversion of [shorten_colnames()].
#'
#' @inheritParams shorten_colnames
#' @inheritParams shorten_v_names
#'
#' @return `x` with original/unshortened column names restored.
#' @seealso [shorten_v_names()], [shorten_colnames()]
#' @export
restore_colnames <- function(x) {
  
  x %>% magrittr::set_colnames(value = shorten_v_names(v_names = colnames(x),
                                                       reverse = TRUE))
}
```

## Miscellaneous

### `abbreviations`

```{r}
#' Abbreviations used in the **fokus** package
#'
#' Returns a [tibble][tibble::tbl_df] listing an opinionated set of abbreviations used in the \R code and documentation of the **fokus** package.
#'
#' @inheritParams pkgsnip::abbreviations
#'
#' @return `r pkgsnip::param_label("data")`
#' @export
abbreviations <- function(expand = FALSE) {
  
  pal::assert_pkg("pkgsnip")
  
  tibble::tribble(
    ~full_expressions, ~abbreviation,
    "google", "g",
    c("proceed","procedure"), "prcd",
    "procedures", "prcds",
    "questionnaire", "q",
    "questionnaires", "qx",
    "statistik aargau", "sa",
    c("supplemental", "supplementary"), "suppl"
  ) %>%
    dplyr::bind_rows(pkgsnip::abbreviations()) %>%
    dplyr::arrange(dplyr::across()) %>%
    purrr::when(expand ~ tidyr::unnest_longer(data = ., 
                                              col = full_expressions,
                                              values_to = "full_expression"), 
                ~.)
}
```

### `print_fokus_private_structure`

TODO:

-   Think about implementing a fn that returns the dir structure *as structured data*, i.e. a properly nested list of paths or the like. Then this print fn
    could be replaced by a to-text-converter of the new fn.

```{r}
#' Print expected structure of the private FOKUS directory
#'
#' Returns a textual representation of the expected structure of the private FOKUS directory, formatted as a Markdown [fenced code
#' block](https://pandoc.org/MANUAL.html#extension-fenced_code_blocks).
#'
#' @includeRmd data-raw/snippets/fokus_private_description.Rmd
#'
#' @return A character scalar.
#' @export
print_fokus_private_structure <- function() {
  cat(fokus_private_structure)
}
```

### `md_emphasize`

```{r}
#' Emphasize xth element of character vector (Markdown)
#'
#' @param x Input as a character vector.
#' @param which Indices of the elements to be emphasized.
#' @param emph Character sequence used for emphasis.
#'
#' @return A character vector of the same length as `x`.
#' @export
md_emphasize <- function(x,
                         which = TRUE,
                         emph = "**") {
  
  x[which] %<>% paste0(emph, ., emph)
  x
}
```

### `lgl_to_unicode`

```{r}
#' Convert logical vector to Unicode symbols `r unicode_checkmark` and `r unicode_crossmark`
#'
#' @param x A logical vector.
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' fokus::lgl_to_unicode(c(TRUE, TRUE, FALSE, NA))
lgl_to_unicode <- function(x) {
  
  dplyr::if_else(checkmate::assert_logical(x),
                 unicode_checkmark,
                 unicode_crossmark)
}
```

### `prettify_date`

Relevant SO question: [What is a reliable way of getting allowed locale names in
R?](https://stackoverflow.com/questions/20960821/what-is-a-reliable-way-of-getting-allowed-locale-names-in-r)

TODO: Investigate if there's a more sophisticated pkg available fulfilling this task (ideally in a system-locale-independent way).

```{r}
#' Prettify date
#'
#' Note that this might only work on (Ubuntu) Linux in the current form since locales are one bitchy hell of a PITA...
#'
#' @param date Date to be prettified. A [date][base::Date] or something coercible to.
#' @param locale Locale the date should be prettified for. Currently only `"en"`/`"en-US"` and `"de"`/`"de-CH"` are implemented.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' fokus::prettify_date(lubridate::today())
prettify_date <- function(date,
                          locale = "en-US") {
  
  withr::with_locale(new = c("LC_TIME" = purrr::when(. = locale,
                                                     . %in% c("en", "en-US") ~ "C",
                                                     . %in% c("de", "de-CH") ~ "de_CH.utf8")),
                     code =
                       locale %>%
                       purrr::when(. %in% c("en", "en-US") ~ "%B %d, %Y",
                                   . %in% c("de", "de-CH") ~ "%d. %B %Y",
                                   ~ cli::cli_abort("Specified {.arg locale} not implemented yet.")) %>%
                       format(x = lubridate::as_date(date)))
}
```

### `read_toml`

TODO: Outsource this into separate pkg *tomlr*.

```{r}
#' Read in and parse a TOML file as a strict list
#'
#' Reads in a file in [Tom's Obvious Minimal Language](https://toml.io/) format and returns its content as a (nested) [strict list][xfun::strict_list()].
#'
#' The file is parsed using [`RcppTOML::parseTOML(escape = FALSE)`][RcppTOML::parseTOML].
#'
#' @param path Path to the TOML file. A character scalar.
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @export
read_toml <- function(path) {
  
  pal::assert_pkg("RcppTOML")
  
  path %>%
    purrr::when(length(.) > 0L ~ RcppTOML::parseTOML(input = .,
                                                     escape = FALSE),
                ~ NULL) %>%
    xfun::as_strict_list()
}
```
