---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Package load/unload

```{r}
.onLoad <- function(libname, pkgname) {
  
  pkgpins::clear_cache(board = pkgpins::board(pkg = pkgname),
                       max_age = getOption(paste0(pkgname, ".global_cache_lifespan"),
                                           default = global_cache_lifespan))
}
```

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "all_of",
                                 "ends_with",
                                 "everything",
                                 "where",
                                 # other
                                 "alignment",
                                 "allowed",
                                 "block",
                                 "date_begin",
                                 "date_end",
                                 "enumerator",
                                 "enumerator_base",
                                 "Geschlecht",
                                 "has_same_length",
                                 "has_auto_fallback",
                                 "Haushaltsgr\u00f6sse Anzahl Personen Total",
                                 "Haushaltsgr\u00f6sse Anzahl Personen \u00fcber 18 Jahren",
                                 "household_size_official",
                                 "i",
                                 "ID-Nummer",
                                 "id_statistical_office",
                                 "j",
                                 "Jahrgang",
                                 "length_response_options",
                                 "length_value_labels",
                                 "length_variable_values",
                                 "lvl",
                                 "marital_status_official",
                                 "matches_length",
                                 "n_adults_in_household_official",
                                 "n_cantonal_majoritarian_elections",
                                 "n_cantonal_proportional_elections",
                                 "n_cantonal_proposals",
                                 "n_char_short",
                                 "n_federal_majoritarian_elections",
                                 "n_federal_proportional_elections",
                                 "n_federal_proposals",
                                 "n_kids_in_household_official",
                                 "name",
                                 "nr",
                                 "question",
                                 "receives_print",
                                 "response_options",
                                 "separator",
                                 "sex_official",
                                 "string",
                                 "topic",
                                 "value_labels",
                                 "variable_name",
                                 "variable_values",
                                 "who",
                                 "width",
                                 "year_of_birth_official",
                                 "Zivilstand"))

# avoid notes about "possible error"s when using non-exported rex shortcuts, cf. https://github.com/kevinushey/rex#using-rex-in-other-packages
rex::register_shortcuts(pkg_name = utils::packageName())
```

## Functions

### Basic

#### `path_private`

Assemble a FOKUS private working directory path

```{r}
path_private <- function(...) {
  
  dir_private <- getOption("fokus.path_private",
                           default = getwd())
  
  # ensure `fokus.path_private` is valid (read access plus file `data/aargau/survey_data_2018-09-23.xlsx` exists)
  is_valid_path <-
    checkmate::test_directory(dir_private, access = "r") && fs::file_exists(path = fs::path(dir_private, "data/aargau/survey_data_2018-09-23.xlsx"))
  
  if (!is_valid_path) {
    
    is_opt_set <- !is.null(getOption("fokus.path_private"))
    
    cli::cli_abort(paste0(dplyr::if_else(is_opt_set,
                                         "The option {.field fokus.path_private} is set to: {.path {dir_private}}\n\n",
                                         "The option {.field fokus.path_private} is unset, thus we fall back to: {.path {dir_private}}\n\n"),
                          "This doesn't seem to be a valid FOKUS working directory. Please correct this in order for this package to work properly."))
  }
  
  fs::path(dir_private, ...)
}
```

#### `opts`

List package-specific options

```{r}
opts <- function(pretty_colnames = FALSE) {
  
  tibble::tibble(name = "fokus.path_private",
                 description = paste0("path to the working directory (the local instance of the ",
                                      "[`fokus_private` repository](https://gitlab.com/zdaarau/private/fokus_private)); defaults to the current working ",
                                      "directory"),
                 has_auto_fallback = TRUE) |>
    tibble::add_row(name = "fokus.global_cache_lifespan",
                    description = glue::glue("default cache lifespan for all functions taking a `cache_lifespan` argument; defaults to ",
                                             global_cache_lifespan),
                    has_auto_fallback = TRUE) |>
    purrr::when(checkmate::assert_flag(pretty_colnames) ~ dplyr::rename(.data = .,
                                                                        "automatic fallback if unset" = has_auto_fallback),
                ~ .)
}
```

#### `print_opts`

Pretty-print package-specific options

```{r}
print_opts <- function() {
  
  opts(pretty_colnames = TRUE) |>
    dplyr::mutate(name = paste0("`", name, "`"),
                  dplyr::across(all_of("automatic fallback if unset"),
                                lgl_to_unicode)) |>
    pal::pipe_table()
}
```

### Raw questionnaire data

#### DESCRIPTION

Functions to access the raw questionnaire data as defined in the [TOML](https://toml.io/) files found under
[`data-raw/questionnaire`](https://gitlab.com/zdaarau/rpkgs/fokus/-/tree/master/data-raw/questionnaire/).

#### `raw_q`

```{r}
#' Raw FOKUS questionnaire data
#'
#' A structured list of the raw questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @seealso [`raw_qx_suppl`][raw_qx_suppl] [`raw_q_suppl`][raw_q_suppl] [`raw_q_suppl_lvl`][raw_q_suppl_lvl] [`raw_q_suppl_lvl_canton`][raw_q_suppl_lvl_canton] 
#'   [`raw_q_suppl_proposal`][raw_q_suppl_proposal] [`raw_q_suppl_election`][raw_q_suppl_election] [`raw_q_suppl_skill_questions`][raw_q_suppl_skill_questions]
#'   [`raw_q_suppl_skill_question`][raw_q_suppl_skill_question]
#' @keywords internal
"raw_q"
```

#### `raw_qx_suppl`

```{r}
#' Raw supplemental date-specific FOKUS questionnaire data
#'
#' A structured list of raw supplemental date-specific questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @seealso [`raw_q`][raw_q] [`raw_q_suppl`][raw_q_suppl] [`raw_q_suppl_lvl`][raw_q_suppl_lvl] [`raw_q_suppl_lvl_canton`][raw_q_suppl_lvl_canton]
#'   [`raw_q_suppl_proposal`][raw_q_suppl_proposal] [`raw_q_suppl_election`][raw_q_suppl_election] [`raw_q_suppl_skill_questions`][raw_q_suppl_skill_questions]
#'   [`raw_q_suppl_skill_question`][raw_q_suppl_skill_question]
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qx_suppl[["2018-09-23"]]$mode
"raw_qx_suppl"
```

#### `raw_q_suppl`

```{r}
#' Get raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][raw_qx_suppl] for the specified ballot date.
#'
#' @inheritParams ballot_types
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl(ballot_date = "2018-09-23") %$% mode
raw_q_suppl <- function(ballot_date = ballot_dates) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  raw_qx_suppl[[ballot_date]]
}
```

#### `raw_q_suppl_lvl`

```{r}
#' Get a political level's raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl] for the specified ballot date and political level.
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return seealso
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_lvl(ballot_date = "2018-09-23",
#'                         lvl = "cantonal") |>
#'   names()
raw_q_suppl_lvl <- function(ballot_date = ballot_dates,
                            lvl = c("cantonal", "federal")) {
  
  lvl <- rlang::arg_match(lvl)
  
  result <- raw_q_suppl(ballot_date = ballot_date) %>% purrr::pluck(lvl)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    
    cli::cli_abort("No {.val {lvl}} level present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  result
}
```

#### `raw_q_suppl_lvl_canton`

```{r}
#' Get a canton's political-level-specific raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data for the specified ballot date and political level][raw_q_suppl_lvl]
#' that applies for the specified canton only.
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_lvl_canton(ballot_date = "2018-09-23",
#'                                lvl = "cantonal",
#'                                canton = "aargau") |>
#'   names()
raw_q_suppl_lvl_canton <- function(ballot_date = ballot_dates,
                                   lvl = c("cantonal", "federal"),
                                   canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  
  result <-
    raw_q_suppl_lvl(ballot_date = ballot_date,
                    lvl = lvl) %>%
    purrr::pluck(canton)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    
    cli::cli_abort("No {.val {lvl}} supplemental {.val {ballot_date}} FOKUS questionnaire data present for canton {.val {canton}}.")
  }
  
  result
}
```

#### `raw_q_suppl_proposal`

```{r}
#' Get raw proposal supplemental questionnaire data
#'
#' Returns a structured list of a proposal's data from the [supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_proposal(ballot_date = "2018-09-23",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              proposal_nr = 1) %$%
#'   name
raw_q_suppl_proposal <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr) {
  
  lvl <- rlang::arg_match(lvl)
  checkmate::assert_count(proposal_nr,
                          positive = TRUE)
  
  proposals <-
    lvl %>%
    purrr::when(. == "federal" ~
                  raw_q_suppl_lvl(ballot_date = ballot_date,
                                  lvl = .),
                ~ raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                                         lvl = .,
                                         canton = canton)) %>%
    purrr::pluck("proposal")
  
  if (is.null(proposals)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} proposals present",
                          " for {.val {canton}}"[lvl == "cantonal"],
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  proposal <- proposals %>% purrr::pluck(as.character(proposal_nr))
  
  if (is.null(proposal)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} proposal {.val {proposal_nr}} present",
                          " for {.val {canton}}"[lvl == "cantonal"],
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  proposal
}
```

#### `raw_q_suppl_proposal_name`

```{r}
#' Get a proposal's raw name supplemental questionnaire data
#'
#' Returns a structured list of proposal name data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_proposal_name(ballot_date = "2018-11-25",
#'                                   lvl = "cantonal",
#'                                   canton = "aargau",
#'                                   proposal_nr = 2)
raw_q_suppl_proposal_name <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("name")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No names present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_arguments`

```{r}
#' Get a proposal's raw argument supplemental questionnaire data
#'
#' Returns a structured list of argument data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::proposal_main_motives(ballot_date = "2018-11-25",
#'                               lvl = "cantonal",
#'                               canton = "aargau",
#'                               proposal_nr = 2)
raw_q_suppl_arguments <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("argument")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No arguments present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_main_motives`

```{r}
#' Get a proposal's raw main motive supplemental questionnaire data
#'
#' Returns a structured list of main motive data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::proposal_main_motives(ballot_date = "2018-11-25",
#'                               lvl = "cantonal",
#'                               canton = "aargau",
#'                               proposal_nr = 2)
raw_q_suppl_main_motives <- function(ballot_date = ballot_dates,
                                     lvl = c("cantonal", "federal"),
                                     canton = cantons,
                                     proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("main_motive")
  
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No main motives present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_elections`

```{r}
#' Get raw supplemental election questionnaire data
#'
#' Returns a structured list of election data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl_canton].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_elections(ballot_date = "2019-10-20",
#'                               lvl = "cantonal",
#'                               canton = "aargau") %$%
#'   skill_questions_source
raw_q_suppl_elections <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons) {
  result <-
    raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton) %>%
    purrr::pluck("election")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_election`

NOTES:

-   Since *federal* elections in Switzerland are also organized per canton (the cantons are the electoral constituencies), the relevant data always stems from
    `raw_q_suppl_lvl_canton()` and never from `raw_q_suppl_lvl()`.

```{r}
#' Get an election's raw supplemental questionnaire data
#'
#' Returns a structured list of an election's data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl_canton].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_election(ballot_date = "2019-10-20",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              prcd = "majoritarian") %$%
#'   n_seats
raw_q_suppl_election <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 prcd = c("proportional", "majoritarian"),
                                 election_nr = 1L) {
  
  prcd <- rlang::arg_match(prcd)
  checkmate::assert_count(election_nr,
                          positive = TRUE)
  
  result <-
    raw_q_suppl_elections(ballot_date = ballot_date,
                          lvl = lvl,
                          canton = canton) %>%
    purrr::pluck(prcd)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS ",
                          "questionnaire data."))
  }
  
  result %<>% purrr::pluck(as.character(election_nr))
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} election {.val {election_nr}} for canton {.val {canton}} present in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_election_name`

```{r}
#' Get raw supplemental election name questionnaire data
#'
#' Returns a structured list of an election's name data from the [political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_election_name(ballot_date = "2019-10-20",
#'                                   lvl = "cantonal",
#'                                   canton = "aargau",
#'                                   prcd = "majoritarian")
raw_q_suppl_election_name <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      prcd = c("proportional", "majoritarian"),
                                      election_nr = 1L) {
  lvl <- rlang::arg_match(lvl)
  prcd <- rlang::arg_match(prcd)
  checkmate::assert_count(election_nr,
                          positive = TRUE)
  
  # federal proportional election names are defined once for all cantons together
  if (lvl == "federal" && prcd == "proportional") {
    
    result <-
      raw_q_suppl_lvl(ballot_date = ballot_date,
                      lvl = lvl) %>%
      purrr::chuck("election", prcd, as.character(election_nr))
    
  } else {
    
    result <- raw_q_suppl_election(ballot_date = ballot_date,
                                   lvl = lvl,
                                   canton = canton,
                                   prcd = prcd,
                                   election_nr = election_nr)
  }
  
  result %<>% purrr::pluck("name")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No names present for {.val {lvl}} {.val {prcd}} election {.val {election_nr}} in canton {.val {canton}} in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_mode`

```{r}
#' Get raw supplemental survey mode questionnaire data
#'
#' Returns a structured list of survey mode data from the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#' 
#' @inheritParams ballot_types 
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_mode(ballot_date = "2018-09-23",
#'                          canton = "aargau")
raw_q_suppl_mode <- function(ballot_date = ballot_dates,
                             canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  
  result <-
    raw_q_suppl(ballot_date = ballot_date) %>%
    purrr::pluck("mode", canton)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    
    cli::cli_abort("No survey mode data present for canton {.val {canton}} in supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  result
}
```

#### `raw_q_suppl_skill_questions`

```{r}
#' Get raw supplemental skill question questionnaire data
#'
#' Returns a structured list of skill question data from the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, non-proposal-specific skill question data is returned.
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_skill_questions(ballot_date = "2018-09-23",
#'                                     lvl = "cantonal",
#'                                     canton = "aargau",
#'                                     proposal_nr = 1) |>
#'   purrr::map_depth(1L, "de") |>
#'   purrr::flatten_chr()
raw_q_suppl_skill_questions <- function(ballot_date = ballot_dates,
                                        lvl = c("cantonal", "federal"),
                                        canton = cantons,
                                        proposal_nr = NULL) {
  lvl <- rlang::arg_match(lvl)
  
  result <-
    lvl %>%
    purrr::when(
      
      # federal non-proposal-specific skill questions (e.g. at federal elections)
      length(proposal_nr) == 0L && . == "federal" ~
        raw_q_suppl_lvl(ballot_date = ballot_date,
                        lvl = .),
      # cantonal non-proposal-specific skill questions (e.g. at cantonal elections)
      length(proposal_nr) == 0L && . == "cantonal" ~
        raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                               lvl = .,
                               canton = canton),
      # federal or cantonal proposal-specific skill questions
      ~ raw_q_suppl_proposal(ballot_date = ballot_date,
                             lvl = .,
                             canton = canton,
                             proposal_nr = proposal_nr)) %>%
    purrr::pluck("skill_question")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No skill questions present",
                          dplyr::if_else(length(proposal_nr) == 0L,
                                         paste0(" on the {.val {lvl}} level",
                                                " for {.val {canton}}"[lvl == "cantonal"]),
                                         " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}
```

#### `raw_q_suppl_skill_question`

```{r}
#' Get a single skill question's raw supplemental questionnaire data
#'
#' Returns a structured list of a single skill question's data from the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_skill_question(ballot_date = "2018-09-23",
#'                                    lvl = "cantonal",
#'                                    canton = "aargau",
#'                                    proposal_nr = 1,
#'                                    skill_question_nr = 1)
raw_q_suppl_skill_question <- function(ballot_date = ballot_dates,
                                       lvl = c("cantonal", "federal"),
                                       canton = cantons,
                                       proposal_nr = NULL,
                                       skill_question_nr) {
  
  checkmate::assert_count(skill_question_nr,
                          positive = TRUE)
  result <-
    raw_q_suppl_skill_questions(ballot_date = ballot_date,
                                lvl = lvl,
                                canton = canton,
                                proposal_nr = proposal_nr) %>%
    purrr::pluck(skill_question_nr)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No skill question {.val {skill_question_nr}} present",
                          dplyr::if_else(length(proposal_nr) == 0L,
                                         paste0(" on the {.val {lvl}} level", " for {.val {canton}}"[lvl == "cantonal"]),
                                         " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data. Only {length(skill_questions)} skill questions included."))
  }
  
  result
}
```

#### `raw_pick_right`

TODO:

-   Currently, when no matching subkey is found, `pick_right_helper()` only properly falls back to default value for key `include` (it's hardcoded). Instead, we
    should always fall back to default value (from `init_heritable_map()$KEY`)!

NOTES:

-   The recursion is performed because it's allowed to nest `.default`, `.true`, `false`, `.YYYYMMDD` etc. subkeys under ballot-type-subkeys (`.election`,
    `.referendum` etc.).

```{r}
#' Pick right raw questionnaire value
#'
#' Picks the right value of a certain raw questionnaire key based on ballot date and canton (recursively).
#'
#' @param x Questionnaire key. A list object.
#' @inheritParams ballot_types
#'
#' @return Value of `x` that corresponds to `canton` and `ballot_date`.
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
raw_pick_right <- function(x,
                           ballot_date,
                           canton) {
  
  # force evaluation of `ballot_date` and `canton` to ensure immediate error (with better msg) in case they are missing
  ballot_date
  canton
  
  if (purrr::vec_depth(x) > 1L) {
    
    x <-
      pick_right_helper(x = x,
                        ballot_date = ballot_date,
                        canton = canton) %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton)
    
  }
  
  x
}

pick_right_helper <- function(x,
                              ballot_date,
                              canton) {
  
  if (purrr::is_list(x) && (length(x) > 1L || purrr::vec_depth(x) > 1L)) {
    
    # create plain ballot date as in subkeys
    ballot_date_squeezed <- stringr::str_remove_all(string = ballot_date,
                                                    pattern = "-")
    # convert ballot date to type date
    ballot_date %<>% lubridate::as_date()
    
    # handle begin-end date subkeys
    begin_end_subkeys <-
      names(x) %>%
      stringr::str_subset(pattern = "^\\d+_\\d+$")
    
    matches_begin_end_subkeys <-
      begin_end_subkeys %>%
      purrr::map_lgl(function(x) {
        
        begin <- x %>% stringr::str_extract(pattern = "^\\d+") %>% lubridate::as_date()
        end <- x %>% stringr::str_extract(pattern = "\\d+$") %>% lubridate::as_date()
        
        begin <= ballot_date && ballot_date <= end
      })
    
    # integrity check: ensure there aren't any overlapping intervals
    if (length(which(matches_begin_end_subkeys)) > 1L) {
      
      cli::cli_abort("Illegal overlapping interval subkeys found: {.var {begin_end_subkeys[matches_begin_end_subkeys]}}\n\nPlease fix this and run again.")
    }
    
    ballot_types <- ballot_types(ballot_date = ballot_date,
                                 canton = canton)
    
    x <- names(x) %>% purrr::when(
      
      # consider overrides for binary keys
      ballot_date %in% x[["false"]] ~ FALSE,
      ballot_date %in% x[["true"]] ~ TRUE,
      
      # consider overrides for non-binary keys
      ## single date subkey
      ballot_date_squeezed %in% . ~ x[[ballot_date_squeezed]],
      ## begin-end date subkey
      length(which(matches_begin_end_subkeys)) > 0L ~ x[[begin_end_subkeys[matches_begin_end_subkeys]]],
      
      # consider overrides for ballot types (we take the first one in case of ambiguity)
      any(ballot_types %in% .) ~ x[[intersect(., ballot_types)[1L]]],
      
      # return default value if defined
      "default" %in% . ~ x[["default"]],
      
      # return TRUE in any remaining cases (implicit `include`)
      ~ TRUE
    )
  }
  
  x
}
```

### Questionnaire generation

#### `add_who_constraint`

Adds the who constraint wrapped in parentheses to the end of a string (e.g. `variable_label`).

```{r}
add_who_constraint <- function(x,
                               who) {
  if (who != "all") {
    
    result <- who %>% purrr::when(stringr::str_detect(string = x, pattern = "\\)$") ~
                                    stringr::str_replace(string = x,
                                                         pattern = "\\)$",
                                                         replacement = paste0("; only *", ., "*)")),
                                  ~ paste0(x, " (only *", ., "*)"))
  } else {
    
    result <- x
  }
  
  result
}
```

#### `assemble_q_tibble`

Traverse questionnaire recursively and assemble questionnaire block tibble.

```{r}
assemble_q_tibble <- function(ballot_date,
                              canton,
                              raw_q_branch,
                              q_lvl,
                              heritable_map,
                              verbose) {
  map <- heritable_map
  
  # only complement with non-table-array q lvls
  # (`purrr::list_modify()` leads to completely undesired results with *unnamed* lists like the `item` table arrays)
  if (rlang::is_named(raw_q_branch)) {
    map %<>%
      purrr::list_modify(!!!raw_q_branch) %>%
      pal::list_keep(keep = fokus::q_item_keys$key)
  }
  
  result <- NULL
  
  if ("variable_name" %in% names(raw_q_branch)) {
    
    if (verbose) cli::cli_progress_step(".. ITEM: {.var {map$variable_name}}")
    
    result <- assemble_q_item_tibble(ballot_date = ballot_date,
                                     canton = canton,
                                     item_map = map,
                                     verbose = verbose)
    
  } else if (purrr::vec_depth(raw_q_branch) > 2L) {
    
    if (verbose && dplyr::last(stringr::str_split(q_lvl, "\\.")[[1L]]) == "item") {
      cli::cli_progress_step("Q TABLE LVL: {.val {q_lvl}}")
    }
    
    result <- purrr::map2_dfr(.x = raw_q_branch,
                              .y = names(raw_q_branch) %||% seq_along(raw_q_branch),
                              .f = ~ assemble_q_tibble(ballot_date = ballot_date,
                                                       canton = canton,
                                                       raw_q_branch = .x,
                                                       q_lvl = paste(q_lvl, .y,
                                                                     sep = "."),
                                                       heritable_map = map,
                                                       verbose = verbose))
  }
  
  result
}
```

#### `assemble_q_item_tibble`

```{r}
assemble_q_item_tibble <- function(ballot_date,
                                   canton,
                                   item_map,
                                   verbose) {
  # iterate over `lvl`...
  resolve_q_val(x = item_map$lvl,
                ballot_date = ballot_date,
                canton = canton,
                key = "lvl",
                lvl = "",
                i = NA_integer_,
                j = NA_integer_) %>%
    purrr::map_dfr(
      .f = function(lvl) {
        # ...`i`...
        resolve_q_val(x = item_map$i,
                      ballot_date = ballot_date,
                      canton = canton,
                      key = "i",
                      lvl = lvl,
                      i = NA_integer_,
                      j = NA_integer_) %>%
          purrr::map_dfr(
            lvl = lvl,
            .f = function(i,
                          lvl) {
              # ...and `j`
              resolve_q_val(x = item_map$j,
                            ballot_date = ballot_date,
                            canton = canton,
                            key = "j",
                            lvl = lvl,
                            i = i,
                            j = NA_integer_) %>%
                purrr::map_dfr(
                  i = i,
                  lvl = lvl,
                  .f = function(j,
                                i,
                                lvl) {
                    
                    # respect keys `include` and `ballot_types`
                    is_incl <- resolve_q_val(x = item_map$include,
                                             ballot_date = ballot_date,
                                             canton = canton,
                                             key = "include",
                                             lvl = lvl,
                                             i = i,
                                             j = j)
                    has_ballot_type <-
                      resolve_q_val(x = item_map$ballot_types,
                                    ballot_date = ballot_date,
                                    canton = canton,
                                    key = "ballot_types",
                                    lvl = lvl,
                                    i = i,
                                    j = j) %>%
                      intersect(ballot_types(ballot_date = ballot_date,
                                             canton = canton)) %>%
                      rlang::is_empty() %>%
                      magrittr::not()
                    
                    result <- NULL
                    
                    if (is_incl && has_ballot_type) {
                      
                      # resolve all keys in item map
                      result <-
                        names(item_map) %>%
                        setdiff(c("lvl",
                                  "i",
                                  "j",
                                  "ballot_types",
                                  "include")) %>%
                        magrittr::set_names(x = .,
                                            value = .) %>%
                        purrr::map(~ {
                          
                          if (verbose) cli::cli_progress_step(".. .. KEY: {.field {.x}}")
                          
                          # pre-resolve `question` for dependent `question_full` resolution
                          if (.x == "question_full") {
                            question <- resolve_q_val(x = item_map[["question"]],
                                                      ballot_date = ballot_date,
                                                      canton = canton,
                                                      key = "question",
                                                      lvl = lvl,
                                                      i = i,
                                                      j = j)
                          } else {
                            question <- NA_character_
                          }
                          
                          resolve_q_val(x = item_map[[.x]],
                                        ballot_date = ballot_date,
                                        canton = canton,
                                        key = .x,
                                        lvl = lvl,
                                        i = i,
                                        j = j,
                                        question = question) %>%
                            purrr::when(
                              # replace empty scalars with NA
                              length(.) == 0L && .x %in% q_item_keys$key[q_item_keys$is_scalar] ~
                                .[NA],
                              # wrap vectors in list
                              .x %in% q_item_keys$key[!q_item_keys$is_scalar] ~
                                list(.),
                              ~ .
                            )
                        }) %>%
                        # add iterators
                        c(lvl = lvl,
                          i = i,
                          j = j)
                      
                      # handle special cases
                      ## 1: fill empty non-iterator multi-value keys with NA(s) if all other non-empty multi-value keys have the same length
                      lengths_multi_val_keys <-
                        q_item_keys_multival %>%
                        magrittr::set_names(., .) %>%
                        purrr::map_int(~ length(result[[.x]][[1L]]))
                      
                      positive_lengths_multi_val_keys <-
                        lengths_multi_val_keys %>%
                        magrittr::extract(. > 0L)
                      
                      if (any(lengths_multi_val_keys == 0L) && length(unique(positive_lengths_multi_val_keys)) == 1L) {
                        
                        for (k in (lengths_multi_val_keys %>%
                                   magrittr::extract(. == 0L) %>%
                                   names())) {
                          
                          result[[k]] <- list(rep(result[[k]][[1L]][NA],
                                                  times = length(result[[names(positive_lengths_multi_val_keys)[1L]]][[1L]])))
                        }
                      }
                      
                      ## 2: if no `question_common` is defined, fall back on
                      ##    a) `question_full.default`
                      ##    b) `question.default`
                      ##    c) `question_full`
                      ##    if either exists and actually differs from `question`
                      if (is.null(result$question_common)) {
                        
                        question_common_fallback <-
                          item_map %>%
                          purrr::when("default" %in% names(.$question_full) ~
                                        resolve_q_val(x = item_map$question_full$default,
                                                      ballot_date = ballot_date,
                                                      canton = canton,
                                                      key = "question_full",
                                                      lvl = lvl,
                                                      i = i,
                                                      j = j),
                                      "default" %in% names(.$question) ~
                                        resolve_q_val(x = item_map$question$default,
                                                      ballot_date = ballot_date,
                                                      canton = canton,
                                                      key = "question",
                                                      lvl = lvl,
                                                      i = i,
                                                      j = j),
                                      ~ result$question_full)
                        
                        if (isTRUE(question_common_fallback != result$question)) {
                          result$question_common <- question_common_fallback
                        }
                      }
                      
                      ## 3: if no `variable_label_common` is defined, fall back on `variable_label.default` if it exists and actually differs from
                      ##    variable_label`
                      if (is.null(result$variable_label_common) && "default" %in% names(item_map$variable_label)) {
                        
                        default_variable_label <- resolve_q_val(x = item_map$variable_label$default,
                                                                ballot_date = ballot_date,
                                                                canton = canton,
                                                                key = "variable_label",
                                                                lvl = lvl,
                                                                i = i,
                                                                j = j)
                        
                        if (isTRUE(default_variable_label != result$variable_label)) {
                          result$variable_label_common <- default_variable_label
                        }
                      }
                      
                      ## 4: add `who`-constraint to `variable_label` and `variable_label_common`
                      ### get English `who` value
                      who_en <-
                        raw_q$who %>%
                        purrr::detect(~ .x$value$de == stringr::str_replace(string = result$who,
                                                                            pattern = "\\d+",
                                                                            replacement = "{i}")) %>%
                        purrr::chuck("value", "en") %>%
                        cli::pluralize(.null = NA_character_,
                                       .trim = FALSE)
                      
                      ### add who-constraints
                      if (!is.null(result$variable_label_common) && !has_who_constraint(result$variable_label_common)) {
                        
                        # ensure `who` doesn't vary over time
                        if (length(item_map$who) > 1L) {
                          cli::cli_abort(paste0("{.field who} of variable {.var {result$variable_name}} has changed over time. Thus an explicit {.field who}-",
                                                "constraint has to be specified at the end of {.field variable_label_common} in the raw ",
                                                "{.file questionnaire.toml}."))
                        }
                        result$variable_label_common %<>% add_who_constraint(who = who_en)
                      }
                      result$variable_label %<>% add_who_constraint(who = who_en)
                    }
                    
                    # convert result to tibble
                    tibble::as_tibble(result)
                  })
            })
      })
}
```

#### `complement_heritable_map`

Complement `map` with key-values from top level of list

```{r}
complement_heritable_map <- function(x,
                                     from) {
  names <- names(x)
  
  x %>%
    purrr::map2(.x = names,
                .y = .,
                .f = function(k, v) purrr::pluck(.x = from,
                                                 k,
                                                 .default = v)) %>%
    magrittr::set_names(names)
}
```

#### `expand_q_tibble`

```{r}
#' Expand questionnaire tibble to long format
#'
#' Expands a [questionnaire tibble][gen_q_tibble] to [long format](https://en.wikipedia.org/wiki/Wide_and_narrow_data).
#'
#' @param q_tibble Questionnaire tibble as returned by [gen_q_tibble()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family q_gen
#' @keywords internal
expand_q_tibble <- function(q_tibble) {
  
  # run integrity checks...
  validate_q_tibble(q_tibble) %>%
    # ...expand questionnaire data to long format...
    tidyr::unnest(cols = any_of(q_item_keys_multival))
}
```

#### `export_q_all`

```{r}
#' Export all questionnaires
#'
#' Exports *all* questionnaires, *softly* by default (i.e. without an XLSX version and deploying/uploading).
#'
#' Useful to efficiently test and inspect latest changes in generated questionnaire files.
#'
#' @inheritParams export_q
#'
#' @keywords internal
export_q_all <- function(verbose = FALSE,
                         incl_csv = TRUE,
                         incl_html = TRUE,
                         incl_xlsx = FALSE,
                         deploy = FALSE,
                         local_deploy_path = getOption("fokus.q.local_deploy_path"),
                         upload_to_g_drive = FALSE,
                         g_drive_folder = "fokus_aargau/Umfragen/Dateien f\u00fcr publitest/Fragebogen/") {
  ballot_dates %>%
    purrr::walk(export_q,
                canton = "aargau",
                incl_csv = incl_csv,
                incl_html = incl_html,
                incl_xlsx = incl_xlsx,
                deploy = deploy,
                local_deploy_path = local_deploy_path,
                upload_to_g_drive = upload_to_g_drive,
                g_drive_folder = g_drive_folder)
}
```

#### `gen_q_tibble`

```{r}
#' Generate questionnaire tibble
#'
#' @inheritParams ballot_types
#' @param verbose Whether or not to print progress information during questionnaire generation.
#'
#' @return `r pkgsnip::return_label("data")`
#' @family q_gen
#' @keywords internal
gen_q_tibble <- function(ballot_date = ballot_dates,
                         canton = cantons,
                         verbose = FALSE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  checkmate::assert_flag(verbose)
  
  status_msg <- "Generating questionnaire tibble for canton {.val {canton}} @ {.val {ballot_date}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  purrr::map2_dfr(.x = raw_q,
                  .y = names(raw_q),
                  .f = ~ {
                    
                    if (verbose && !(.y %in% q_non_item_lvls)) cli::cli_h1("BLOCK: {.val {.y}}")
                    
                    assemble_q_tibble(ballot_date = ballot_date,
                                      canton = canton,
                                      raw_q_branch = .x,
                                      q_lvl = .y,
                                      heritable_map = init_heritable_map(block = .y),
                                      verbose = verbose)
                  }) %>%
    # add ballot date and canton
    dplyr::mutate(ballot_date = !!ballot_date,
                  canton = !!canton,
                  .before = 1L)
}
```

#### `has_who_constraint`

Determines whether or not a `variable_label`/`variable_label_common` already has a who-constraint at its end.

```{r}
has_who_constraint <- function(x) {
  
  isTRUE(stringr::str_detect(string = x,
                             pattern = "(\\(|; )(\\d{4}-\\d{2}-\\d{2} )?only [^\\)]+\\)$"))
}
```

#### `init_heritable_map`

Initialize heritable map of key-value pairs that can be valid for multiple questions (set hierarchically)

```{r}
init_heritable_map <- function(block) {
  
  xfun::strict_list(lvl = "?",
                    i = NA_integer_,
                    j = NA_integer_,
                    block = block,
                    variable_name = "???",
                    topic = NULL,
                    who = "alle",
                    question_intro_i = NULL,
                    question_intro_j = NULL,
                    question = NULL,
                    question_full = NULL,
                    question_common = NULL,
                    multiple_answers_allowed = FALSE,
                    variable_label = "???",
                    variable_label_common = NULL,
                    response_options = NULL,
                    variable_values = NULL,
                    value_labels = NULL,
                    value_scale = "nominal",
                    randomize_response_options = FALSE,
                    is_mandatory = FALSE,
                    ballot_types = c("referendum", "election"),
                    include = TRUE)
}
```

#### `interpolate_q_val`

NOTES:

-   `cli::pluralize()` collapses substituted vectors into a comma separated string, so we have to fall back to `glue::glue()` for arrays.

```{r}
interpolate_q_val <- function(x,
                              ballot_date,
                              canton,
                              key,
                              lvl,
                              i,
                              j,
                              ...) {
  
  # assign objects in dots to current env ensuring glue/cli fns respect them
  rlang::env_bind(.env = rlang::current_env(),
                  ...)
  
  if (key %in% q_item_keys$key[q_item_keys$is_scalar]) {
    
    result <- cli::pluralize(x,
                             .null = NA_character_,
                             .trim = FALSE)
  } else {
    
    result <-
      x %>%
      purrr::map(.f = glue::glue,
                 .envir = rlang::current_env(),
                 .null = NA_character_,
                 .trim = FALSE) %>%
      unlist()
  }
  
  result
}
```

#### `resolve_q_val`

```{r}
resolve_q_val <- function(x,
                          ballot_date,
                          canton,
                          key,
                          lvl,
                          i,
                          j,
                          ...) {
  
  checkmate::assert_scalar(lvl, null.ok = TRUE)
  checkmate::assert_scalar(i, na.ok = TRUE, null.ok = TRUE)
  checkmate::assert_scalar(j, na.ok = TRUE, null.ok = TRUE)
  
  x %>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    purrr::when(is.character(.) ~ interpolate_q_val(.,
                                                    ballot_date = ballot_date,
                                                    canton = canton,
                                                    key = key,
                                                    lvl = lvl,
                                                    i = i,
                                                    j = j,
                                                    ... = ...),
                ~ .) %>%
    # convert to proper type
    purrr::when(
      key %in% q_item_keys$key[q_item_keys$type == "character"] ~
        as.character(.),
      key %in% q_item_keys$key[q_item_keys$type == "logical"] ~
        as.logical(.),
      key %in% q_item_keys$key[q_item_keys$type == "integer"] ~
        as.integer(.),
      key %in% q_item_keys$key[q_item_keys$type == "double"] ~
        as.double(.),
      # undefined behaviour
      ~ cli::cli_abort("Undefined behaviour in {.fun resolve_q_val}. Please debug.")
    )
}
```

#### `clean_q_tibble`

-   Replaces placeholder values in multi-value columns with an empty vector.
-   Removes all Markdown formatting from character columns.

NOTES:

-   We assume each list column contains only a single type (e.g. character), so we only have to check the first value to determine the columns "subtype".

```{r}
clean_q_tibble <- function(q_tibble) {
  
  q_tibble %>%
    # remove (single) placeholders
    dplyr::mutate(dplyr::across(any_of(q_item_keys_multival) & where(~ is.character(.x[[1L]])),
                                ~ .x %>% purrr::map(~ { if (length(.x) == 1L && isTRUE(stringr::str_detect(.x, "^_.+_$"))) character() else .x }))) %>%
    # strip MD
    dplyr::mutate(dplyr::across(where(is.character),
                                pal::strip_md),
                  dplyr::across(where(is.list) & where(~ is.character(.x[[1L]])),
                                ~ .x %>% purrr::map(pal::strip_md)))
}
```

#### `validate_q_tibble`

NOTES:

-   Technically, `tidyr::unnest()` used in `expand_q_tibble()` also implicitly performs integrity check 2: it ensures that all of the simultaneously expanded
    variables are of the same length (or otherwise throws an error); obviously, this isn't as useful since it doesn't tell which `variable_name`s are affected.

```{r}
validate_q_tibble <- function(q_tibble) {
  
  # integrity check 1: ensure there are no duplicated topics, variable names and variable labels
  c("topic",
    "variable_name",
    "variable_label") %>%
    purrr::walk(.f = function(v) {
      
      is_dup <- duplicated(q_tibble[[v]])
      
      if (any(is_dup)) {
        
        dup_indices <- which(is_dup)
        
        for (i in dup_indices) {
          
          dup_v <- q_tibble[[v]][i]
          
          cli::cli_alert_danger(paste0("{.var {v}} {.val {dup_v}} is included more than once in the questionnaire."))
        }
      }
    })
  
  # integrity check 2: ensure all multi-value columns have the same length or alternatively are empty, and if not, tell which ones don't
  multi_val_v_lengths <-
    q_tibble %>%
    dplyr::transmute(dplyr::across(where(is.list),
                                   purrr::map_int,
                                   length)) %>%
    dplyr::rename_with(~ paste0("length_", .x)) %>%
    dplyr::mutate(matches_length = length_variable_values == 0L | length_value_labels == 0L | length_variable_values == length_value_labels) %>%
    dplyr::mutate(matches_length =
                    matches_length & (length_response_options == 0L | length_value_labels == 0L | length_response_options == length_value_labels),
                  matches_length =
                    matches_length & (length_response_options == 0L | length_variable_values == 0L | length_response_options == length_variable_values))
  
  i_violated <- which(!multi_val_v_lengths$matches_length)
  
  if (length(i_violated)) {
    
    multi_val_v_names <-
      q_tibble %>%
      dplyr::select(where(is.list)) %>%
      colnames()
    
    # print affected variable names first since long error msg gets truncated
    cli::cli({
      cli::cli_alert_danger("Affected variable names:")
      cli::cli_ul(items = q_tibble$variable_name[i_violated])
    })
    
    cli::cli_abort(paste0("The number of {.var {multi_val_v_names}} differs for the variable names listed above."))
  }
  
  invisible(q_tibble)
}
```

#### Markdown questionnaire

##### `gen_q_md`

```{r}
#' Generate Markdown questionnaire
#'
#' @inheritParams ballot_types
#' @param incl_title Whether or not to generate an `<h1>` questionnaire title at the beginning of the document. If the result is intended to be fed to Pandoc,
#'   it's recommended to set this to `FALSE` and provide the title via [Pandoc's `--metadata` option](https://pandoc.org/MANUAL.html#option--metadata) instead.
#'
#' @return A character vector.
#' @family q_gen
#' @keywords internal
gen_q_md <- function(q_tibble,
                     incl_title = FALSE) {
  
  # ensure we have a single ballot date and canton
  ballot_date <-
    q_tibble %$%
    ballot_date %>%
    unique() %>%
    checkmate::assert_string(.var.name = "ballot_date")
  canton <-
    q_tibble %$%
    canton %>%
    unique() %>%
    checkmate::assert_string(.var.name = "canton")
  
  status_msg <- "Generating Markdown questionnaire for canton {.val {canton}} @ {.val {ballot_date}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  block_lines <-
    q_tibble %>%
    # add block title and across-block item enumerator base/group
    dplyr::mutate(enumerator_base =
                    block %>%
                    purrr::map_int(~ raw_q %>% purrr::pluck(.x, "prefix",
                                                            .default = 0L))) %>%
    # add across-block item enumerator
    dplyr::group_by(enumerator_base) %>%
    dplyr::group_modify(~ tibble::rowid_to_column(.x,
                                                  var = "enumerator")) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(enumerator = enumerator_base + enumerator) %>%
    dplyr::arrange(block, enumerator) %>%
    # iterate over every block and generate block header plus table
    dplyr::group_by(block) %>%
    dplyr::group_map(~ {
      
      block <- .y$block
      block_nr <- block_name_to_nr(block)
      block_title <- raw_q %>% purrr::chuck(block, "title")
      block_intro <-
        raw_q %>%
        purrr::pluck(block, "intro") %>%
        raw_pick_right(ballot_date = ballot_date,
                       canton = canton) %>%
        cli::pluralize(.trim = FALSE)
      
      c(glue::glue("## Block {block_nr}: {block_title}",
                   .null = NA_character_),
        "",
        block_intro,
        ""[length(block_intro)],
        q_md_table_header(),
        q_md_table_body(q_tibble_block = .x,
                        block = block),
        "",
        "")
    }) %>%
    purrr::flatten_chr()
  
  # add title, technical notes, introduction, footnotes and link references
  title <- paste0("# FOKUS-Aargau-Fragebogen f\u00fcr den ",
                  ballot_title(ballot_date = ballot_date,
                               canton = canton),
                  "\n")
  
  technical_notes <-
    raw_q %$%
    who %>%
    # reduce to who's that actually occur in data
    purrr::keep(~ .x %>%
                  purrr::chuck("value", "de") %>%
                  glue::glue(i = glue::glue(.x$i),
                             j = glue::glue(.x$j)) %>%
                  magrittr::extract(.x %>%
                                      purrr::pluck("ballot_types",
                                                   .default = c("referendum", "election")) %>%
                                      intersect(ballot_types(ballot_date = ballot_date,
                                                             canton = canton)) %>%
                                      length() %>%
                                      magrittr::is_greater_than(0L)) %>%
                  purrr::when(length(.) == 0L ~ FALSE,
                              ~ stringr::str_detect(string = q_tibble$who,
                                                    pattern = pal::fuse_regex(paste0("\\Q", ., "\\E")))) %>%
                  any()) %>%
    # assemble who lines
    purrr::map_depth(.depth = 1L,
                     .f = function(who_map) {
                       
                       i <- resolve_q_val(x = who_map$i %||% 1L,
                                          ballot_date = ballot_date,
                                          canton = canton,
                                          key = "i",
                                          lvl = "",
                                          i = NA_character_,
                                          j = NA_character_)
                       
                       j <- resolve_q_val(x = who_map$j %||% 1L,
                                          ballot_date = ballot_date,
                                          canton = canton,
                                          key = "j",
                                          lvl = "",
                                          i = NA_character_,
                                          j = NA_character_)
                       value <-
                         i %>%
                         purrr::map(function(i) {
                           j %>%
                             purrr::map_chr(i = i,
                                            .f = function(i, j) {
                                              
                                              who_map$value$de %>%
                                                glue::glue(.null = NA_character_,
                                                           .trim = FALSE) %>%
                                                md_emphasize()
                                            })
                         }) %>%
                         purrr::flatten_chr()
                       
                       description <-
                         i %>%
                         purrr::map(function(i) {
                           j %>%
                             purrr::map_chr(i = i,
                                            .f = function(i, j) {
                                              
                                              who_map$description$de %>%
                                                glue::glue(.null = NA_character_,
                                                           .trim = FALSE)
                                            })
                         }) %>%
                         purrr::flatten_chr()
                       
                       glue::glue("- {value}: {description}")
                     }) %>%
    purrr::flatten_chr() %>%
    c("## Technische Vorbemerkungen",
      "",
      "### `Wer`",
      "",
      "Die Spalte `Wer` dient dem Fragebogen-Routing. Sie kennt folgende Werte:",
      "",
      .,
      "",
      md_snippets$q_technical_notes_multiple_responses,
      md_snippets$q_technical_notes_free_text_fields)
  
  footnotes <-
    raw_q$footnote %>%
    # reduce to footnotes that actually occur in table body
    purrr::keep(~ any(stringr::str_detect(block_lines, glue::glue("\\[\\^{.x$id}\\]",
                                                                  .null = NA_character_)))) %>%
    purrr::map(~ c(glue::glue("[^{.x$id}]: ", glue::glue(.x$text,
                                                         .null = NA_character_,
                                                         .trim = FALSE),
                              .null = NA_character_,
                              .trim = FALSE),
                   "")) %>%
    purrr::flatten_chr()
  
  link_refs <-
    raw_q$link %>%
    # reduce to link references that actually occur in table body
    purrr::keep(~ any(stringr::str_detect(block_lines, glue::glue("\\[[^]]+\\]\\[{.x$id}\\]",
                                                                  .null = NA_character_)))) %>%
    purrr::map(~ c(glue::glue("[{.x$id}]: {.x$url}",
                              .null = NA_character_),
                   "")) %>%
    purrr::flatten_chr()
  
  c(title[incl_title],
    technical_notes,
    md_snippets$q_introduction,
    block_lines,
    footnotes,
    link_refs)
}
```

##### `q_md_table_header`

Generate table header for Markdown questionnaire. The tribble below allows easy tweaking of the column widths and alignment.

```{r}
q_md_table_header <- function() {
  
  tibble::tribble(
    ~name,                                         ~width, ~alignment,
    "\\#",                                         2L,     "left",
    "Thema",                                       5L,     "left",
    "Wer",                                         3L,     "left",
    "Frage",                                       15L,    "left",
    "Mehrfachnennungen",                           3L,     "left",
    "Variablenname",                               5L,     "left",
    "Variablenname (gek\u00fcrzt auf 32 Zeichen)", 5L,     "left",
    "Variablenlabel",                              15L,    "left",
    "Antwortoptionen",                             5L,     "left",
    "Variablenauspr\u00e4gungen",                  5L,     "left",
    "Auspr\u00e4gungslabels",                      5L,     "left",
    "Antwortoptionen in Zufallsreihenfolge",       3L,     "left",
    "Antwort obligatorisch",                       3L,     "left"
  ) %>%
    dplyr::mutate(separator =
                    purrr::map2_chr(.x = width,
                                    .y = alignment,
                                    .f = ~
                                      rep(x = "-",
                                          times = .x) %>%
                                      paste0(collapse = "") %>%
                                      purrr::when(.y == "left" ~ stringr::str_replace(string = .,
                                                                                      pattern = "^.",
                                                                                      replacement = ":"),
                                                  .y == "right" ~ stringr::str_replace(string = .,
                                                                                       pattern = ".$",
                                                                                       replacement = ":"),
                                                  .y == "center" ~ stringr::str_replace_all(string = .,
                                                                                            pattern = "(^.|.$)",
                                                                                            replacement = ":"),
                                                  ~ .))) %$%
    c(paste0(name, collapse = " | "),
      paste0(separator, collapse = " | "))
}
```

##### `q_md_table_body`

Generate table body for Markdown questionnaire

NOTES:

-   we set `shorten_v_names(max_n_char = 30L)` to account for additional `time_*` variables which will be shortened to `t_*`, i.e. add 2 additional chars to the
    original variable name (except the special-block variables which won't have `time_*` siblings and certain exceptions which will share a common `time_*`
    variable).

```{r}
q_md_table_body <- function(q_tibble_block,
                            block) {
  
  q_tibble_block %>%
    # replace logicals by German ja/nein
    dplyr::mutate(dplyr::across(where(is.logical),
                                ifelse,
                                "ja",
                                "nein")) %>%
    purrr::pmap_chr(function(ballot_date,
                             canton,
                             enumerator,
                             topic,
                             who,
                             question_intro_i,
                             question_intro_j,
                             question,
                             multiple_answers_allowed,
                             variable_name,
                             variable_label,
                             response_options,
                             variable_values,
                             value_labels,
                             randomize_response_options,
                             is_mandatory,
                             i,
                             j,
                             ...) {
      paste(enumerator,
            tidyr::replace_na(topic,
                              "-"),
            who,
            question %>% purrr::when(is.na(.) ~ "-",
                                     ~ c(c(question_intro_i[isTRUE(i == 1L && j %in% c(1L, NA_integer_))],
                                           question_intro_j[isTRUE(j == 1L)]) %>%
                                           magrittr::extract(!is.na(.)) %>%
                                           pal::as_string(),
                                         .) %>%
                                       magrittr::extract(!is.na(.)) %>%
                                       pal::as_string(sep = " <br><br>")),
            multiple_answers_allowed,
            pal::wrap_chr(variable_name,
                          wrap = "`"),
            shorten_v_names(v_names = variable_name,
                            max_n_char = dplyr::if_else(block %in% c("x_publitest", "y_generated", "z_generated")
                                                        || stringr::str_detect(string = variable_name,
                                                                               pattern = paste0("^", pal::fuse_regex(c("agreement_contra_argument_",
                                                                                                                       "information_source_",
                                                                                                                       "reason_non_participation_",
                                                                                                                       "political_occasions_")))),
                                                        32L,
                                                        30L)) %>%
              pal::wrap_chr("`"),
            variable_label,
            response_options %>%
              purrr::when(is_skill_question_v(variable_name) ~
                            format_md_multival_col(x = .,
                                                   collapse_break = FALSE) %>%
                            md_emphasize(which = skill_question_answer_nr(ballot_date = ballot_date,
                                                                          lvl = v_lvls(v_name = variable_name),
                                                                          canton = canton,
                                                                          proposal_nr =
                                                                            v_proposal_nr(variable_name) %>%
                                                                            purrr::when(is.na(.) ~ NULL,
                                                                                        ~ .),
                                                                          skill_question_nr = v_skill_question_nr(variable_name))) %>%
                            collapse_break(),
                          ~ format_md_multival_col(.)),
            format_md_multival_col(variable_values),
            format_md_multival_col(value_labels),
            randomize_response_options,
            is_mandatory,
            sep = " | ")
    })
}
```

##### `format_md_multival_col`

```{r}
format_md_multival_col <- function(x,
                                   collapse_break = TRUE) {
  
  result <- x
  
  if (all(is.na(x))) {
    
    result <- "-"
    
  } else if (length(x) > 1L
             && all(stringr::str_detect(string = x,
                                        pattern = "^_.+_$",
                                        negate = TRUE),
                    na.rm = TRUE)) {
    
    result <-
      x %>%
      pal::wrap_chr(wrap = "`") %>%
      purrr::when(collapse_break ~ collapse_break(.),
                  ~ .)
  }
  
  result
}
```

##### `block_name_to_nr`

```{r}
block_name_to_nr <- function(x) {
  
  x %>%
    stringr::str_extract("^.[^_]?(_\\d)?") %>%
    stringr::str_replace("_(\\d)", "-\\1") %>%
    stringr::str_remove("^0") %>%
    stringr::str_to_upper()
}
```

#### Questionnaire-internal

##### `q_item_val`

```{r}
#' Extract questionnaire item field value
#'
#' Extracts a single questionnaire item field value for every first- for every second-level iterator from the [raw FOKUS questionnaire data][raw_q] based on the
#' specified variable name and branch path.
#' 
#' When used in questionnaire item field values via [string interpolation][glue::glue], be careful to not create infinite loops via circular references.
#'
#' @inheritParams ballot_types
#' @param v_name Variable name, without resolved string interpolation, i.e. 1:1 as stated in the raw FOKUS questionnaire data. A character scalar.
#' @param branch_path Sequence of questionnaire table levels that lead to the `item` leaf node where `v_name` is defined. A character vector.
#' @param key Questionnaire item key. One of
#' `r pal::as_md_list(paste0('"', q_item_keys$key, '"'), wrap = '``')`
#' @param lvl Political-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. A character vector.
#' @param i Second-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. An integer vector.
#' @param j Third-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. An integer vector.
#'
#' @return A vector of the resolved item field values. Type and length of resolved values depend on `key`.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_item_val(ballot_date = "2018-09-23",
#'                    canton = "aargau",
#'                    branch_path = c("03_proposal_specific", "004_participants"),
#'                    v_name = "appeal_federal_proposals",
#'                    key = "include")
#'
#' fokus:::q_item_val(
#'   ballot_date = "2019-10-20",
#'   canton = "aargau",
#'   branch_path = c("02_political_start", "002_non_participation",
#'                   "003_election", "z01_hypothetical"),
#'   v_name = "hypothetical_voting_decision_federal_majoritarian_election_{i}_seat_{j}",
#'   key = "topic",
#'   i = 1:2,
#'   j = 1:3
#' )
q_item_val <- function(ballot_date = ballot_dates,
                       canton = cantons,
                       branch_path,
                       v_name,
                       key = q_item_keys$key,
                       lvl = "?",
                       i = NA_integer_,
                       j = NA_integer_) {
  
  checkmate::assert_character(branch_path,
                              any.missing = FALSE,
                              min.len = 1L)
  if ("item" %in% branch_path) {
    cli::cli_abort("{.arg branch_path} must be specified {.emph without} the {.val item} leaf node.")
  }
  checkmate::assert_string(v_name)
  key <- rlang::arg_match(key)
  
  item_map <-
    raw_q %>%
    purrr::chuck(!!!branch_path, "item") %>%
    purrr::keep(.p = ~ isTRUE(.x$variable_name == v_name)) %>%
    purrr::flatten()
  
  if (!rlang::has_name(x = item_map, name = "variable_name")) {
    cli::cli_abort(paste0("There is no item with {.arg variable_name} {.val {v_name}} defined under the questionnaire branch path {.field ",
                          pal::prose_ls(x = branch_path,
                                        separator = " -> ",
                                        last_separator = " -> "),
                          "}."))
  }
  
  # traverse questionnaire branch path and complement heritable map
  parent_map <- init_heritable_map(block = branch_path[1L])
  
  for (branch_depth in purrr::accumulate(branch_path, c)) {
    
    parent_map <-
      raw_q %>%
      purrr::chuck(!!!branch_depth) %>%
      purrr::list_modify(.x = parent_map,
                         !!!.) %>%
      pal::list_keep(keep = fokus::q_item_keys$key)
  }
  
  # evaluate requested item value
  raw_val <-
    parent_map %>%
    purrr::list_modify(!!!item_map) %>%
    purrr::chuck(key)
  
  lvl %>%
    purrr::map(function(lvl) {
      i %>%
        purrr::map(lvl = lvl,
                   .f = function(i,
                                 lvl) {
                     j %>%
                       purrr::map(i = i,
                                  lvl = lvl,
                                  .f = function(j,
                                                i,
                                                lvl) {
                                    
                                    resolve_q_val(x = raw_val,
                                                  ballot_date = ballot_date,
                                                  canton = canton,
                                                  key = key,
                                                  lvl = lvl,
                                                  i = i,
                                                  j = j)
                                  })
                   })
    }) %>%
    unlist()
}
```

##### `q_parties`

This fn is used inside the TOML questionnaire only.

```{r}
#' Political parties
#'
#' A tibble of ballot-date-specific political party metadata defined in the [raw FOKUS questionnaire data][raw_q].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family q_internal
#' @keywords internal
q_parties <- function(ballot_date = ballot_dates) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  ballot_date %<>% lubridate::as_date()
  
  raw_q %>%
    purrr::chuck("party") %>%
    purrr::map_dfr(~ {
      tibble::tibble_row(code = .x$code,
                         de.long = .x$de$long,
                         de.short = .x$de$short,
                         en.short = .x$en$short %||% .x$de$short,
                         date_begin = .x$date_begin %||% lubridate::as_date("1970-01-01"),
                         date_end = .x$date_end %||% lubridate::as_date("2099-12-31"))
    }) %>%
    dplyr::filter(date_begin <= ballot_date & date_end >= ballot_date)
}
```

##### `q_response_options`

```{r}
#' Extract response options
#'
#' Extracts response options of the specified type and optionally subtype(s) from the [raw FOKUS questionnaire data][raw_q].
#'
#' Note that only recurring response options are returned which are defined under the `response_options` top-level key in the file
#' `data-raw/questionnaire/questionnaire.toml`.
#'
#' @inheritParams election_name
#' @param type Response option type. One of
#' `r pal::as_md_list(paste0('"', response_option_types, '"'), wrap = '``')`
#' @param subtypes Hierarchical response option subtypes as a character vector, or `NULL`. If `NULL`, all subtypes are returned.
#'
#' @return A character vector.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de")
#'
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de",
#'                            subtypes = "election")
#'
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de",
#'                            subtypes = c("election", "proportional"))
q_response_options <- function(type = response_option_types,
                               lang = c("de", "en"),
                               subtypes = NULL) {
  
  type <- rlang::arg_match(type)
  lang <- rlang::arg_match(lang)
  checkmate::assert_character(subtypes,
                              any.missing = FALSE,
                              min.len = 1L,
                              null.ok = TRUE)
  raw_q %>%
    purrr::chuck("response_options", type, lang, !!!subtypes) %>%
    pal::as_chr()
}
```

##### `q_response_option_codes`

```{r}
#' Extract response option codes
#'
#' Extracts response option codes of the specified type(s) from the [raw FOKUS questionnaire data][raw_q].
#'
#' Note that only codes of recurring response options are returned which are defined under the `response_options` top-level key in the file
#' `data-raw/questionnaire/questionnaire.toml`.
#'
#' @param types Response option types. One or more of
#' `r pal::as_md_list(paste0('"', response_option_types, '"'), wrap = '``')`
#'
#' @return An integer vector.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_response_option_codes(types = "abstain")
#'
#' fokus:::q_response_option_codes(types = c("dunno",
#'                                           "custom",
#'                                           "abstain"))
q_response_option_codes <- function(types = response_option_types) {
  
  types <- unique(checkmate::assert_subset(types,
                                           choices = response_option_types,
                                           empty.ok = FALSE))
  
  types %>% purrr::map_int(~ raw_q %>% purrr::chuck("response_options", .x, "code"))
}
```

### Data import

#### `read_online_participation_codes`

```{r}
read_online_participation_codes <- function(ballot_date = ballot_dates,
                                            canton = cantons) {
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  path_input <- path_private(glue::glue("data/{canton}/online_participation_codes_{ballot_date}.txt"))
  
  if (!fs::file_exists(path_input)) {
    cli::cli_abort("No online participation codes present for canton {.val {canton}} @ {.val {ballot_date}}.")
  }
  
  readr::read_lines(file = path_input,
                    skip_empty_rows = TRUE)
}
```

#### `read_voting_register_data_extra`

```{r}
read_voting_register_data_extra <- function(ballot_date = ballot_dates,
                                            canton = cantons) {
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  pal::assert_pkg("readxl")
  
  # get date of latest dataset delivered *before* ballot date
  date_data <-
    path_private("data", canton) %>%
    fs::dir_ls(type = "file",
               regexp = "voting_register_data_extra_\\d{4}-\\d{2}-\\d{2}\\.xlsx$") %>%
    stringr::str_extract("\\d{4}-\\d{2}-\\d{2}(?=\\.xlsx$)") %>%
    lubridate::as_date() %>%
    magrittr::extract(. < lubridate::as_date(ballot_date)) %>%
    max()
  
  data <-
    path_private(glue::glue("data/{canton}/voting_register_data_extra_{date_data}.xlsx")) %>%
    readxl::read_xlsx(col_types = "text") %>%
    # rename variables to our scheme
    dplyr::rename(id_statistical_office = `ID-Nummer`,
                  sex_official = Geschlecht,
                  year_of_birth_official = Jahrgang,
                  marital_status_official = Zivilstand,
                  household_size_official = "Haushaltsgr\u00f6sse Anzahl Personen Total",
                  n_adults_in_household_official = "Haushaltsgr\u00f6sse Anzahl Personen \u00fcber 18 Jahren",
                  n_kids_in_household_official = "Haushaltsgr\u00f6sse Anzahl Personen unter 18 Jahren") %>%
    # convert numeric columns to type integer
    dplyr::mutate(dplyr::across(.cols = c(id_statistical_office,
                                          year_of_birth_official,
                                          household_size_official,
                                          n_adults_in_household_official,
                                          n_kids_in_household_official),
                                .fns = as.integer)) %>%
    # transform variable values to our scheme
    dplyr::mutate(dplyr::across(.cols = c(sex_official, marital_status_official),
                                .fns = stringr::str_to_lower)) %>%
    dplyr::mutate(marital_status_official = dplyr::recode(.x = marital_status_official,
                                                          "eingetragene partnerschaft" = "in eingetragener Partnerschaft",
                                                          "aufgel\u00f6ste partnerschaft" = "aufgel\u00f6ste Partnerschaft",
                                                          "unverheiratet" = "ledig"))
  
  # integrity check 1: ensure no unexpected columns occur
  if (ncol(data) > 7L) {
    
    unknown_colnames <-
      colnames(data) %>%
      setdiff(c(id_statistical_office,
                sex_official,
                year_of_birth_official,
                marital_status_official,
                household_size_official,
                n_adults_in_household_official,
                n_kids_in_household_official))
    
    cli::cli_abort("Unexpected column(s) detected in {.file data/{canton}/voting_register_data_extra_{date_data}.xlsx}: {.val unknown_colnames}")
  }
  
  # TODO!
  # # integrity check 2: ensure no unexpected values occur
  # ## in `sex_official`
  # unknown_sex_official_i <-
  #   data$sex_official %>%
  #   magrittr::is_in(fa_fct_labels(v_name = "sex_official",
  #                                 check_v_presence = FALSE,
  #                                 lang = "de")) %>%
  #   magrittr::not() %>%
  #   which()
  # 
  # if (length(unknown_sex_official_i)) {
  #   
  #   rlang::abort(message = style_error(paste0(
  #     style_v_name("sex_official"), " in raw Statistik Aargau data has unknown values: ",
  #     data$sex_official[unknown_sex_official_i] %>%
  #       unique() %>%
  #       style_arg_invalid() %>%
  #       list_pretty(lang = "en")
  #   )))
  # }
  # ## in `marital_status_official`
  # unknown_marital_status_official_i <-
  #   data$marital_status_official %>%
  #   magrittr::is_in(fa_fct_labels(v_name = "marital_status_official",
  #                                 check_v_presence = FALSE,
  #                                 lang = "de")) %>%
  #   magrittr::not() %>%
  #   which()
  # 
  # if (length(unknown_marital_status_official_i)) {
  #   
  #   rlang::abort(message = style_error(paste0(
  #     style_v_name("marital_status_official"), " in raw Statistik Aargau data has unknown values: ",
  #     data$sex_official[unknown_marital_status_official_i] %>%
  #       unique() %>%
  #       style_arg_invalid() %>%
  #       list_pretty(lang = "en")
  #   )))
  # }
  
  data
}
```

#### `read_voting_register_ids`

```{r}
read_voting_register_ids <- function(ballot_date = ballot_dates,
                                     canton = cantons) {
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  path_private(glue::glue("data/{canton}/voting_register_ids_{ballot_date}.csv")) %>%
    readr::read_csv(col_types = "i") %>%
    # integrity check
    purrr::when(ncol(.) > 1L ~ cli::cli_abort("More than one column present in {.file data/{canton}/voting_register_ids_{ballot_date}.csv}. Please debug."),
                ~ .) %>%
    dplyr::first()
}
```

### Google Apps

#### `auth_g_drive_gcp`

```{r}
#' Authorize googledrive using GCP Service Account Key
#'
#' Authorizes the googledrive package to access and manage files on your Google Drive via a [Google Cloud Platform (GCP) Service
#' Account Key](https://cloud.google.com/iam/docs/creating-managing-service-account-keys) file in JSON format. See the [relevant googledrive
#' documentation](https://gargle.r-lib.org/articles/non-interactive-auth.html#provide-a-service-account-token-directly) for details.
#'
#' @param path_gcp_service_account_key Path to the GCP Service Account Key JSON file.
#'
#' @return `path_gcp_service_account_key`, invisibly.
#' @family g_apps
#' @keywords internal
auth_g_drive_gcp <- function(path_gcp_service_account_key = path_private("config/gcp_service_account_key.json")) {
  
  pal::assert_pkg("googledrive")
  is_file <- checkmate::test_file_exists(path_gcp_service_account_key,
                                         access = "r")
  
  if (is_file) {
    
    status_msg <- "Authenticating Google account..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    googledrive::drive_auth(path = path_gcp_service_account_key,
                            email = TRUE)
    
  } else {
    cli::cli_abort(paste0("No Google Cloud Platform service account key found under {.path {path_gcp_service_account_key}} ",
                          "Instructions to store such a key can be found here: ",
                          # TODO: the `#` char in the URL somehow breaks cli's class formatting (`{.url ...}`) -> report bug!
                          "https://gargle.r-lib.org/articles/non-interactive-auth.html#provide-a-service-account-token-directly"))
  }
  
  invisible(path_gcp_service_account_key)
}
```

### Miscellaneous

#### `assert_countish`

DEPRECATED

Assertion that

-   allows a count as a character-scalar and converts its input to an integer scalar.
-   checks for `positive = TRUE` *by default*.

```{r}
assert_countish <- function(x,
                            positive = TRUE,
                            null_ok = FALSE) {
  
  if (null_ok && is.null(x)) {
    x
    
  } else {
    checkmate::assert_count(as.integer(x),
                            positive = positive)
  }
}
```

#### `assert_integerish`

DEPRECATED

Assertion that

-   allows integers as characters and converts its input to type integer.
-   forbids missing values *by default*.

```{r}
assert_integerish <- function(x,
                              lower = -Inf,
                              upper = Inf,
                              any_missing = FALSE,
                              all_missing = FALSE,
                              null_ok = FALSE) {
  
  if (null_ok && is.null(x)) {
    x
    
  } else {
    checkmate::assert_integerish(as.integer(x),
                                 lower = lower,
                                 upper = upper,
                                 any.missing = any_missing,
                                 all.missing = all_missing,
                                 coerce = TRUE)
  }
}
```

#### `as_flat_list`

NOTES:

-   This differs substantially from `pal::as_flat_list()`; it preserves all (sub)names by concatenating them but doesn't preserve any attributes, so data frames
    & co. are destroyed.

```{r}
as_flat_list <- function(x) {
  
  result <- x
  depth <- purrr::vec_depth(result)
  
  # unlist until only a single list level remains
  while (depth > 2L) {
    
    result %<>% unlist(recursive = FALSE)
    depth <- purrr::vec_depth(result)
  }
  
  # wrap in list if necessary
  if (depth < 2L && !is.list(x)) {
    
    result <- list(x)
  }
  
  result
}
```

#### `collapse_break`

Collapse char vector into single string separated by single HTML line breaks (`<br>` tags)

```{r}
collapse_break <- function(s) {
  
  paste0(s, collapse = "<br>")
}
```

#### `wrap_backtick`

Wrap a char vector in backticks

```{r}
wrap_backtick <- function(s) {
  
  purrr::map_chr(.x = s,
                 .f = ~ dplyr::if_else(.x == "-" | stringr::str_detect(string = .x,
                                                                       pattern = "^(_.*_|\\*.*\\*)$"),
                                       as.character(.x),
                                       paste0("`", .x, "`")))
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

### Questionnaire and survey

```{r}
# questionnaire item subkeys (lowest level only, i.e. without ballot types)
q_item_subkeys <- c("true",
                    "false",
                    "default",
                    "YYYYMMDD",
                    "YYYYMMDD_YYYYMMDD")
# URLs
url_survey_host <- list(aargau = "https://umfrage.fokus.ag")
url_parameter_survey <- list(aargau = "pw")
```

### Unicode sequences

```{r}
unicode_checkmark <- "\u2705"
unicode_crossmark <- "\u274C"
unicode_ellipsis  <- "\u2026"
```

### Miscellaneous

```{r}
global_cache_lifespan <- "30 days"
```

# EXPORTED

## FOKUS metadata

### DESCRIPTION

Metadata about the FOKUS surveys, generated from the raw supplemental date-specific questionnaire data files found under
[`data-raw/questionnaire/YYYY-MM-DD.toml`](https://gitlab.com/zdaarau/rpkgs/fokus/-/tree/master/data-raw/questionnaire/) that serve as the "source of truth" for
the [predicate functions](#section-predicates).

### `ballot_dates`

TODO:

-   Unfortunately, the roxygen2 `@family` tag doesn't seem to work for datasets. Thus, we manually specify the documentation links using `@seealso` ->
    investigate the underlying cause and ideally file a bug report.

```{r}
#' FOKUS-covered ballot dates
#'
#' A vector of ballot dates covered by FOKUS surveys up until `r max(ballot_dates)`.
#'
#' @format `r pkgsnip::return_label("dates")`
#' @seealso [`cantons`][cantons] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys] [`proposal_types`][proposal_types]
#' @export
"ballot_dates"
```

### `cantons`

```{r}
#' Cantons covered in *any* FOKUS survey
#'
#' A vector of cantons that were part of at least one FOKUS survey up until `r max(ballot_dates)`.
#'
#' @format A character vector.
#' @seealso [`ballot_dates`][ballot_dates] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys] [`proposal_types`][proposal_types]
#' @export
"cantons"
```

### `proposal_types`

```{r}
#' Referendum proposal types
#'
#' A vector of all [referendum proposal types][proposal_type].
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys]
#' @export
"proposal_types"
```

### `response_option_types`

```{r}
#' Response option types
#'
#' A vector of all response option types defined in the [raw FOKUS questionnaire data][raw_q].
#'
#' @format A character vector.
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`proposal_types`][proposal_types] [`q_item_keys`][q_item_keys]
#' @export
"response_option_types"
```

### `q_item_keys`

```{r}
#' Questionnaire item keys
#'
#' A tibble of item keys supported in the [raw FOKUS questionnaire data][raw_q].
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`response_option_types`][response_option_types] [`proposal_types`][proposal_types]
#' @export
"q_item_keys"
```

## Predicates

### DESCRIPTION

Predicate functions based on the [metadata](#section-fokus-metadata).

### Fundamental predicates

#### `ballot_types`

```{r}
#' Determine ballot types
#'
#' Determines the types of the ballot for the specified canton at the specified date.
#'
#' @param ballot_date A valid FOKUS-covered cantonal ballot date. One of
#' `r pal::as_md_list(paste0('"', ballot_dates, '"'), wrap = '``')`
#' @param canton A valid FOKUS canton. One of
#' `r pal::as_md_list(paste0('"', cantons, '"'), wrap = '``')`
#'
#' @return A character vector of ballot types. One or more of
#'   - `"referendum"`
#'   - `"election"`
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::ballot_types(ballot_date = "2018-09-23",
#'                     canton = "aargau")
ballot_types <- function(ballot_date = ballot_dates,
                         canton = cantons) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  has_election <- has_election(ballot_date = ballot_date,
                               canton = canton)
  
  has_referendum <- has_referendum(ballot_date = ballot_date,
                                   canton = canton)
  
  c("referendum"[has_referendum],
    "election"[has_election])
}
```

#### `n_proposals`

```{r}
#' Get number of referendum proposals
#'
#' Determines the number of referendum proposals for a canton at the specified ballot date on the specified political level(s).
#'
#' Technically, the number of *federal* proposals is independent from the canton, but this function still expects a valid `canton`. Nonetheless, the returned
#' number of *federal* proposals at a specific ballot date is always the same regardless of `canton`.
#'
#' @inheritParams n_elections
#'
#' @inherit n_elections return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::n_proposals(ballot_date = "2018-09-23",
#'                    canton = "aargau")
n_proposals <- function(ballot_date = ballot_dates,
                        lvls = c("cantonal", "federal"),
                        canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = c("cantonal", "federal"),
                                          empty.ok = FALSE))
  
  raw <- raw_q_suppl(ballot_date = ballot_date)
  result <- 0L
  
  if ("federal" %in% lvls) {
    result %<>% magrittr::add(length(raw$federal$proposal))
  }
  
  if ("cantonal" %in% lvls) {
    result %<>% magrittr::add(length(raw$cantonal[[canton]]$proposal))
  }
  
  result
}
```

#### `n_elections`

```{r}
#' Get number of elections
#'
#' Determines the number of elections for a canton at the specified ballot date on the specified political level(s) and of the specified election procedure(s).
#'
#' @inheritParams ballot_types
#' @param lvls Political level(s). One or more of
#'   - `"cantonal"`
#'   - `"federal"`
#' @param prcds Election procedure(s). One or more of
#'   - `"proportional"`
#'   - `"majoritarian"`
#'
#' @return An integer.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::n_elections(ballot_date = "2018-09-23",
#'                    canton = "aargau")
n_elections <- function(ballot_date = ballot_dates,
                        lvls = c("cantonal", "federal"),
                        canton = cantons,
                        prcds = c("proportional", "majoritarian")) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = c("cantonal", "federal"),
                                          empty.ok = FALSE))
  canton <- rlang::arg_match(canton)
  prcds <- unique(checkmate::assert_subset(prcds,
                                           choices = c("proportional", "majoritarian"),
                                           empty.ok = FALSE))
  result <- 0L
  raw <- raw_q_suppl(ballot_date = ballot_date)
  
  if ("federal" %in% lvls) {
    
    result <-
      prcds %>%
      purrr::map_int(~ length(raw$federal$election[[.x]])) %>%
      sum() %>%
      purrr::when(length(.) == 0L ~ 0L,
                  ~ .) %>%
      magrittr::add(result)
  }
  
  if ("cantonal" %in% lvls) {
    
    result <-
      prcds %>%
      purrr::map_int(~ length(raw$cantonal[[canton]]$election[[.x]])) %>%
      sum() %>%
      purrr::when(length(.) == 0L ~ 0L,
                  ~ .) %>%
      magrittr::add(result)
  }
  
  result
}
```

#### `has_referendum`

```{r}
#' Determine whether ballot type includes a referendum
#'
#' Determines whether or not the ballot in the specified canton at the specified date on the specified political level(s) includes a referendum.
#'
#' Note that if more than one `lvls` are provided (the default), they are interpreted according to the rules of [logical
#' disjunction](https://en.wikipedia.org/wiki/Logical_disjunction), i.e. `TRUE` is returned if *any* `lvls` are included in the specified ballot.
#' 
#' For [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction), use `has_referendum(lvls = "cantonal") && has_referendum(lvls = "federal")`.
#'
#' @inheritParams n_elections
#'
#' @inherit has_election return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_referendum(ballot_date = "2018-09-23",
#'                       lvls = "federal",
#'                       canton = "aargau")
has_referendum <- function(ballot_date = ballot_dates,
                           lvls = c("cantonal", "federal"),
                           canton = cantons) {
  
  n_proposals(ballot_date = ballot_date,
              lvls = lvls,
              canton = canton) > 0L
}
```

#### `has_election`

```{r}
#' Determine whether ballot type includes an election
#'
#' Determines whether or not the ballot for the specified canton at the specified date on the specified political level(s) includes an election of the specified
#' election procedure(s).
#'
#' Note that if more than one `lvls`/`prcds` are provided (the default), they are interpreted according to the rules of [logical
#' disjunction](https://en.wikipedia.org/wiki/Logical_disjunction), i.e. `TRUE` is returned if *any* `lvls`/`prcds` are included in the specified ballot.
#' 
#' For [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction), use e.g. `has_election(lvls = "cantonal") && has_election(lvls = "federal")`.
#'
#' @inheritParams n_elections
#'
#' @return A logical scalar.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_election(ballot_date = "2018-09-23",
#'                     canton = "aargau")
has_election <- function(ballot_date = ballot_dates,
                         lvls = c("cantonal", "federal"),
                         canton = cantons,
                         prcds = c("proportional", "majoritarian")) {
  
  n_elections(ballot_date = ballot_date,
              lvls = lvls,
              canton = canton,
              prcds = prcds) > 0L
}
```

#### `has_lvl`

```{r}
#' Determine whether ballot includes a political level
#'
#' Determines whether or not the ballot in the specified canton at the specified date includes the specified political level.
#'
#' @inheritParams election_name
#'
#' @inherit has_election return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_lvl(ballot_date = "2018-09-23",
#'                lvl = "federal",
#'                canton = "aargau")
has_lvl <- function(ballot_date = ballot_dates,
                    lvl = c("cantonal", "federal"),
                    canton = cantons) {
  
  lvl <- rlang::arg_match(lvl)
  
  has_election(ballot_date = ballot_date,
               lvls = lvl,
               canton = canton) ||
    has_referendum(ballot_date = ballot_date,
                   lvls = lvl,
                   canton = canton)
}
```

### Proposal predicates

#### `proposal_type`

```{r}
#' Get proposal type
#'
#' @inheritParams proposal_name
#'
#' @return Proposal type. One of
#' `r pal::as_md_list(paste0('"', proposal_types, '"'), wrap = '``')`
#' 
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_type(ballot_date = "2018-09-23",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      proposal_nr = 1)
proposal_type <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          proposal_nr = 1L) {
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::chuck("type")
}
```

#### `proposal_name`

```{r}
#' Get proposal name
#'
#' Returns the name of the specified proposal in the specified language.
#'
#' @inheritParams ballot_types
#' @param lvl Political level. One of
#'   - `"cantonal"`
#'   - `"federal"`
#' @param proposal_nr Proposal number. A positive integer scalar.
#' @param lang Language. One of
#'   - `"de"`
#'   - `"en"`
#' @param type Name type. One of
#'   - `"short"`
#'   - `"long"`
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_name(ballot_date = "2018-09-23",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      proposal_nr = 1,
#'                      type = "long")
proposal_name <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          proposal_nr = 1L,
                          lang = c("de", "en"),
                          type = c("short", "long")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            proposal_nr = proposal_nr) %>%
    purrr::chuck(lang, type, "text")
}
```

#### `proposal_name_gender`

```{r}
#' Get German proposal name's grammatical gender
#'
#' Returns the grammatical gender of the German name of the specified proposal.
#'
#' @inheritParams proposal_name
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_name_gender(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1,
#'                             type = "short")
proposal_name_gender <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr = 1L,
                                 type = c("short", "long")) {
  
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            proposal_nr = proposal_nr) %>%
    purrr::chuck("de", type, "gender")
}
```

#### `proposal_arguments`

```{r}
#' Get proposal's arguments
#'
#' Returns text, side and number of all arguments on the specified proposal.
#'
#' @inheritParams proposal_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_arguments(ballot_date = "2018-09-23",
#'                           lvl = "cantonal",
#'                           canton = "aargau",
#'                           proposal_nr = 1)
proposal_arguments <- function(ballot_date = ballot_dates,
                               lvl = c("cantonal", "federal"),
                               canton = cantons,
                               proposal_nr = 1L) {
  
  raw_q_suppl_arguments(ballot_date = ballot_date,
                        lvl = lvl,
                        canton = canton,
                        proposal_nr = proposal_nr) %>%
    purrr::map(as_flat_list) %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `proposal_main_motives`

```{r}
#' Get proposal's main motives
#'
#' Returns text and code number of all main motives on the specified proposal.
#'
#' @inheritParams proposal_name
#' @param type Main motive type. One of
#'   - `"yes"`
#'   - `"no"`
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_main_motives(ballot_date = "2018-09-23",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              proposal_nr = 1,
#'                              type = "no")
proposal_main_motives <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  proposal_nr = 1L,
                                  type = c("yes",
                                           "no")) {
  type <- rlang::arg_match(type)
  
  raw_q_suppl_main_motives(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           proposal_nr = proposal_nr) %>%
    purrr::chuck(type) %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `n_proposal_main_motives`

```{r}
#' Get proposal's number of main motives
#'
#' Determines the number of main motives on the specified proposal.
#'
#' @inheritParams proposal_main_motives
#'
#' @return An integer scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::n_proposal_main_motives(ballot_date = "2018-09-23",
#'                                lvl = "cantonal",
#'                                canton = "aargau",
#'                                proposal_nr = 1,
#'                                type = "no")
n_proposal_main_motives <- function(ballot_date = ballot_dates,
                                    lvl = c("cantonal", "federal"),
                                    canton = cantons,
                                    proposal_nr = 1L,
                                    type = c("yes",
                                             "no")) {
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::pluck("main_motive") %>%
    purrr::pluck(type) %>%
    length()
}
```

#### `n_proposal_arguments`

```{r}
#' Get proposal's number of arguments
#'
#' Determines the number of arguments on the specified proposal.
#'
#' @inheritParams proposal_main_motives
#'
#' @return An integer scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::n_proposal_arguments(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1)
n_proposal_arguments <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr = 1L) {
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::pluck("argument") %>%
    length()
}
```

### Election predicates

#### `n_election_candidates`

```{r}
#' Get number of (officially registered) majoritarian election candidates
#'
#' Determines the number of (officially registered) candidates of a majoritarian election at the specified ballot date on the specified political level.
#'
#' @inheritParams election_name
#'
#' @return An integer scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::n_election_candidates(ballot_date = "2019-10-20",
#'                              lvl = "cantonal",
#'                              canton = "aargau")
n_election_candidates <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    length()
}
```

#### `n_election_seats`

```{r}
#' Get number of majoritarian election seats
#'
#' Determines the number of election seats of the specified type for the specified majoritarian election.
#'
#' @inheritParams election_name
#' @param type Seat type. One of
#'  - `"vacant"`
#'  - `"total"`
#'
#' @return An integer scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::n_election_seats(ballot_date = "2019-10-20",
#'                         lvl = "cantonal",
#'                         canton = "aargau",
#'                         type = "total")
n_election_seats <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L,
                             type = c("vacant", "total")) {
  
  type <- rlang::arg_match(type)
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("n_seats", type)
}
```

#### `election_name`

```{r}
#' Get election name
#'
#' Returns the name of the specified election in the specified language.
#'
#' @inheritParams proposal_name
#' @param prcd Election procedure. One of
#'   - `"proportional"`
#'   - `"majoritarian"`
#' @param election_nr Election number. A positive integer scalar (in almost all cases `1L`).
#' @param type Name type. One of
#'   - `"short"`
#'   - `"long"`
#'   - `"body"`
#'   - `"body_alt"`
#'
#' @return A character scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_name(ballot_date = "2019-10-20",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      prcd = "majoritarian",
#'                      election_nr = 1,
#'                      type = "body")
election_name <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          prcd = c("proportional", "majoritarian"),
                          election_nr = 1L,
                          lang = c("de", "en"),
                          type = c("short", "long", "body", "body_alt")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  
  raw_q_suppl_election_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            prcd = prcd,
                            election_nr = election_nr) %>%
    purrr::chuck(lang, type, "text")
}
```

#### `election_names_combined`

```{r}
#' Get combined elections name
#'
#' Returns the combined name of all elections at the specified date on the specified level for the specified canton.
#'
#' @inheritParams election_name
#'
#' @return A character scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_names_combined(ballot_date = "2019-10-20",
#'                                lvl = "federal",
#'                                canton = "aargau")
election_names_combined <- function(ballot_date = ballot_dates,
                                    lvl = c("cantonal", "federal"),
                                    canton = cantons) {
  
  raw_q_suppl_elections(ballot_date = ballot_date,
                        lvl = lvl,
                        canton = canton) %>%
    purrr::chuck("names_combined", "de", "short")
}
```

#### `election_candidates`

```{r}
#' Get majoritarian election's candidates
#'
#' Returns the name and party of all candidates running for the specified majoritarian election.
#'
#' @inheritParams election_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_candidates(ballot_date = "2019-10-20",
#'                            lvl = "cantonal",
#'                            canton = "aargau")
election_candidates <- function(ballot_date = ballot_dates,
                                lvl = c("cantonal", "federal"),
                                canton = cantons,
                                election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `election_candidate_string`

```{r}
#' Assemble majoritarian election's candidate string(s)
#'
#' Assembles one or more majoritarian election candidate string(s) consisting of the candidate's first name, last name and optionally political party (in
#' parentheses).
#'
#' @inheritParams election_name
#' @param candidate_nrs Election candidate numbers to include. A vector of positive integers or `NULL`. If `NULL`, all candidates will be included.
#' @param incl_party Whether or not to include the candidate's political party in the resulting string (in parentheses).
#'
#' @return A character vector.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_candidate_string(ballot_date = "2019-10-20",
#'                                  lvl = "cantonal",
#'                                  canton = "aargau",
#'                                  candidate_nrs = 1:3)
election_candidate_string <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      election_nr = 1L,
                                      candidate_nrs = NULL,
                                      incl_party = TRUE) {
  
  data_candidates <- election_candidates(ballot_date = ballot_date,
                                         lvl = lvl,
                                         canton = canton,
                                         election_nr = election_nr)
  
  checkmate::assert_integerish(candidate_nrs,
                               lower = 1L,
                               upper = nrow(data_candidates),
                               any.missing = FALSE,
                               null.ok = TRUE)
  checkmate::assert_flag(incl_party)
  
  if (length(candidate_nrs)) {
    data_candidates %<>% dplyr::filter(dplyr::row_number() %in% candidate_nrs)
  }
  
  data_candidates %>% purrr::pmap_chr(incl_party = incl_party,
                                      .f = function(first_name, last_name, party, ..., incl_party) {
                                        paste0(first_name, " ", last_name, paste0(" (", party, ")")[incl_party])
                                      })
}
```

#### `election_parties`

```{r}
#' Get proportional election's political parties
#'
#' Returns the questionnaire code as well as different versions of the name of all parties for the specified proportional election.
#'
#' @inheritParams election_name
#' @param past Whether to extract the current or the predecessor election's parties.
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_parties(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau")
#'
#' fokus::election_parties(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau",
#'                         past = TRUE)
election_parties <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L,
                             past = FALSE) {
  
  checkmate::assert_flag(past)
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "proportional",
                       election_nr = election_nr) %>%
    purrr::chuck(dplyr::if_else(past,
                                "past_party",
                                "party")) %>%
    purrr::map(as_flat_list) %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `election_tickets`

```{r}
#' Get proportional election's tickets
#'
#' Returns the name, number and party of all tickets for the specified proportional election.
#'
#' @inheritParams election_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_tickets(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau")
election_tickets <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "proportional",
                       election_nr = election_nr) %>%
    purrr::chuck("ticket") %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `requires_candidate_registration`

```{r}
#' Determine whether majoritarian election requires candidate registration
#'
#' Determines whether or not candidates must be officially registered prior to the specified majority election.
#' 
#' The absence of a candidate registration requirement usually means that every eligible citizen can be elected, i.e. receive valid votes.
#'
#' @inheritParams election_name
#'
#' @return A logical scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::requires_candidate_registration(ballot_date = "2019-10-20",
#'                                        lvl = "federal",
#'                                        canton = "aargau")
requires_candidate_registration <- function(ballot_date = ballot_dates,
                                            lvl = c("cantonal", "federal"),
                                            canton = cantons,
                                            election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("requires_candidate_registration")
}
```

### Skill question predicates

#### `n_skill_questions`

```{r}
#' Get number of skill questions
#'
#' Determines the number of skill questions at the specified ballot date on the specified political level.
#'
#' @inheritParams election_name
#' @param canton A valid FOKUS canton. One of
#' `r pal::as_md_list(paste0('"', cantons, '"'), wrap = '``')`
#' 
#' Only relevant if `lvl = "cantonal"`.
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, the number of non-proposal-specific skill questions is returned.
#'
#' @return An integer scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::n_skill_questions(ballot_date = "2018-09-23",
#'                          lvl = "cantonal",
#'                          canton = "aargau",
#'                          proposal_nr = 1)
n_skill_questions <- function(ballot_date = ballot_dates,
                              lvl = c("cantonal", "federal"),
                              canton = cantons,
                              proposal_nr = NULL) {
  
  lvl <- rlang::arg_match(lvl)
  canton <- rlang::arg_match(canton)
  checkmate::assert_count(proposal_nr,
                          positive = TRUE,
                          null.ok = TRUE)
  lvl %>%
    purrr::when(
      
      # federal non-proposal-specific skill questions (e.g. at federal elections)
      length(proposal_nr) == 0L && . == "federal" ~
        raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl),
      # cantonal non-proposal-specific skill questions (e.g. at cantonal elections)
      length(proposal_nr) == 0L && . == "cantonal" ~
        raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl) %>%
        purrr::pluck(canton),
      # federal or cantonal proposal-specific skill questions
      ~ raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl) %>%
        purrr::when(lvl == "cantonal" ~ purrr::pluck(., canton),
                    ~ .) %>%
        purrr::pluck("proposal") %>%
        purrr::pluck(proposal_nr)
    ) %>%
    purrr::pluck("skill_question") %>%
    length()
}
```

#### `skill_question`

```{r}
#' Get skill question
#'
#' Returns the skill question text in the specified language.
#'
#' @inheritParams proposal_name
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, it is considered to be a non-proposal-specific skill question 
#'   (the case at elections).
#' @param skill_question_nr Skill question number. A positive integer scalar.
#'
#' @return A character scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question(ballot_date = "2018-09-23",
#'                       lvl = "cantonal",
#'                       canton = "aargau",
#'                       proposal_nr = 1,
#'                       skill_question_nr = 2,
#'                       lang = "en")
skill_question <- function(ballot_date = ballot_dates,
                           lvl = c("cantonal", "federal"),
                           canton = cantons,
                           proposal_nr = NULL,
                           skill_question_nr,
                           lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck(lang)
}
```

#### `skill_question_response_options`

```{r}
#' Get skill question response options
#'
#' Returns the response options of the specified skill question together with the information whether they are correct or not.
#'
#' @inheritParams skill_question
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_response_options(ballot_date = "2018-09-23",
#'                                        lvl = "cantonal",
#'                                        canton = "aargau",
#'                                        proposal_nr = 1,
#'                                        skill_question_nr = 2)
skill_question_response_options <- function(ballot_date = ballot_dates,
                                            lvl = c("cantonal", "federal"),
                                            canton = cantons,
                                            proposal_nr = NULL,
                                            skill_question_nr) {
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map_dfr(tibble::as_tibble)
}
```

#### `skill_question_answer_nr`

```{r}
#' Get correct skill question answer number
#'
#' Returns the sequential number of the correct answer for the specified skill question.
#'
#' @inheritParams skill_question
#'
#' @return An integer scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_answer_nr(ballot_date = "2018-09-23",
#'                                 lvl = "cantonal",
#'                                 canton = "aargau",
#'                                 proposal_nr = 1,
#'                                 skill_question_nr = 2)
skill_question_answer_nr <- function(ballot_date = ballot_dates,
                                     lvl = c("cantonal", "federal"),
                                     canton = cantons,
                                     proposal_nr = NULL,
                                     skill_question_nr) {
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map_depth(.depth = 1L,
                     .f = ~ .x$is_correct) %>%
    purrr::flatten_lgl() %>%
    which()
}
```

### Other predicates

#### `ballot_title`

```{r}
#' Get ballot title
#'
#' Returns the ballot title consisting of the [ballot type][ballot_types()] and the ballot date in German prose.
#'
#' @inheritParams proposal_name
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' ballot_title(ballot_date = "2019-10-20",
#'              canton = "aargau")
ballot_title <- function(ballot_date,
                         canton,
                         lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  ballot_types <- ballot_types(ballot_date = ballot_date,
                               canton = canton)
  
  if (!length(ballot_types)) {
    cli::cli_abort("No ballot type could be determined. Please debug.")
  }
  
  if (lang == "de") {
    
    result <-
      ballot_types %>%
      purrr::when(length(.) > 1L ~ "Abstimmungs- und Wahl",
                  . == "referendum" ~ "Abstimmungs",
                  . == "election" ~ "Wahl") %>%
      glue::glue("termin vom {prettify_date(ballot_date, locale = lang)}")
    
  } else if (lang == "en") {
    
    result <-
      ballot_types %>%
      purrr::when(length(.) > 1L ~ "Referendum and election",
                  ~ stringr::str_to_sentence(.)) %>%
      glue::glue(" date of {prettify_date(ballot_date, locale = lang)}")
  }
  
  result
}
```

#### `political_issues`

```{r}
#' Get political issues
#'
#' Returns the political issues in the specified language.
#'
#' @inheritParams proposal_name
#'
#' @return A character vector.
#' @family predicate_other
#' @export
#'
#' @examples
#' fokus::political_issues(ballot_date = "2019-10-20",
#'                         lang = "en")
political_issues <- function(ballot_date = ballot_dates,
                             lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  result <-
    raw_q_suppl(ballot_date = ballot_date) %>%
    purrr::pluck("political_issues")
  
  if (is.null(result)) {
    
    # reduce to proper arg value for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    
    cli::cli_abort("No political issues present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  result %>%
    purrr::chuck("issue") %>%
    purrr::map_depth(1L, purrr::chuck, lang) %>%
    purrr::flatten_chr()
}
```

## Questionnaire and survey

### DESCRIPTION

Functions to process the \[raw FOKUS questionnaire data\]\[#raw-questionnaire-data\] and other functions to conduct a survey.

### `export_q`

```{r}
#' Export questionnaire data
#'
#' Generates the [questionnaire tibble][gen_q_tibble], the [Markdown questionnaire][gen_q_md] and optionally a CSV, an HTML and an XLSX version of it, and
#' writes all of them to the [private FOKUS directory][print_fokus_private_structure] and optionally deploys them as a static site (`local_deploy_path`) and
#' uploads them to a Google Drive folder (`g_drive_folder`).
#'
#' @inheritParams gen_q_tibble
#' @param incl_csv Whether or not to also generate and export a CSV version of the questionnaire.
#' @param incl_html Whether or not to also generate and export an HTML version of the questionnaire.
#' @param incl_xlsx Whether or not to also generate and export an XLSX version of the questionnaire.
#' @param deploy Whether or not to deploy the generated files as a static site to the Git repository specified under `local_deploy_path`.
#' @param local_deploy_path Local filesystem path to the Git repository of the static site to deploy the generated files files to. Ignored if `deploy = FALSE`.
#' @param upload_to_g_drive Whether or not to upload the generated files to the Google Drive folder `g_drive_folder`.
#' @param g_drive_folder Google Drive folder to deploy the generated files to. Ignored if `upload_to_g_drive = FALSE`.
#'
#' @family q_gen
#' @export
export_q <- function(ballot_date = ballot_dates,
                     canton = cantons,
                     verbose = FALSE,
                     incl_csv = TRUE,
                     incl_html = TRUE,
                     incl_xlsx = incl_html,
                     deploy = TRUE,
                     local_deploy_path = getOption("fokus.q.local_deploy_path"),
                     upload_to_g_drive = TRUE,
                     g_drive_folder = "fokus_aargau/Umfragen/Dateien f\u00fcr publitest/Fragebogen/") {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  checkmate::assert_flag(incl_csv)
  checkmate::assert_flag(incl_html)
  checkmate::assert_flag(incl_xlsx)
  if (incl_xlsx && !incl_html) {
    cli::cli_abort("{.arg incl_html} must be set to {.val TRUE} when {.code incl_xlsx = TRUE} because the XLSX file is generated from the HTML file.")
  }
  checkmate::assert_flag(deploy)
  checkmate::assert_string(local_deploy_path,
                           null.ok = TRUE)
  checkmate::assert_flag(upload_to_g_drive)
  pal::assert_pkg("rmarkdown")
  pal::assert_pkg("yay")
  
  md_path <- path_private(glue::glue("output/questionnaires/questionnaire_{ballot_date}_{canton}.md"))
  
  # Generate questionnaire tibble and Markdown version
  q_tibble <- gen_q_tibble(ballot_date = ballot_date,
                           verbose = verbose)
  
  q_tibble %>%
    gen_q_md() %>%
    readr::write_lines(file = md_path)
  
  # create CSV version from tibble if requested
  if (incl_csv) {
    
    status_msg <- "Converting questionnaire tibble to CSV..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    csv_path <- md_path %>% fs::path_ext_set(ext = "csv")
    
    q_tibble %>%
      clean_q_tibble() %>%
      dplyr::mutate(variable_name_32 =
                      purrr::map2_chr(.x = variable_name,
                                      .y = dplyr::if_else(block %in% c("x_publitest", "y_generated", "z_generated")
                                                          | stringr::str_detect(string = variable_name,
                                                                                pattern = paste0("^", pal::fuse_regex(c("agreement_contra_argument_",
                                                                                                                        "information_source_",
                                                                                                                        "reason_non_participation_",
                                                                                                                        "political_occasions_")))),
                                                          32L,
                                                          30L),
                                      .f = ~ shorten_v_names(v_names = .x,
                                                             max_n_char = .y)),
                    .after = variable_name) %>%
      dplyr::select(-ends_with("_common"),
                    -c(lvl, i, j)) %>%
      expand_q_tibble() %>%
      readr::write_csv(file = csv_path,
                       na = "")
  }
  
  # create HTML version from Markdown questionnaire if requested
  if (incl_html) {
    
    html_path <- fs::path_ext_set(path = md_path,
                                  ext = "html")
    path_dir <- fs::path_dir(html_path)
    
    status_msg <- "Converting Markdown questionnaire to HTML using Pandoc..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    rmarkdown::pandoc_convert(input = md_path,
                              to = "html5",
                              from = "markdown",
                              output = html_path,
                              options = c("--standalone",
                                          "--css=github-pandoc.css",
                                          paste0('--metadata=title:FOKUS-Aargau-Fragebogen f\u00fcr den ', ballot_title(ballot_date = ballot_date,
                                                                                                                        canton = canton))),
                              verbose = FALSE)
    cli::cli_progress_done()
  }
  
  # create XLSX version from HTML questionnaire if requested
  if (incl_xlsx) {
    
    status_msg <- "Converting HTML questionnaire to XLSX using LibreOffice..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    system2(command = "flatpak",
            args = glue::glue("run --command=libreoffice",
                              "org.libreoffice.LibreOffice",
                              "--calc",
                              "--headless",
                              "--convert-to xlsx",
                              "--outdir \"{path_dir}\"",
                              "\"{html_path}\"",
                              .sep = " "))
    cli::cli_progress_done()
  }
  
  # deploy HTML to GitLab Pages if requested
  if (deploy) {
    
    status_msg <- "Deploying questionnaire to GitLab Pages..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    yay::deploy_static_site(from_path = path_dir,
                            to_path = "~/Arbeit/ZDA/Git/c2d-zda/c2d-zda.gitlab.io/public/",
                            clean_to_path = FALSE)
    cli::cli_progress_done()
  }
  
  # upload files to Google Drive for polling agency if requested
  if (upload_to_g_drive) {
    
    upload_to_g_drive(filepaths = c(md_path,
                                    csv_path[incl_csv],
                                    html_path[incl_html],
                                    fs::path(path_dir, "github-pandoc.css")[incl_html],
                                    fs::path_ext_set(path = html_path,
                                                     ext = "xlsx")[incl_xlsx]),
                      g_drive_folder = g_drive_folder)
  }
}
```

### `export_qr_codes`

Generates personalized QR codes from publitest's online survey participation codes.

To generate high quality QR codes in SVG format we use the R package [qrencoder](https://github.com/hrbrmstr/qrencoder) which is based on the C library
libqrencode.

```{r}
#' Export QR codes with personalized survey URL
#'
#' Exports a ZIP file that contains a [QR code](https://en.wikipedia.org/wiki/QR_code) in SVG and in EPS format for each survey participant storing the
#' personalized survey URL to the [private FOKUS directory][print_fokus_private_structure].
#'
#' @inheritParams export_q
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the contents of the created ZIP archive, invisibly.
#' @export
export_qr_codes <- function(ballot_date = ballot_dates,
                            canton = cantons,
                            upload_to_g_drive = TRUE,
                            g_drive_folder = "fokus_aargau/Umfragen/Dateien f\u00fcr publitest/QR-Codes/") {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  checkmate::assert_flag(upload_to_g_drive)
  pal::assert_pkg("archive")
  pal::assert_pkg("qrencoder")
  pal::assert_pkg("rsvg")
  
  participation_codes <- read_online_participation_codes(ballot_date = ballot_date,
                                                         canton = canton)
  tmp_dir <-
    glue::glue("fokus_qr_codes_{ballot_date}_{canton}") %>%
    fs::path_temp() %>%
    fs::dir_create()
  
  on.exit(fs::dir_delete(tmp_dir))
  
  tmp_dir_svg <-
    fs::path(tmp_dir, "svg") %>%
    fs::dir_create()
  
  tmp_dir_eps <-
    fs::path(tmp_dir, "eps") %>%
    fs::dir_create()
  
  # create SVG and EPS image files
  status_msg <- "Generating {length(participation_codes)} personalized QR code{?s} in SVG and EPS format for canton {.val {canton}} @ {.val {ballot_date}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"),
                         .auto_close = FALSE)
  
  participation_codes %>%
    cli::cli_progress_along() %>%
    purrr::walk2(.x = participation_codes,
                 .y = .,
                 .f = ~ {
                   
                   path_svg <- fs::path(tmp_dir_svg, .x,
                                        ext = "svg")
                   
                   # create SVG file
                   qrencoder::qrencode_svg(to_encode = glue::glue("{url_survey_host$aargau}?{url_parameter_survey$aargau}={.x}"),
                                           level = 3) %>%
                     readr::write_file(file = path_svg)
                   
                   # create EPS file from SVG file
                   rsvg::rsvg_eps(svg = path_svg,
                                  file = fs::path(tmp_dir_eps, .x,
                                                  ext = "eps"))
                 })
  
  cli::cli_progress_done()
  
  # create ZIP archive of SVG and EPS files
  status_msg <- "Compressing SVG and EPS QR code files to ZIP archive..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"),
                         .auto_close = FALSE)
  
  dir_output <- fs::dir_create(path_private("output/images/qr_codes"))
  path_zip <- fs::path(dir_output, glue::glue("{ballot_date}_{canton}.zip"))
  
  result <- archive::archive_write_dir(archive = path_zip,
                                       dir = tmp_dir,
                                       format = "zip")
  
  # TODO: remove `cli::cli_process_done()` and increase dep version as soon as archive v1.1.3+ is released
  #       (containing [PR #60](https://github.com/r-lib/archive/pull/60)).
  cli::cli_process_done()
  cli::cli_progress_done()
  
  # upload files to Google Drive for polling agency if requested
  if (upload_to_g_drive) {
    
    upload_to_g_drive(filepaths = path_zip,
                      g_drive_folder = g_drive_folder)
  }
  
  invisible(result)
}
```

### `export_print_recipients`

```{r}
#' Export print recipients data
#'
#' Exports a CSV dataset containing the two variables `id_statistical_office` and `receives_print` to the [private FOKUS
#' directory][print_fokus_private_structure].
#'
#' @inheritParams ballot_types
#'
#' @return `NULL` if no export for the specified ballot date is possible, otherwise a [tibble][tibble::tbl_df] of the exported data, invisibly.
#' @family q_gen
#' @export
export_print_recipients <- function(ballot_date = ballot_dates,
                                    canton = cantons) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  # only export if `reminder_print_*` constraint present
  if (raw_q_suppl_mode(ballot_date = ballot_date,
                       canton = canton) %>%
      purrr::pluck("constraints") %>%
      stringr::str_detect("^reminder_print_.+") %>%
      any()) {
    
    status_msg <- "Exporting print recipients data for canton {.val {canton}} @ {.val {ballot_date}}..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    # read in statistical office IDs used for current survey
    ids_statistical_office <- read_voting_register_ids(ballot_date = ballot_date,
                                                       canton = canton)
    # ensure output folder exists
    fs::dir_create(path_private(glue::glue("output/data/polling_agency/{canton}")))
    
    # export data
    result <-
      read_voting_register_data_extra(ballot_date = ballot_date,
                                      canton = canton) %>%
      dplyr::filter(id_statistical_office %in% !!ids_statistical_office) %>%
      dplyr::mutate(receives_print = year_of_birth_official < 1970L) %>%
      dplyr::select(id_statistical_office, receives_print) %>%
      readr::write_csv(file = path_private(glue::glue("output/data/polling_agency/{canton}/{ballot_date}_print_recipients.csv")))
    
  } else {
    
    cli::cli_alert_info("No print recipients data export sensible or possible for canton {.val {canton}} @ {.val {ballot_date}}.")
    result <- NULL
  }
  
  invisible(result)
}
```

## Variable-related

### `is_skill_question_v`

```{r}
#' Determine whether variable is skill question
#'
#' Determines for each variable whether or not it is a skill question.
#' 
#' Note that the determination is performed by simply parsing `v_names`.
#'
#' @param v_names A character vector of FOKUS variable names.
#'
#' @return A logical vector of the same length as `v_names`.
#' @family variable
#' @export
is_skill_question_v <- function(v_names) {
  
  v_names %>%
    checkmate::assert_character() %>%
    stringr::str_detect(pattern = "^skill_question_\\d+_(cantonal|federal)(_proposal_\\d+)?$")
}
```

### `v_lvls`

```{r}
#' Determine variable's political level(s)
#'
#' Determines a variable's political level(s).
#' 
#' Note that the political levels are determined by simply parsing `v_name`.
#'
#' @param v_name Variable name. A character scalar.
#'
#' @return A character vector of political levels, of length 0 if no specific levels could be determined.
#' @family variable
#' @export
#'
#' @examples
#' fokus::v_lvls("skill_question_1_cantonal_proposal_1")
v_lvls <- function(v_name) {
  
  checkmate::assert_string(v_name,
                           na.ok = TRUE)
  
  is_cantonal <- v_name %>% stringr::str_detect(pattern = "cantonal")
  is_federal <- v_name %>% stringr::str_detect(pattern = "federal")
  
  c("cantonal"[is_cantonal], "federal"[is_federal])
}
```

### `v_proposal_nr`

```{r}
#' Determine variable's proposal number
#'
#' Determines the proposal number each variable corresponds to. In case no proposal number could be determined for a variable, `NA_character` is returned.
#'
#' @inherit is_skill_question_v details
#'
#' @inheritParams is_skill_question_v
#'
#' @return An integer vector of the same length as `v_names`.
#' @family variable
#' @export
v_proposal_nr <- function(v_names) {
  
  v_names %>%
    checkmate::assert_character() %>%
    stringr::str_extract("(?<=_proposal_)\\d+") %>%
    as.integer()
}
```

### `v_skill_question_nr`

```{r}
#' Determine variable's skill question number
#'
#' Determines the skill question number each variable corresponds to. In case no skill question number could be determined for a variable, `NA_character` is
#' returned.
#'
#' @inherit v_proposal_nr details return
#'
#' @inheritParams is_skill_question_v
#'
#' @family variable
#' @export
v_skill_question_nr <- function(v_names) {
  
  v_names %>%
    checkmate::assert_character() %>%
    stringr::str_extract("(?<=skill_question_)\\d+") %>%
    as.integer()
}
```

### Variable name shortening

#### `shorten_v_names`

**Remarks:**

-   To display a comparison between original and shortened column names and their respective lengths after applying `shorten_v_names()`, use:

    ``` r
    fa_data() %>%
      colnames() %>%
      tibble::tibble(original = .,
                     shortened = shorten_v_names(v_names = .,
                                                 max_n_char = NULL)) %>%
      dplyr::mutate(n_char_original = nchar(original),
                    n_char_shortened = nchar(shortened)) %>%
      dplyr::arrange(-n_char_shortened) %>%
      print(n = Inf)
    ```

```{r}
#' Shorten variable names to a maximum length of 32 characters
#'
#' @param v_names A character vector of variable names.
#' @param reverse Whether to apply the inversion of the shortening logic, i.e. to restore original/unshortened variable names.
#' @param max_n_char Maximum allowed number of characters. Either `NULL` to skip the check or otherwise an integer scalar in which case it is ensured that the
#'   maximum resulting variable name length doesn't exceed it. Doesn't have any influence on the applied shortening logic.
#'
#' @return A character vector of the same length as `v_names`.
#' @family variable
#' @seealso [shorten_colnames()], [restore_colnames()]
#' @export
shorten_v_names <- function(v_names,
                            reverse = FALSE,
                            max_n_char = 32L) {
  
  checkmate::assert_character(v_names,
                              any.missing = FALSE)
  checkmate::assert_flag(reverse)
  checkmate::assert_count(max_n_char)
  rules <- shortening_rules

  if (reverse) colnames(rules) %<>% .[c(2L, 1L, 3L)]
  
  rules %<>% dplyr::mutate(pattern =
                             allowed %>%
                             purrr::map_chr(function(allowed) {
                               
                               allowed %>% purrr::when(. %in% c("begin-middle", "begin-middle-end") ~ "(?<=(^|_))",
                                                       . %in% c("middle", "middle-end") ~ "(?<=_)",
                                                       . %in% c("begin", "begin-end") ~ "^",
                                                       ~ "")
                             }) %>%
                             paste0(string) %>%
                             purrr::map2_chr(.x = allowed,
                                             .f = ~ {
                                               
                                               .x %>% purrr::when(. == "begin" ~ .y,
                                                                  . %in% c("begin-middle-end", "middle-end") ~ paste0(.y, "(?=(_|$))"),
                                                                  . %in% c("begin-middle", "middle") ~ paste0(.y, "(?=_)"),
                                                                  . == "begin-end" ~ paste0(.y, "$"),
                                                                  . == "end" ~ paste0("(?<=_)", .y, "$"),
                                                                  ~ cli::cli_abort("This should not happen."))
                                             }))
  
  pattern_replacement <- rules$replacement
  names(pattern_replacement) <- rules$pattern
  
  v_names_new <- v_names %>% stringr::str_replace_all(pattern = pattern_replacement)
  
  # ensure we did our job
  if (!is.null(max_n_char) && !reverse && any(nchar(v_names_new) > max_n_char)) {
    
    # NOTE: `cli::cli_abort()` doesn't properly print the output of `pal::capture_print()` because:
    #        - it just seems to ignore the output if it includes ANSI escape sequences (this can be worked around by an additional `cli::ansi_strip()`)
    #        - it normalizes whitespace chars **incl. tabs** to a single regular whitespace, thus breaking the formatting
    rlang::abort(glue::glue("There are still variable names left of a length greater than {max_n_char} characters after applying `shorten_v_names()`. ",
                            "Affected are the following (shortened) variable names:\n\n",
                            tibble::tibble(v_name = v_names,
                                           v_name_short = v_names_new,
                                           n_char = nchar(v_names),
                                           n_char_short = nchar(v_names_new)) %>%
                              dplyr::filter(n_char_short > max_n_char) %>%
                              pal::capture_print(collapse = "\n"),
                            .null = NA_character_,
                            .trim = FALSE))
  }
  
  v_names_new
}
```

#### `shorten_colnames`

```{r}
#' Shorten column names to a maximum length of 32 characters
#'
#' This is useful for DTA export since Stata has a built-in variable name length limit of [32
#' characters](https://www.stata.com/manuals/r.pdf#rLimits) (see also
#' [here](https://www.statalist.org/forums/forum/general-stata-discussion/general/1452366-number-of-characters-in-variable-names)).
#'
#' @param x `r pkgsnip::param_label("tabular_data")`
#' @inheritParams shorten_v_names
#'
#' @return `x` with column names shortened to a maximum length of 32 characters.
#' @seealso [shorten_v_names()], [restore_colnames()]
#' @export
shorten_colnames <- function(x,
                             max_n_char = 32L) {
  
  x %>% magrittr::set_colnames(value = shorten_v_names(v_names = colnames(x),
                                                       max_n_char = max_n_char))
}
```

#### `restore_colnames`

```{r}
#' Restore original/unshortened column names
#'
#' Applies the inversion of [shorten_colnames()].
#'
#' @inheritParams shorten_colnames
#' @inheritParams shorten_v_names
#'
#' @return `x` with original/unshortened column names restored.
#' @seealso [shorten_v_names()], [shorten_colnames()]
#' @export
restore_colnames <- function(x) {
  
  x %>% magrittr::set_colnames(value = shorten_v_names(v_names = colnames(x),
                                                       reverse = TRUE))
}
```

## Google Apps

TODO: Move these fns to a different pkg!

### `upload_to_g_drive`

```{r}
#' Upload files to Google Drive
#'
#' Uploads one or more files to your Google Drive.
#'
#' @param filepaths Local path(s) to the file(s) to be uploaded.
#' @param g_drive_folder Destination path on Google Drive where the files are to be uploaded to.
#'
#' @return `filepaths`, invisibly.
#' @family g_apps
#' @export
upload_to_g_drive <- function(filepaths,
                              g_drive_folder = "fokus_aargau/") {
  
  checkmate::assert_character(filepaths,
                              any.missing = FALSE)
  checkmate::assert_string(g_drive_folder)
  
  # extract filenames
  filenames <- fs::path_file(filepaths)
  
  # authenticate Google account
  auth_g_drive_gcp()
  
  # upload files
  status_msg <- "Uploading {length(filepaths)} file{?s} to Google Drive folder {.path {g_drive_folder}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  purrr::walk2(.x = filenames,
               .y = filepaths,
               .f = ~ {
                 # overwrite existing file if possible or create new one otherwise
                 googledrive::drive_put(media = .y,
                                        path = g_drive_folder,
                                        name = .x)
               })
  
  invisible(filepaths)
}
```

## Miscellaneous

### `abbreviations`

```{r}
#' Abbreviations used in the **fokus** package
#'
#' Returns a [tibble][tibble::tbl_df] listing an opinionated set of abbreviations used in the \R code and documentation of the **fokus** package.
#'
#' @inheritParams pkgsnip::abbreviations
#'
#' @return `r pkgsnip::param_label("data")`
#' @export
abbreviations <- function(expand = FALSE) {
  
  pal::assert_pkg("pkgsnip")
  
  tibble::tribble(
    ~full_expressions, ~abbreviation,
    "google", "g",
    c("proceed","procedure"), "prcd",
    "procedures", "prcds",
    "questionnaire", "q",
    "questionnaires", "qx",
    "statistik aargau", "sa",
    c("supplemental", "supplementary"), "suppl"
  ) %>%
    dplyr::bind_rows(pkgsnip::abbreviations()) %>%
    dplyr::arrange(dplyr::across()) %>%
    purrr::when(expand ~ tidyr::unnest_longer(data = ., 
                                              col = full_expressions,
                                              values_to = "full_expression"), 
                ~.)
}
```

### `print_fokus_private_structure`

TODO:

-   Think about implementing a fn that returns the dir structure *as structured data*, i.e. a properly nested list of paths or the like. Then this print fn
    could be replaced by a to-text-converter of the new fn.

```{r}
#' Print expected structure of the private FOKUS directory
#'
#' Returns a textual representation of the expected structure of the private FOKUS directory, formatted as a Markdown [fenced code
#' block](https://pandoc.org/MANUAL.html#extension-fenced_code_blocks).
#'
#' @includeRmd data-raw/snippets/fokus_private_description.Rmd
#'
#' @return A character scalar.
#' @export
print_fokus_private_structure <- function() {
  cat(md_snippets$fokus_private_structure)
}
```

### `md_emphasize`

```{r}
#' Emphasize xth element of character vector (Markdown)
#'
#' @param x Input as a character vector.
#' @param which Indices of the elements to be emphasized.
#' @param emph Character sequence used for emphasis.
#'
#' @return A character vector of the same length as `x`.
#' @export
md_emphasize <- function(x,
                         which = TRUE,
                         emph = "**") {
  
  x[which] %<>% paste0(emph, ., emph)
  x
}
```

### `lgl_to_unicode`

```{r}
#' Convert logical vector to Unicode symbols `r unicode_checkmark` and `r unicode_crossmark`
#'
#' @param x A logical vector.
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' fokus::lgl_to_unicode(c(TRUE, TRUE, FALSE, NA))
lgl_to_unicode <- function(x) {
  
  dplyr::if_else(checkmate::assert_logical(x),
                 unicode_checkmark,
                 unicode_crossmark)
}
```

### `prettify_date`

TODO:

-   This fn somehow acts very strangely during questionnaire generation: Although we use `prettify_date(ballot_date, locale = 'de')`, it results in
    `October 18, 2020`, i.e. doesn't even use the proper format string.

-   Investigate if there's a more sophisticated pkg available fulfilling this task (ideally in a system-locale-independent way).

NOTES:

-   Relevant SO question: [What is a reliable way of getting allowed locale names in
    R?](https://stackoverflow.com/questions/20960821/what-is-a-reliable-way-of-getting-allowed-locale-names-in-r)

```{r}
#' Prettify date
#'
#' Note that this might only work on (Ubuntu) Linux in the current form since locales are one bitchy hell of a PITA...
#'
#' @param date Date to be prettified. A [date][base::Date] or something coercible to.
#' @param locale Locale the date should be prettified for. Currently only `"en"`/`"en-US"` and `"de"`/`"de-CH"` are implemented.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' fokus::prettify_date("2021-12-21")
prettify_date <- function(date,
                          locale = c("en", "de", "en-US", "de-CH")) {
  
  locale <- rlang::arg_match(locale)
  
  withr::with_locale(new = c("LC_TIME" = purrr::when(. = locale,
                                                     . %in% c("en", "en-US") ~ "C",
                                                     . %in% c("de", "de-CH") ~ "de_CH.utf8")),
                     code =
                       locale %>%
                       purrr::when(. %in% c("en", "en-US") ~
                                     "%B %d, %Y",
                                   . %in% c("de", "de-CH") ~
                                     "%d. %B %Y",
                                   ~ cli::cli_abort("Specified {.arg locale} not implemented yet.")) %>%
                       format(x = lubridate::as_date(date)))
}
```

### `read_toml`

TODO: Outsource this into separate pkg *tomlr*.

```{r}
#' Read in and parse a TOML file as a strict list
#'
#' Reads in a file in [Tom's Obvious Minimal Language](https://toml.io/) format and returns its content as a (nested) [strict list][xfun::strict_list()].
#'
#' The file is parsed using [`RcppTOML::parseTOML(escape = FALSE)`][RcppTOML::parseTOML].
#'
#' @param path Path to the TOML file. A character scalar.
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @export
read_toml <- function(path) {
  
  pal::assert_pkg("RcppTOML")
  
  path %>%
    purrr::when(length(.) > 0L ~ RcppTOML::parseTOML(input = .,
                                                     escape = FALSE),
                ~ NULL) %>%
    xfun::as_strict_list()
}
```
