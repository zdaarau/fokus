# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/fokus.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# fokus: Provides an API around the FOKUS Post-voting Surveys
# Copyright (C) 2023 Centre for Democracy Studies Aarau (ZDA)
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

.onLoad <- function(libname, pkgname) {
  
  pkgpins::clear_cache(board = pkgpins::board(pkg = pkgname),
                       max_age = getOption(paste0(pkgname, ".global_max_cache_age"),
                                           default = global_max_cache_age))
}

utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "all_of",
                                 "any_of",
                                 "ends_with",
                                 "everything",
                                 "where",
                                 # other
                                 "alignment",
                                 "allowed_at",
                                 "block",
                                 "date_begin",
                                 "date_end",
                                 "drive_resource",
                                 "enumerator",
                                 "enumerator_base",
                                 "full_expressions",
                                 "Geschlecht",
                                 "has_fallback",
                                 "has_same_length",
                                 "Haushaltsgr\u00f6sse Anzahl Personen Total",
                                 "Haushaltsgr\u00f6sse Anzahl Personen \u00fcber 18 Jahren",
                                 "household_size_official",
                                 "i",
                                 "id",
                                 "ID-Nummer",
                                 "is_likely_default",
                                 "j",
                                 "Jahrgang",
                                 "length_response_options",
                                 "length_value_labels",
                                 "length_variable_values",
                                 "lvl",
                                 "marital_status_official",
                                 "matches_length",
                                 "max_age",
                                 "mimeType",
                                 "min_age",
                                 "modifiedTime",
                                 "n_adults_in_household_official",
                                 "n_cantonal_majoritarian_elections",
                                 "n_cantonal_proportional_elections",
                                 "n_cantonal_proposals",
                                 "n_char_short",
                                 "n_federal_majoritarian_elections",
                                 "n_federal_proportional_elections",
                                 "n_federal_proposals",
                                 "n_kids_in_household_official",
                                 "name",
                                 "nr",
                                 "question",
                                 "question_full",
                                 "question_intro_i",
                                 "question_intro_j",
                                 "receives_print",
                                 "response_options",
                                 "sep",
                                 "sex_official",
                                 "string",
                                 "topic",
                                 "value_labels",
                                 "variable_label",
                                 "variable_label_common",
                                 "variable_name",
                                 "variable_values",
                                 "who",
                                 "width",
                                 "year_of_birth_official",
                                 "Zivilstand"))

#' Abbreviations used in the **fokus** package
#'
#' Returns a [tibble][tibble::tbl_df] listing an opinionated set of abbreviations used in the \R code and documentation of the **fokus** package.
#'
#' @inheritParams pkgsnip::abbreviations
#'
#' @return `r pkgsnip::param_label("data")`
#' @keywords internal
abbreviations <- function(expand = FALSE) {
  
  pal::assert_pkg("pkgsnip")
  
  tibble::tibble(full_expressions = list("google"),
                 abbreviation = "g") %>%
    dplyr::bind_rows(pkgsnip::abbreviations()) %>%
    dplyr::arrange(purrr::map_chr(full_expressions,
                                  ~ stringr::str_to_lower(dplyr::first(.x)))) %>%
    pal::when(expand ~ tidyr::unnest_longer(data = .,
                                            col = full_expressions,
                                            values_to = "full_expression"),
              ~ .)
}

#' Convert language code to country-specific locale ID
#'
#' Converts a language code as used in many of this package's functions to a country-specific locale identifier.
#'
#' @param lang Language. One of
#'   - `"de"`
#'   - `"en"`
#'
#' @return A character scalar.
#' @keywords internal
#'
#' @examples
#' fokus:::lang_to_locale("de")
#' fokus:::lang_to_locale("en")
lang_to_locale <- function(lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  switch(lang,
         de = "de-CH",
         en = "en-US")
}

#' Assemble a private FOKUS directory path
#'
#' Assembles a path from the private FOKUS directory root plus any additional path elements supplied.
#'
#' See [print_fokus_private_structure()] for details about the private FOKUS directory.
#'
#' @param ... Filesystem path elements as unnamed vectors.
#'
#' @return `r pkgsnip::param_label("path")`
#' @keywords internal
path_private <- function(...) {
  
  dir_private <- getOption("fokus.path_private",
                           default = getwd())
  
  # ensure `fokus.path_private` is valid (read access plus file `input/data/aargau/survey_data_2018-09-23.xlsx` exists)
  is_dir_private_valid <-
    checkmate::test_directory(dir_private, access = "r") &&
    fs::file_exists(path = fs::path(dir_private, "input/data/aargau/survey_data_2018-09-23.xlsx"))
  
  if (!is_dir_private_valid) {
    
    cli::cli_abort(paste0(ifelse(!is.null(getOption("fokus.path_private")),
                                 "The option {.field fokus.path_private} is set to {.path {dir_private}}.",
                                 "The option {.field fokus.path_private} is unset, thus we fall back to {.path {dir_private}}."),
                          " This doesn't seem to be a valid FOKUS working directory. Please correct this in order for this package to work properly."))
  }
  
  fs::path(dir_private, ...)
}

#' Print expected structure of the private FOKUS directory
#'
#' Returns a textual representation of the expected structure of the private FOKUS directory, formatted as a Markdown [fenced code
#' block](https://pandoc.org/MANUAL.html#extension-fenced_code_blocks).
#'
#' @includeRmd data-raw/snippets/fokus_private_description.Rmd
#'
#' @return A character scalar.
#' @keywords internal
print_fokus_private_structure <- function() {
  
  pal::cat_lines("``` default")
  fokus_private_structure %>% pal::flatten_path_tree() %>% pal::draw_path_tree()
  pal::cat_lines("```",
                 "",
                 "The following placeholders are used in the schema above:",
                 "",
                 "-   `...` for further files and/or folders",
                 "-   `*` for a variable character sequence",
                 "-   `#` for a count starting with `1`",
                 "-   `{canton}` for the name of the FOKUS-covered canton (in lower case), e.g. `aargau`",
                 "-   `{ballot_date}` for the FOKUS-covered ballot date (in the format `YYYY-MM-DD`), e.g. `2018-09-23`",
                 paste0("-   `{date_delivery_statistical_office}` for the delivery date of the voting register data provided by the cantonal statistical ",
                        "office (in the format `YYYY-MM-DD`), e.g. `2019-09-11`"))
}

#' List package-specific options
#'
#' Returns a tibble of R options specific to the FOKUS package.
#'
#' @param pretty_colnames Whether or not to return prose colnames. If `FALSE`, snake-cased colnames safe to use in R expressions are returned.
#'
#' @return `r pkgsnip::param_label("data")`
#' @keywords internal
#'
#' @examples
#' fokus:::opts()
opts <- function(pretty_colnames = FALSE) {
  
  checkmate::assert_flag(pretty_colnames)
  
  if (pretty_colnames) {
    pkg_opts %<>% dplyr::rename("has fallback if unset" = has_fallback)
  }
  
  pkg_opts
}

#' Pretty-print package-specific options
#'
#' Pretty-prints the output of [opts()] as a Markdown [pipe table][pal::pipe_table].
#'
#' @inherit pal::pipe_table return
#' @keywords internal
#'
#' @examples
#' fokus:::print_opts()
print_opts <- function() {
  
  opts(pretty_colnames = TRUE) |>
    dplyr::mutate(name = paste0("`", name, "`"),
                  dplyr::across(all_of("has fallback if unset"),
                                lgl_to_unicode)) |>
    pal::pipe_table()
}

#' Raw FOKUS questionnaire data
#'
#' A structured list of the raw questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @docType data
#' @family qstnr_raw
#' @keywords internal
#' 
#' @name raw_qstnr
NULL

#' Raw supplemental date-specific FOKUS questionnaire data
#'
#' A structured list of raw supplemental date-specific questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @docType data
#' @family qstnr_raw
#' @keywords internal
#' 
#' @name raw_qstnrs_suppl
#'
#' @examples
#' fokus:::raw_qstnrs_suppl[["2018-09-23"]]$mode
NULL

#' Get raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][raw_qstnrs_suppl] for the specified ballot date.
#'
#' @inheritParams cantons
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl(ballot_date = "2018-09-23") %$% mode
raw_qstnr_suppl <- function(ballot_date = all_ballot_dates) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  raw_qstnrs_suppl[[ballot_date]]
}

#' Get a political level's raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][raw_qstnr_suppl] for the specified ballot date and political
#' level.
#'
#' @inheritParams cantons
#' @param lvl Political level. One of
#' `r pal::as_md_val_list(all_lvls)`
#'
#' @inherit raw_qstnr_suppl return seealso
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_lvl(ballot_date = "2018-09-23",
#'                             lvl = "cantonal") |>
#'   names()
raw_qstnr_suppl_lvl <- function(ballot_date = all_ballot_dates,
                                lvl = all_lvls) {
  
  lvl <- rlang::arg_match(lvl)
  
  result <- raw_qstnr_suppl(ballot_date = ballot_date) %>% purrr::pluck(lvl)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    
    cli::cli_abort("No {.val {lvl}} level present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.",
                   .internal = TRUE)
  }
  
  result
}

#' Get a canton's political-level-specific raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data for the specified ballot date and political
#' level][raw_qstnr_suppl_lvl] that applies for the specified canton only.
#'
#' @inheritParams raw_qstnr_suppl_lvl
#' @inheritParams lvls
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_lvl_canton(ballot_date = "2018-09-23",
#'                                    lvl = "cantonal",
#'                                    canton = "aargau") |>
#'   names()
raw_qstnr_suppl_lvl_canton <- function(ballot_date = all_ballot_dates,
                                       lvl = all_lvls,
                                       canton = all_cantons) {
  
  canton <- rlang::arg_match(canton)
  
  result <-
    raw_qstnr_suppl_lvl(ballot_date = ballot_date,
                        lvl = lvl) %>%
    purrr::pluck(canton)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    
    cli::cli_abort("No {.val {lvl}} supplemental {.val {ballot_date}} FOKUS questionnaire data present for canton {.val {canton}}.",
                   .internal = TRUE)
  }
  
  result
}

#' Get raw proposal supplemental questionnaire data
#'
#' Returns a structured list of a proposal's data from the [supplemental date-specific FOKUS questionnaire data][raw_qstnr_suppl].
#'
#' @inheritParams raw_qstnr_suppl_lvl_canton
#' @param proposal_nr Proposal number. A positive integerish scalar.
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_proposal(ballot_date = "2018-09-23",
#'                                  lvl = "cantonal",
#'                                  canton = "aargau",
#'                                  proposal_nr = 1) %$%
#'   name
raw_qstnr_suppl_proposal <- function(ballot_date = all_ballot_dates,
                                     lvl = all_lvls,
                                     canton = all_cantons,
                                     proposal_nr = 1L) {
  
  lvl <- rlang::arg_match(lvl)
  checkmate::assert_count(proposal_nr,
                          positive = TRUE)
  
  proposals <-
    lvl %>%
    pal::when(. == "federal" ~
                raw_qstnr_suppl_lvl(ballot_date = ballot_date,
                                    lvl = .),
              ~ raw_qstnr_suppl_lvl_canton(ballot_date = ballot_date,
                                           lvl = .,
                                           canton = canton)) %>%
    purrr::pluck("proposal")
  
  if (is.null(proposals)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} proposals present",
                          " for {.val {canton}}"[lvl == "cantonal"],
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  proposal <- proposals %>% purrr::pluck(as.character(proposal_nr))
  
  if (is.null(proposal)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} proposal {.val {proposal_nr}} present",
                          " for {.val {canton}}"[lvl == "cantonal"],
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  proposal
}

#' Get a proposal's raw name supplemental questionnaire data
#'
#' Returns a structured list of proposal name data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_qstnr_suppl_proposal].
#'
#' @inheritParams raw_qstnr_suppl_proposal
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_proposal_name(ballot_date = "2018-11-25",
#'                                       lvl = "cantonal",
#'                                       canton = "aargau",
#'                                       proposal_nr = 2)
raw_qstnr_suppl_proposal_name <- function(ballot_date = all_ballot_dates,
                                          lvl = all_lvls,
                                          canton = all_cantons,
                                          proposal_nr = 1L) {
  result <-
    raw_qstnr_suppl_proposal(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr) %>%
    purrr::pluck("name")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No names present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  result
}

#' Get a proposal's raw argument supplemental questionnaire data
#'
#' Returns a structured list of argument data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_qstnr_suppl_proposal].
#'
#' @inheritParams raw_qstnr_suppl_proposal
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_arguments(ballot_date = "2018-11-25",
#'                                   lvl = "cantonal",
#'                                   canton = "aargau",
#'                                   proposal_nr = 2)
raw_qstnr_suppl_arguments <- function(ballot_date = all_ballot_dates,
                                      lvl = all_lvls,
                                      canton = all_cantons,
                                      proposal_nr = 1L) {
  result <-
    raw_qstnr_suppl_proposal(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr) %>%
    purrr::pluck("argument")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No arguments present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  result
}

#' Get a proposal argument's raw supplemental questionnaire data
#'
#' Returns a structured list of a proposal argument's data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_qstnr_suppl_proposal].
#'
#' @inheritParams raw_qstnr_suppl_arguments
#' @inheritParams proposal_argument
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_argument(ballot_date = "2018-11-25",
#'                                  lvl = "cantonal",
#'                                  canton = "aargau",
#'                                  proposal_nr = 2,
#'                                  argument_nr = 2,
#'                                  side = "pro")
raw_qstnr_suppl_argument <- function(ballot_date = all_ballot_dates,
                                     lvl = all_lvls,
                                     canton = all_cantons,
                                     proposal_nr = 1L,
                                     argument_nr = 1L,
                                     side = all_argument_sides) {
  
  checkmate::assert_count(argument_nr,
                          positive = TRUE)
  side <- rlang::arg_match(side)
  
  result <-
    raw_qstnr_suppl_arguments(ballot_date = ballot_date,
                              lvl = lvl,
                              canton = canton,
                              proposal_nr = proposal_nr) %>%
    purrr::keep(~ .x$side %in% side && .x$nr %in% argument_nr) %>%
    dplyr::first()
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {side}} argument {.val {argument_nr}} present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  result
}

#' Get a proposal's raw main motive supplemental questionnaire data
#'
#' Returns a structured list of main motive data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_qstnr_suppl_proposal].
#'
#' @inheritParams raw_qstnr_suppl_proposal
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_main_motives(ballot_date = "2018-11-25",
#'                                      lvl = "cantonal",
#'                                      canton = "aargau",
#'                                      proposal_nr = 2)
raw_qstnr_suppl_main_motives <- function(ballot_date = all_ballot_dates,
                                         lvl = all_lvls,
                                         canton = all_cantons,
                                         proposal_nr = 1L) {
  result <-
    raw_qstnr_suppl_proposal(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr) %>%
    purrr::pluck("main_motive")
  
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No main motives present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  result
}

#' Get raw supplemental election questionnaire data
#'
#' Returns a structured list of election data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_qstnr_suppl_lvl_canton].
#'
#' @inheritParams raw_qstnr_suppl_lvl_canton
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_elections(ballot_date = "2019-10-20",
#'                                   lvl = "cantonal",
#'                                   canton = "aargau") %$%
#'   skill_questions_source
raw_qstnr_suppl_elections <- function(ballot_date = all_ballot_dates,
                                      lvl = all_lvls,
                                      canton = all_cantons) {
  result <-
    raw_qstnr_suppl_lvl_canton(ballot_date = ballot_date,
                               lvl = lvl,
                               canton = canton) %>%
    purrr::pluck("election")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort("No {.val {lvl}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.",
                   .internal = TRUE)
  }
  
  result
}

#' Get an election's raw supplemental questionnaire data
#'
#' Returns a structured list of an election's data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_qstnr_suppl_lvl_canton].
#'
#' @inheritParams raw_qstnr_suppl_lvl_canton
#' @inheritParams election_name
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_election(ballot_date = "2019-10-20",
#'                                  lvl = "cantonal",
#'                                  canton = "aargau",
#'                                  prcd = "majoritarian") %$%
#'   n_seats
raw_qstnr_suppl_election <- function(ballot_date = all_ballot_dates,
                                     lvl = all_lvls,
                                     canton = all_cantons,
                                     prcd = all_prcds,
                                     election_nr = 1L) {
  
  prcd <- rlang::arg_match(prcd)
  checkmate::assert_count(election_nr,
                          positive = TRUE)
  
  result <-
    raw_qstnr_suppl_elections(ballot_date = ballot_date,
                              lvl = lvl,
                              canton = canton) %>%
    purrr::pluck(prcd)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS ",
                          "questionnaire data."),
                   .internal = TRUE)
  }
  
  result %<>% purrr::pluck(as.character(election_nr))
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} election {.val {election_nr}} for canton {.val {canton}} present in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  result
}

#' Get raw supplemental election name questionnaire data
#'
#' Returns a structured list of an election's name data from the [political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_qstnr_suppl_lvl].
#'
#' @inheritParams raw_qstnr_suppl_election
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_election_name(ballot_date = "2019-10-20",
#'                                       lvl = "cantonal",
#'                                       canton = "aargau",
#'                                       prcd = "majoritarian")
raw_qstnr_suppl_election_name <- function(ballot_date = all_ballot_dates,
                                          lvl = all_lvls,
                                          canton = all_cantons,
                                          prcd = all_prcds,
                                          election_nr = 1L) {
  lvl <- rlang::arg_match(lvl)
  prcd <- rlang::arg_match(prcd)
  checkmate::assert_count(election_nr,
                          positive = TRUE)
  
  # federal proportional election names are defined once for all cantons together
  if (lvl == "federal" && prcd == "proportional") {
    
    result <-
      raw_qstnr_suppl_lvl(ballot_date = ballot_date,
                          lvl = lvl) %>%
      purrr::chuck("election", prcd, as.character(election_nr))
    
  } else {
    
    result <- raw_qstnr_suppl_election(ballot_date = ballot_date,
                                       lvl = lvl,
                                       canton = canton,
                                       prcd = prcd,
                                       election_nr = election_nr)
  }
  
  result %<>% purrr::pluck("name")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No names present for {.val {lvl}} {.val {prcd}} election {.val {election_nr}} in canton {.val {canton}} in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  result
}

#' Get raw supplemental survey mode questionnaire data
#'
#' Returns a structured list of survey mode data from the [raw supplemental date-specific FOKUS questionnaire data][raw_qstnr_suppl].
#'
#' @inheritParams raw_qstnr_suppl_lvl_canton
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_mode(ballot_date = "2018-09-23",
#'                              canton = "aargau")
raw_qstnr_suppl_mode <- function(ballot_date = all_ballot_dates,
                                 canton = all_cantons) {
  
  canton <- rlang::arg_match(canton)
  
  result <-
    raw_qstnr_suppl(ballot_date = ballot_date) %>%
    purrr::pluck("mode", canton)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    
    cli::cli_abort("No survey mode data present for canton {.val {canton}} in supplemental {.val {ballot_date}} FOKUS questionnaire data.",
                   .internal = TRUE)
  }
  
  result
}

#' Get raw supplemental skill question questionnaire data
#'
#' Returns a structured list of skill question data from the [raw supplemental date-specific FOKUS questionnaire data][raw_qstnr_suppl].
#'
#' @inheritParams raw_qstnr_suppl_proposal
#' @param proposal_nr Proposal number. A positive integerish scalar or `NULL`. If `NULL`, non-proposal-specific skill question data is returned.
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_skill_questions(ballot_date = "2018-09-23",
#'                                         lvl = "cantonal",
#'                                         canton = "aargau",
#'                                         proposal_nr = 1) |>
#'   purrr::map_depth(1L, "de") |>
#'   purrr::list_c(ptype = character())
raw_qstnr_suppl_skill_questions <- function(ballot_date = all_ballot_dates,
                                            lvl = all_lvls,
                                            canton = all_cantons,
                                            proposal_nr = NULL) {
  lvl <- rlang::arg_match(lvl)
  result <-
    lvl %>%
    pal::when(
      
      # federal non-proposal-specific skill questions (e.g. at federal elections)
      length(proposal_nr) == 0L && . == "federal" ~
        raw_qstnr_suppl_lvl(ballot_date = ballot_date,
                            lvl = .),
      # cantonal non-proposal-specific skill questions (e.g. at cantonal elections)
      length(proposal_nr) == 0L && . == "cantonal" ~
        raw_qstnr_suppl_lvl_canton(ballot_date = ballot_date,
                                   lvl = .,
                                   canton = canton),
      # federal or cantonal proposal-specific skill questions
      ~ raw_qstnr_suppl_proposal(ballot_date = ballot_date,
                                 lvl = .,
                                 canton = canton,
                                 proposal_nr = proposal_nr)) %>%
    purrr::pluck("skill_question")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No skill questions present",
                          ifelse(length(proposal_nr) == 0L,
                                 paste0(" on the {.val {lvl}} level",
                                        " for {.val {canton}}"[lvl == "cantonal"]),
                                 " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."),
                   .internal = TRUE)
  }
  
  result
}

#' Get a single skill question's raw supplemental questionnaire data
#'
#' Returns a structured list of a single skill question's data from the [raw supplemental date-specific FOKUS questionnaire data][raw_qstnr_suppl].
#'
#' @inheritParams raw_qstnr_suppl_lvl_canton
#' @inheritParams skill_question
#'
#' @inherit raw_qstnr_suppl return
#' @family qstnr_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qstnr_suppl_skill_question(ballot_date = "2018-09-23",
#'                                        lvl = "cantonal",
#'                                        canton = "aargau",
#'                                        proposal_nr = 1,
#'                                        skill_question_nr = 1)
raw_qstnr_suppl_skill_question <- function(ballot_date = all_ballot_dates,
                                           lvl = all_lvls,
                                           canton = all_cantons,
                                           proposal_nr = NULL,
                                           skill_question_nr = 1L) {
  
  checkmate::assert_count(skill_question_nr,
                          positive = TRUE)
  result <-
    raw_qstnr_suppl_skill_questions(ballot_date = ballot_date,
                                    lvl = lvl,
                                    canton = canton,
                                    proposal_nr = proposal_nr) %>%
    purrr::pluck(skill_question_nr)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No skill question {.val {skill_question_nr}} present",
                          ifelse(length(proposal_nr) == 0L,
                                 paste0(" on the {.val {lvl}} level", " for {.val {canton}}"[lvl == "cantonal"]),
                                 " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data. Only {length(skill_questions)} skill questions included."),
                   .internal = TRUE)
  }
  
  result
}

#' Pick right raw questionnaire value
#'
#' Picks the right value of a certain raw questionnaire key based on ballot date and canton (recursively).
#'
#' @inheritParams raw_qstnr_suppl_lvl_canton
#' @param x Questionnaire key. A list object.
#' @param key Questionnaire key name, used to determine the correct default value fallback. A character scalar or `NULL`. If `NULL`, no fallback is used (and an
#'   error is thrown in case none of the subkeys matches).
#'
#' @return Value of `x` that corresponds to `canton` and `ballot_date`.
#' @family qstnr_raw
#' @keywords internal
raw_pick_right <- function(x,
                           key = NULL,
                           ballot_date,
                           canton) {
  
  # force evaluation of `ballot_date`, `canton` and `key` to ensure immediate error (with better msg) in case they are missing
  ballot_date
  canton
  key
  
  if (purrr::pluck_depth(x) > 1L) {
    
    x <-
      pick_right_helper(x = x,
                        key = key,
                        ballot_date = ballot_date,
                        canton = canton) %>%
      raw_pick_right(key = key,
                     ballot_date = ballot_date,
                     canton = canton)
  }
  
  x
}

pick_right_helper <- function(x,
                              ballot_date,
                              canton,
                              key) {
  
  if (purrr::is_list(x) && (length(x) > 1L || purrr::pluck_depth(x) > 1L)) {
    
    # create plain ballot date as in subkeys
    ballot_date_squeezed <- stringr::str_remove_all(string = ballot_date,
                                                    pattern = "-")
    # convert ballot date to type date
    ballot_date %<>% lubridate::as_date()
    
    # handle begin-end date subkeys
    begin_end_subkeys <-
      names(x) %>%
      stringr::str_subset(pattern = "^\\d+_\\d+$")
    
    matches_begin_end_subkeys <-
      begin_end_subkeys %>%
      purrr::map_lgl(function(x) {
        
        begin <- x %>% stringr::str_extract(pattern = "^\\d+") %>% lubridate::as_date()
        end <- x %>% stringr::str_extract(pattern = "\\d+$") %>% lubridate::as_date()
        
        begin <= ballot_date && ballot_date <= end
      })
    
    # integrity check: ensure there aren't any overlapping intervals
    if (length(which(matches_begin_end_subkeys)) > 1L) {
      
      cli::cli_abort(c("Illegal overlapping interval subkeys found: {.var {begin_end_subkeys[matches_begin_end_subkeys]}}",
                       ">" = "Please fix this and run again."),
                     .internal = TRUE)
    }
    
    ballot_types <- ballot_types(ballot_date = ballot_date,
                                 canton = canton)
    
    x <- names(x) %>% pal::when(
      
      # canton and ballot date
      ## consider overrides for binary keys
      canton %in% x[["false"]] || ballot_date %in% x[["false"]] ~ FALSE,
      canton %in% x[["true"]] || ballot_date %in% x[["true"]] ~ TRUE,
      
      ## consider overrides for non-binary keys
      ### single canton subkey
      canton %in% . ~ x[[canton]],
      ### single date subkey
      ballot_date_squeezed %in% . ~ x[[ballot_date_squeezed]],
      ### begin-end date subkey
      length(which(matches_begin_end_subkeys)) > 0L ~ x[[begin_end_subkeys[matches_begin_end_subkeys]]],
      
      # consider overrides for ballot types (we take the first one in case of ambiguity)
      any(ballot_types %in% .) ~ x[[intersect(., ballot_types)[1L]]],
      
      # return default value if defined
      "default" %in% . ~ x[["default"]],
      
      # fall back on key's default value if no subkey matches canton and ballot date
      key %in% qstnr_item_keys$key ~ unlist(qstnr_item_keys$default_val[qstnr_item_keys$key == key]),
      
      # abort in any remaining case
      ~ cli::cli_abort("Undefined behavior, please debug. {.arg {key}} is {.val {key}}, {.arg {x}} is {.field {x}}.",
                       .internal = TRUE)
    )
  }
  
  x
}

init_heritable_map <- function(block) {
  
  xfun::strict_list(lvl = "?",
                    i = NA_integer_,
                    j = NA_integer_,
                    block = block,
                    variable_name = "???",
                    topic = NULL,
                    who = "alle",
                    question_intro_i = NULL,
                    question_intro_j = NULL,
                    question = NULL,
                    question_full = NULL,
                    question_common = NULL,
                    allow_multiple_answers = FALSE,
                    variable_label = "???",
                    variable_label_common = NULL,
                    response_options = NULL,
                    variable_values = NULL,
                    value_labels = NULL,
                    value_scale = "nominal",
                    randomize_response_options = FALSE,
                    is_mandatory = FALSE,
                    ballot_types = all_ballot_types,
                    include = TRUE)
}

resolve_qstnr_val <- function(x,
                              ballot_date,
                              canton,
                              key,
                              lvl,
                              i,
                              j,
                              ...) {
  
  checkmate::assert_string(lvl,
                           null.ok = TRUE)
  checkmate::assert_count(i,
                          na.ok = TRUE,
                          null.ok = TRUE)
  checkmate::assert_count(j,
                          na.ok = TRUE,
                          null.ok = TRUE)
  
  x %>%
    raw_pick_right(key = key,
                   ballot_date = ballot_date,
                   canton = canton) %>%
    pal::when(is.character(.) ~ interpolate_qstnr_val(.,
                                                      ballot_date = ballot_date,
                                                      canton = canton,
                                                      key = key,
                                                      lvl = lvl,
                                                      i = i,
                                                      j = j,
                                                      ... = ...),
              ~ .) %>%
    # convert to proper type
    pal::when(
      key %in% qstnr_item_keys$key[qstnr_item_keys$type == "character"] ~
        as.character(.),
      key %in% qstnr_item_keys$key[qstnr_item_keys$type == "logical"] ~
        as.logical(.),
      key %in% qstnr_item_keys$key[qstnr_item_keys$type == "integer"] ~
        as.integer(.),
      key %in% qstnr_item_keys$key[qstnr_item_keys$type == "double"] ~
        as.double(.),
      # undefined behaviour
      ~ cli::cli_abort("Undefined behaviour in {.fun resolve_qstnr_val}. Please debug.",
                       .internal = TRUE)
    )
}

interpolate_qstnr_val <- function(x,
                                  ballot_date,
                                  canton,
                                  key,
                                  lvl,
                                  i,
                                  j,
                                  ...) {
  
  # assign objects in dots to current env ensuring glue/cli fns respect them
  rlang::env_bind(.env = rlang::current_env(),
                  ...)
  
  if (key %in% qstnr_item_keys$key[qstnr_item_keys$is_scalar]) {
    
    result <- cli::pluralize(x,
                             .null = NA_character_,
                             .trim = FALSE)
  } else {
    
    result <-
      x %>%
      purrr::map(.f = glue::glue,
                 .envir = rlang::current_env(),
                 .null = NA_character_,
                 .trim = FALSE) %>%
      unlist()
  }
  
  result
}

#' Generate questionnaire tibble
#'
#' @inheritParams ballot_title
#' @param verbose Whether or not to print detailed progress information during questionnaire generation. Note that it will take considerably more time when this
#'   is set to `TRUE`.
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @keywords internal
gen_qstnr_tibble <- function(ballot_date = all_ballot_dates,
                             canton = cantons(ballot_date),
                             verbose = FALSE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  canton <- rlang::arg_match(canton,
                             values = cantons(ballot_date))
  checkmate::assert_flag(verbose)
  
  cli::start_app(theme = cli_theme)
  status_msg <- "Generating questionnaire tibble for canton {.val {canton}} @ {.val {ballot_date}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  purrr::map2_dfr(.x = raw_qstnr,
                  .y = names(raw_qstnr),
                  .f = ~ {
                    
                    if (verbose && !(.y %in% qstnr_non_item_lvls)) cli::cli_h1("BLOCK: {.val {.y}}")
                    
                    assemble_qstnr_tibble(ballot_date = ballot_date,
                                          canton = canton,
                                          raw_qstnr_branch = .x,
                                          qstnr_lvl = .y,
                                          heritable_map = init_heritable_map(block = .y),
                                          verbose = verbose)
                  }) %>%
    # add ballot date and canton
    dplyr::mutate(ballot_date = !!ballot_date,
                  canton = !!canton,
                  .before = 1L)
}

assemble_qstnr_tibble <- function(ballot_date,
                                  canton,
                                  raw_qstnr_branch,
                                  qstnr_lvl,
                                  heritable_map,
                                  verbose) {
  
  if (verbose && stringr::str_detect(qstnr_lvl, "\\..+\\.item$")) {
    cli::cli_h2("BRANCH PATH: {.val {stringr::str_remove(qstnr_lvl, '\\\\.item$')}}")
  }
  
  map <- heritable_map
  
  # only complement with non-table-array qstnr lvls (would be completely wrong to complement with the `item` table arrays, which are also *unnamed* lists)
  if (rlang::is_named(raw_qstnr_branch)) {
    
    map %<>%
      purrr::list_modify(!!!raw_qstnr_branch) %>%
      purrr::keep_at(at = qstnr_item_keys$key)
  }
  
  result <- NULL
  
  if ("variable_name" %in% names(raw_qstnr_branch)) {
    
    result <- assemble_qstnr_item_tibble(ballot_date = ballot_date,
                                         canton = canton,
                                         item_map = map,
                                         verbose = verbose)
    
  } else if (purrr::pluck_depth(raw_qstnr_branch) > 2L) {
    
    result <- purrr::map2_dfr(.x = raw_qstnr_branch,
                              .y = names(raw_qstnr_branch) %||% seq_along(raw_qstnr_branch),
                              .f = ~ assemble_qstnr_tibble(ballot_date = ballot_date,
                                                           canton = canton,
                                                           raw_qstnr_branch = .x,
                                                           qstnr_lvl = paste(qstnr_lvl, .y,
                                                                             sep = "."),
                                                           heritable_map = map,
                                                           verbose = verbose))
  }
  
  result
}

assemble_qstnr_item_tibble <- function(ballot_date,
                                       canton,
                                       item_map,
                                       verbose) {
  # iterate over `lvl`...
  resolve_qstnr_val(x = item_map$lvl,
                    ballot_date = ballot_date,
                    canton = canton,
                    key = "lvl",
                    lvl = "",
                    i = NA_integer_,
                    j = NA_integer_) %>%
    purrr::map(
      .f = function(lvl) {
        # ...`i`...
        resolve_qstnr_val(x = item_map$i,
                          ballot_date = ballot_date,
                          canton = canton,
                          key = "i",
                          lvl = lvl,
                          i = NA_integer_,
                          j = NA_integer_) %>%
          purrr::map(
            lvl = lvl,
            .f = function(i,
                          lvl) {
              # ...and `j`
              resolve_qstnr_val(x = item_map$j,
                                ballot_date = ballot_date,
                                canton = canton,
                                key = "j",
                                lvl = lvl,
                                i = i,
                                j = NA_integer_) %>%
                purrr::map(
                  i = i,
                  lvl = lvl,
                  .f = function(j,
                                i,
                                lvl) {
                    
                    # respect keys `include` and `ballot_types`
                    is_incl <- resolve_qstnr_val(x = item_map$include,
                                                 ballot_date = ballot_date,
                                                 canton = canton,
                                                 key = "include",
                                                 lvl = lvl,
                                                 i = i,
                                                 j = j)
                    has_ballot_type <-
                      resolve_qstnr_val(x = item_map$ballot_types,
                                        ballot_date = ballot_date,
                                        canton = canton,
                                        key = "ballot_types",
                                        lvl = lvl,
                                        i = i,
                                        j = j) %>%
                      intersect(ballot_types(ballot_date = ballot_date,
                                             canton = canton)) %>%
                      rlang::is_empty() %>%
                      magrittr::not()
                    
                    result <- NULL
                    
                    if (is_incl && has_ballot_type) {
                      
                      if (verbose) cli::cli_h3("ITEM: {.var {item_map$variable_name}}")
                      
                      # resolve all keys in item map
                      result <-
                        names(item_map) %>%
                        setdiff(c("lvl",
                                  "i",
                                  "j",
                                  "ballot_types",
                                  "include")) %>%
                        magrittr::set_names(x = .,
                                            value = .) %>%
                        purrr::map(~ {
                          
                          if (verbose) cli::cli_progress_step("KEY: {.field {.x}}")
                          
                          # pre-resolve `question` for dependent `question_full` resolution
                          if (.x == "question_full") {
                            question <- resolve_qstnr_val(x = item_map[["question"]],
                                                          ballot_date = ballot_date,
                                                          canton = canton,
                                                          key = "question",
                                                          lvl = lvl,
                                                          i = i,
                                                          j = j)
                          } else {
                            question <- NA_character_
                          }
                          
                          resolve_qstnr_val(x = item_map[[.x]],
                                            ballot_date = ballot_date,
                                            canton = canton,
                                            key = .x,
                                            lvl = lvl,
                                            i = i,
                                            j = j,
                                            question = question) %>%
                            pal::when(
                              # replace empty scalars with NA
                              length(.) == 0L && .x %in% qstnr_item_keys$key[qstnr_item_keys$is_scalar] ~
                                .[NA],
                              # wrap vectors in list
                              .x %in% qstnr_item_keys$key[!qstnr_item_keys$is_scalar] ~
                                list(.),
                              ~ .
                            )
                        }) %>%
                        # add iterators
                        c(lvl = lvl,
                          i = i,
                          j = j)
                      
                      # handle special cases
                      ## 1: fill empty non-iterator multi-value keys with NA(s) if all other non-empty multi-value keys have the same length
                      lengths_multi_val_keys <-
                        qstnr_item_keys_multival %>%
                        magrittr::set_names(., .) %>%
                        purrr::map_int(~ length(result[[.x]][[1L]]))
                      
                      positive_lengths_multi_val_keys <-
                        lengths_multi_val_keys %>%
                        magrittr::extract(. > 0L)
                      
                      if (any(lengths_multi_val_keys == 0L) && length(unique(positive_lengths_multi_val_keys)) == 1L) {
                        
                        for (k in (lengths_multi_val_keys %>%
                                   magrittr::extract(. == 0L) %>%
                                   names())) {
                          
                          result[[k]] <- list(rep(result[[k]][[1L]][NA],
                                                  times = length(result[[names(positive_lengths_multi_val_keys)[1L]]][[1L]])))
                        }
                      }
                      
                      ## 2: if no `question_common` is defined, fall back on
                      ##    a) `question_full.default`
                      ##    b) `question.default`
                      ##    c) `question_full`
                      ##    if either exists and actually differs from `question`
                      if (is.null(result$question_common)) {
                        
                        question_common_fallback <-
                          item_map %>%
                          pal::when("default" %in% names(.$question_full) ~
                                      resolve_qstnr_val(x = item_map$question_full$default,
                                                        ballot_date = ballot_date,
                                                        canton = canton,
                                                        key = "question_full",
                                                        lvl = lvl,
                                                        i = i,
                                                        j = j),
                                    "default" %in% names(.$question) ~
                                      resolve_qstnr_val(x = item_map$question$default,
                                                        ballot_date = ballot_date,
                                                        canton = canton,
                                                        key = "question",
                                                        lvl = lvl,
                                                        i = i,
                                                        j = j),
                                    ~ result$question_full)
                        
                        if (isTRUE(question_common_fallback != result$question)) {
                          result$question_common <- question_common_fallback
                        }
                      }
                      
                      ## 3: if no `variable_label_common` is defined, fall back on `variable_label.default` if it exists and actually differs from
                      ##    variable_label`
                      if (is.null(result$variable_label_common) && "default" %in% names(item_map$variable_label)) {
                        
                        default_variable_label <- resolve_qstnr_val(x = item_map$variable_label$default,
                                                                    ballot_date = ballot_date,
                                                                    canton = canton,
                                                                    key = "variable_label",
                                                                    lvl = lvl,
                                                                    i = i,
                                                                    j = j)
                        
                        if (isTRUE(default_variable_label != result$variable_label)) {
                          result$variable_label_common <- default_variable_label
                        }
                      }
                      
                      ## 4: add `who`-constraint to `variable_label` and `variable_label_common`
                      ### get English `who` value
                      who_en <-
                        raw_qstnr$who %>%
                        purrr::detect(~ .x$value$de == stringr::str_replace(string = result$who,
                                                                            pattern = "\\d+",
                                                                            replacement = "{i}")) %>%
                        purrr::chuck("value", "en") %>%
                        cli::pluralize(.null = NA_character_,
                                       .trim = FALSE)
                      
                      ### add who-constraints
                      if (!is.null(result$variable_label_common)
                          && !is.na(result$variable_label_common)
                          && !has_who_constraint(result$variable_label_common)) {
                        
                        # ensure `who` doesn't vary over time
                        if (length(item_map$who) > 1L) {
                          cli::cli_abort(paste0("{.field who} of variable {.var {result$variable_name}} has changed over time. Thus an explicit {.field who}-",
                                                "constraint has to be specified at the end of {.field variable_label_common} in the raw ",
                                                "{.file questionnaire.toml}."),
                                         .internal = TRUE)
                        }
                        result$variable_label_common %<>% add_who_constraint(who = who_en)
                      }
                      result$variable_label %<>% add_who_constraint(who = who_en)
                    }
                    
                    # convert result to tibble
                    tibble::as_tibble(result)
                  }) %>%
                purrr::list_rbind()
            }) %>%
          purrr::list_rbind()
      }) %>%
    purrr::list_rbind()
}

#' Expand questionnaire tibble to long format
#'
#' Expands a [questionnaire tibble][gen_qstnr_tibble] to [long format](https://en.wikipedia.org/wiki/Wide_and_narrow_data).
#'
#' @param qstnr_tibble Questionnaire tibble as returned by [gen_qstnr_tibble()].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_gen
#' @keywords internal
expand_qstnr_tibble <- function(qstnr_tibble) {
  
  # run integrity checks...
  validate_qstnr_tibble(qstnr_tibble) %>%
    # ...expand questionnaire data to long format...
    tidyr::unnest(cols = any_of(qstnr_item_keys_multival))
}

clean_qstnr_tibble <- function(qstnr_tibble) {
  
  qstnr_tibble %>%
    # remove (single) placeholders
    dplyr::mutate(dplyr::across(any_of(qstnr_item_keys_multival) & where(~ is.character(.x[[1L]])),
                                ~ purrr::map(.x,
                                             ~ {
                                               if (length(.x) == 1L && isTRUE(stringr::str_detect(.x, "^_.+_$"))) {
                                                 character()
                                               } else {
                                                 .x
                                               }
                                             }))) %>%
    # strip MD
    dplyr::mutate(dplyr::across(where(is.character),
                                pal::strip_md),
                  dplyr::across(where(is.list) & where(~ is.character(.x[[1L]])),
                                ~ purrr::map(.x,
                                             pal::strip_md)))
}

validate_qstnr_tibble <- function(qstnr_tibble) {
  
  # integrity check 1: ensure there are no duplicated topics, variable names and variable labels
  c("topic",
    "variable_name",
    "variable_label") %>%
    purrr::walk(.f = function(var) {
      
      is_dup <- duplicated(qstnr_tibble[[var]])
      
      if (any(is_dup)) {
        
        dup_indices <- which(is_dup)
        
        for (i in dup_indices) {
          
          dup_var <- qstnr_tibble[[var]][i]
          
          cli::cli_alert_warning(paste0("{.var {var}} {.val {dup_var}} is included more than once in the questionnaire."))
        }
      }
    })
  
  # integrity check 2: ensure all multi-value columns have the same length or alternatively are empty, and if not, tell which ones don't
  multi_val_var_lengths <-
    qstnr_tibble %>%
    dplyr::mutate(dplyr::across(where(is.list),
                                ~ purrr::map_int(.x,
                                                 length)),
                  .keep = "none") %>%
    dplyr::rename_with(~ paste0("length_", .x)) %>%
    dplyr::mutate(matches_length = length_variable_values == 0L | length_value_labels == 0L | length_variable_values == length_value_labels) %>%
    dplyr::mutate(matches_length =
                    matches_length & (length_response_options == 0L | length_value_labels == 0L | length_response_options == length_value_labels),
                  matches_length =
                    matches_length & (length_response_options == 0L | length_variable_values == 0L | length_response_options == length_variable_values))
  
  i_violated <- which(!multi_val_var_lengths$matches_length)
  
  if (length(i_violated)) {
    
    multi_val_var_names <-
      qstnr_tibble %>%
      dplyr::select(where(is.list)) %>%
      colnames()
    
    # print affected variable names first since long error msg gets truncated
    cli::cli({
      cli::cli_alert_danger("Affected variable names:")
      cli::cli_ul(items = qstnr_tibble$variable_name[i_violated])
    })
    
    bullets <-
      qstnr_tibble$variable_name[i_violated] %>%
      purrr::map_chr(~ glue::glue("{{.var {.x}}}")) %>%
      rlang::set_names("*")
    
    cli::cli_abort(c("The number of {.var {multi_val_var_names}} differs for the following variable names:",
                     bullets),
                   .internal = TRUE)
  }
  
  invisible(qstnr_tibble)
}

has_who_constraint <- function(x) {
  
  isTRUE(stringr::str_detect(string = x,
                             pattern = "(\\(|; )(\\d{4}-\\d{2}-\\d{2} )?only [^\\)]+\\)$"))
}

add_who_constraint <- function(x,
                               who) {
  if (who != "all") {
    
    result <- who %>% pal::when(endsWith(x, ")") ~ stringr::str_replace(string = x,
                                                                        pattern = "\\)$",
                                                                        replacement = paste0("; only *", ., "*)")),
                                ~ paste0(x, " (only *", ., "*)"))
  } else {
    
    result <- x
  }
  
  result
}

#' Generate Markdown questionnaire
#'
#' @inheritParams raw_qstnr_suppl_lvl_canton
#' @param incl_title Whether or not to generate an `<h1>` questionnaire title at the beginning of the document. If the result is intended to be fed to Pandoc,
#'   it's recommended to set this to `FALSE` and provide the title via [Pandoc's `--metadata` option](https://pandoc.org/MANUAL.html#option--metadata) instead.
#'
#' @return A character vector.
#' @family qstnr_gen
#' @keywords internal
gen_qstnr_md <- function(qstnr_tibble,
                         incl_title = FALSE) {
  
  # ensure we have a single ballot date and canton
  ballot_date <-
    qstnr_tibble %$%
    ballot_date %>%
    unique() %>%
    checkmate::assert_string(.var.name = "ballot_date")
  canton <-
    qstnr_tibble %$%
    canton %>%
    unique() %>%
    checkmate::assert_string(.var.name = "canton")
  
  status_msg <- "Generating Markdown questionnaire for canton {.val {canton}} @ {.val {ballot_date}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  block_lines <-
    qstnr_tibble %>%
    # add block title and across-block item enumerator base/group
    dplyr::mutate(enumerator_base =
                    block %>%
                    purrr::map_int(~ raw_qstnr %>% purrr::pluck(.x, "prefix",
                                                                .default = 0L))) %>%
    # add across-block item enumerator
    dplyr::group_by(enumerator_base) %>%
    dplyr::group_modify(~ tibble::rowid_to_column(.x,
                                                  var = "enumerator")) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(enumerator = enumerator_base + enumerator) %>%
    dplyr::arrange(block, enumerator) %>%
    # iterate over every block and generate block header plus table
    dplyr::group_by(block) %>%
    dplyr::group_map(~ {
      
      block <- .y$block
      block_nr <- block_name_to_nr(block)
      block_title <- raw_qstnr %>% purrr::chuck(block, "title")
      block_intro <-
        raw_qstnr %>%
        purrr::pluck(block, "intro") %>%
        raw_pick_right(key = "intro",
                       ballot_date = ballot_date,
                       canton = canton) %>%
        cli::pluralize(.trim = FALSE)
      
      c(glue::glue("## Block {block_nr}: {block_title}",
                   .null = NA_character_),
        "",
        block_intro,
        ""[length(block_intro)],
        qstnr_md_table_header,
        qstnr_md_table_body(qstnr_tibble_block = .x,
                            block = block),
        "",
        "")
    }) %>%
    purrr::list_c(ptype = character())
  
  # add title, technical notes, introduction, footnotes and link references
  title <- glue::glue("# FOKUS-{ stringr::str_to_sentence(canton) }-Fragebogen f\u00fcr den ",
                      ballot_title(ballot_date = ballot_date,
                                   canton = canton),
                      "\n",
                      .trim = FALSE)
  
  technical_notes <-
    raw_qstnr %$%
    who %>%
    # reduce to who's that actually occur in data
    purrr::keep(~ .x %>%
                  purrr::chuck("value", "de") %>%
                  glue::glue(i = glue::glue(.x$i),
                             j = glue::glue(.x$j)) %>%
                  magrittr::extract(.x %>%
                                      purrr::pluck("ballot_types",
                                                   .default = all_ballot_types) %>%
                                      intersect(ballot_types(ballot_date = ballot_date,
                                                             canton = canton)) %>%
                                      length() %>%
                                      magrittr::is_greater_than(0L)) %>%
                  pal::when(length(.) == 0L ~ FALSE,
                            ~ stringr::str_detect(string = qstnr_tibble$who,
                                                  pattern = pal::fuse_regex(paste0("\\Q", ., "\\E")))) %>%
                  any()) %>%
    # assemble who lines
    purrr::map_depth(.depth = 1L,
                     .f = function(who_map) {
                       
                       i <- resolve_qstnr_val(x = who_map$i %||% 1L,
                                              ballot_date = ballot_date,
                                              canton = canton,
                                              key = "i",
                                              lvl = "",
                                              i = NA_integer_,
                                              j = NA_integer_)
                       
                       j <- resolve_qstnr_val(x = who_map$j %||% 1L,
                                              ballot_date = ballot_date,
                                              canton = canton,
                                              key = "j",
                                              lvl = "",
                                              i = NA_integer_,
                                              j = NA_integer_)
                       value <-
                         i %>%
                         purrr::map(function(i) {
                           j %>%
                             purrr::map_chr(i = i,
                                            .f = function(i, j) {
                                              
                                              who_map$value$de %>%
                                                glue::glue(.null = NA_character_,
                                                           .trim = FALSE) %>%
                                                md_emphasize()
                                            })
                         }) %>%
                         purrr::list_c(ptype = character())
                       
                       description <-
                         i %>%
                         purrr::map(function(i) {
                           j %>%
                             purrr::map_chr(i = i,
                                            .f = function(i, j) {
                                              
                                              who_map$description$de %>%
                                                glue::glue(.null = NA_character_,
                                                           .trim = FALSE)
                                            })
                         }) %>%
                         purrr::list_c(ptype = character())
                       
                       glue::glue("- {value}: {description}")
                     }) %>%
    purrr::list_c(ptype = character()) %>%
    c("## Technische Vorbemerkungen",
      "",
      "### `Wer`",
      "",
      "Die Spalte `Wer` dient dem Fragebogen-Routing. Sie kennt folgende Werte:",
      "",
      .,
      "",
      md_snippets$qstnr_technical_notes_multiple_responses,
      md_snippets$qstnr_technical_notes_free_text_fields)
  
  footnotes <-
    raw_qstnr$footnote %>%
    # reduce to footnotes that actually occur in table body
    purrr::keep(~ any(stringr::str_detect(block_lines, glue::glue("\\[\\^{.x$id}\\]",
                                                                  .null = NA_character_)))) %>%
    purrr::map(~ c(glue::glue("[^{.x$id}]: ", glue::glue(.x$text,
                                                         .null = NA_character_,
                                                         .trim = FALSE),
                              .null = NA_character_,
                              .trim = FALSE),
                   "")) %>%
    purrr::list_c(ptype = character())
  
  link_refs <-
    raw_qstnr$link %>%
    # reduce to link references that actually occur in table body
    purrr::keep(~ any(stringr::str_detect(block_lines, glue::glue("\\[[^]]+\\]\\[{.x$id}\\]",
                                                                  .null = NA_character_)))) %>%
    purrr::map(~ c(glue::glue("[{.x$id}]: {.x$url}",
                              .null = NA_character_),
                   "")) %>%
    purrr::list_c(ptype = character())
  
  c(title[incl_title],
    technical_notes,
    md_snippets$qstnr_introduction,
    block_lines,
    footnotes,
    link_refs)
}

qstnr_md_table_body <- function(qstnr_tibble_block,
                                block) {
  
  qstnr_tibble_block %>%
    # replace logicals by German ja/nein
    dplyr::mutate(dplyr::across(where(is.logical),
                                ~ ifelse(.x,
                                         "ja",
                                         "nein"))) %>%
    purrr::pmap_chr(function(ballot_date,
                             canton,
                             enumerator,
                             variable_name,
                             topic,
                             who,
                             question_intro_i,
                             question_intro_j,
                             question,
                             allow_multiple_answers,
                             variable_label,
                             response_options,
                             variable_values,
                             value_labels,
                             randomize_response_options,
                             is_mandatory,
                             i,
                             j,
                             ...) {
      paste(enumerator,
            tidyr::replace_na(topic,
                              "-"),
            who,
            question %>% pal::when(is.na(.) ~ "-",
                                   ~ c(c(question_intro_i[isTRUE(i == 1L && j %in% c(1L, NA_integer_))],
                                         question_intro_j[isTRUE(j == 1L)]) %>%
                                         magrittr::extract(!is.na(.)) %>%
                                         pal::as_string(),
                                       .) %>%
                                     magrittr::extract(!is.na(.)) %>%
                                     pal::as_string(sep = " <br><br>")),
            allow_multiple_answers,
            pal::wrap_chr(variable_name,
                          wrap = "`"),
            shorten_var_names(var_names = variable_name,
                              max_n_char = ifelse(block %in% c("x_polling_agency", "y_generated", "z_generated")
                                                  || stringr::str_detect(string = variable_name,
                                                                         pattern = paste0("^", pal::fuse_regex(c("agreement_contra_argument_",
                                                                                                                 "information_source_",
                                                                                                                 "reason_non_participation_",
                                                                                                                 "political_occasions_")))),
                                                  32L,
                                                  30L)) %>%
              pal::wrap_chr("`"),
            variable_label,
            response_options %>%
              pal::when(is_skill_question_var(variable_name) ~
                          format_md_multival_col(x = .,
                                                 collapse_break = FALSE) %>%
                          md_emphasize(which = skill_question_answer_nr(ballot_date = ballot_date,
                                                                        lvl = var_lvls(var_name = variable_name),
                                                                        canton = canton,
                                                                        proposal_nr =
                                                                          var_proposal_nr(variable_name) %>%
                                                                          pal::when(is.na(.) ~ NULL,
                                                                                    ~ .),
                                                                        skill_question_nr = var_skill_question_nr(variable_name))) %>%
                          collapse_break(),
                        ~ format_md_multival_col(.)),
            format_md_multival_col(variable_values),
            format_md_multival_col(value_labels),
            randomize_response_options,
            is_mandatory,
            sep = " | ")
    })
}

format_md_multival_col <- function(x,
                                   collapse_break = TRUE) {
  
  result <- x
  
  if (all(is.na(x))) {
    
    result <- "-"
    
  } else if (length(x) > 1L
             && all(stringr::str_detect(string = x,
                                        pattern = "^_.+_$",
                                        negate = TRUE),
                    na.rm = TRUE)) {
    
    result <-
      x %>%
      pal::wrap_chr(wrap = "`") %>%
      pal::when(collapse_break ~ collapse_break(.),
                ~ .)
  }
  
  result
}

block_name_to_nr <- function(x) {
  
  x %>%
    stringr::str_extract("^.[^_]?(_\\d)?") %>%
    stringr::str_replace("_(\\d)", "-\\1") %>%
    stringr::str_remove("^0") %>%
    stringr::str_to_upper()
}

#' Extract questionnaire item field value
#'
#' Extracts a single questionnaire item field value for every first- for every second-level iterator from the [raw FOKUS questionnaire data][raw_qstnr] based on
#' the specified variable name and branch path.
#'
#' When used in questionnaire item field values via [string interpolation][glue::glue], be careful to not create infinite loops via circular references.
#'
#' @inheritParams ballot_title
#' @param var_name Variable name, without resolved string interpolation, i.e. 1:1 as stated in the raw FOKUS questionnaire data. A character scalar.
#' @param branch_path Sequence of questionnaire table levels that lead to the `item` leaf node where `var_name` is defined. A character vector.
#' @param key Questionnaire item key. One of
#' `r pal::as_md_val_list(qstnr_item_keys$key)`
#' @param lvl Political-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. A character vector.
#' @param i Second-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. An integerish vector.
#' @param j Third-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. An integerish vector.
#'
#' @return A vector of the resolved item field values. Type and length of resolved values depend on `key`.
#' @family qstnr_internal
#' @keywords internal
#'
#' @examples
#' fokus:::qstnr_item_val(ballot_date = "2018-09-23",
#'                        canton = "aargau",
#'                        branch_path = c("03_proposal_specific", "004_participants"),
#'                        var_name = "appeal_federal_proposals",
#'                        key = "include")
#'
#' fokus:::qstnr_item_val(
#'   ballot_date = "2019-10-20",
#'   canton = "aargau",
#'   branch_path = c("02_political_start", "002_non_participation",
#'                   "003_election", "z01_hypothetical"),
#'   var_name = "hypothetical_voting_decision_federal_majoritarian_election_{i}_seat_{j}",
#'   key = "topic",
#'   i = 1:2,
#'   j = 1:3
#' )
qstnr_item_val <- function(ballot_date = all_ballot_dates,
                           canton = cantons(ballot_date),
                           branch_path,
                           var_name,
                           key = qstnr_item_keys$key,
                           lvl = "?",
                           i = NA_integer_,
                           j = NA_integer_) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  canton <- rlang::arg_match(canton,
                             values = all_cantons)
  checkmate::assert_character(branch_path,
                              any.missing = FALSE,
                              min.len = 1L)
  if ("item" %in% branch_path) {
    cli::cli_abort("{.arg branch_path} must be specified {.emph without} the {.val item} leaf node.")
  }
  checkmate::assert_string(var_name)
  key <- rlang::arg_match(key)
  
  item_map <-
    raw_qstnr %>%
    purrr::chuck(!!!branch_path, "item") %>%
    purrr::keep(.p = ~ isTRUE(.x$variable_name == var_name)) %>%
    purrr::list_flatten()
  
  if (!rlang::has_name(x = item_map, name = "variable_name")) {
    cli::cli_abort(paste0("There is no item with {.arg variable_name} {.val {var_name}} defined under the questionnaire branch path {.field ",
                          pal::prose_ls(x = branch_path,
                                        sep = " -> ",
                                        last_sep = " -> "),
                          "}."))
  }
  
  # traverse questionnaire branch path and complement heritable map
  parent_map <- init_heritable_map(block = branch_path[1L])
  
  for (branch_depth in purrr::accumulate(branch_path, c)) {
    
    parent_map <-
      raw_qstnr %>%
      purrr::chuck(!!!branch_depth) %>%
      purrr::list_modify(.x = parent_map,
                         !!!.) %>%
      purrr::keep_at(at = qstnr_item_keys$key)
  }
  
  # evaluate requested item value
  raw_val <-
    parent_map %>%
    purrr::list_modify(!!!item_map) %>%
    purrr::chuck(key)
  
  lvl %>%
    purrr::map(function(lvl) {
      i %>%
        purrr::map(lvl = lvl,
                   .f = function(i,
                                 lvl) {
                     j %>%
                       purrr::map(i = i,
                                  lvl = lvl,
                                  .f = function(j,
                                                i,
                                                lvl) {
                                    
                                    resolve_qstnr_val(x = raw_val,
                                                      ballot_date = ballot_date,
                                                      canton = canton,
                                                      key = key,
                                                      lvl = lvl,
                                                      i = i,
                                                      j = j)
                                  })
                   })
    }) %>%
    unlist()
}

#' Get political parties
#'
#' Returns a tibble of ballot-date-specific political party metadata defined in the [raw FOKUS questionnaire data][raw_qstnr].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family qstnr_internal
#' @keywords internal
qstnr_parties <- function(ballot_date = all_ballot_dates) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  ballot_date %<>% lubridate::as_date()
  
  raw_qstnr %>%
    purrr::chuck("party") %>%
    purrr::map(~ {
      tibble::tibble_row(code = .x$code,
                         de.long = .x$de$long,
                         de.short = .x$de$short,
                         en.short = .x$en$short %||% .x$de$short,
                         date_begin = .x$date_begin %||% lubridate::as_date("1970-01-01"),
                         date_end = .x$date_end %||% lubridate::as_date("2099-12-31"))
    }) %>%
    purrr::list_rbind() %>%
    dplyr::filter(date_begin <= ballot_date & date_end >= ballot_date)
}

#' Get response option codes
#'
#' Extracts response option codes of the specified type(s) from the [raw FOKUS questionnaire data][raw_qstnr].
#'
#' Note that only codes of recurring response options are returned which are defined under the `response_options` top-level key in the file
#' `data-raw/questionnaire/questionnaire.toml`.
#'
#' @param types Response option types. One or more of
#' `r pal::as_md_val_list(all_response_option_types)`
#'
#' @return An integer vector.
#' @family qstnr_internal
#' @keywords internal
#'
#' @examples
#' fokus:::qstnr_response_option_codes(types = "abstain")
#'
#' fokus:::qstnr_response_option_codes(types = c("dunno",
#'                                               "custom",
#'                                               "abstain"))
qstnr_response_option_codes <- function(types = all_response_option_types) {
  
  types <- unique(checkmate::assert_subset(types,
                                           choices = all_response_option_types,
                                           empty.ok = FALSE))
  
  types %>% purrr::map_int(~ raw_qstnr %>% purrr::chuck("response_options", .x, "code"))
}

#' Determine questionnaire data's value label column
#'
#' Determines the [questionnaire data][qstnrs] column that holds variable value labels, returned as a [symbol][as.symbol].
#'
#' The questionnaire data column that holds variable value labels is language-dependent. While the column
#' `r qstnr_lbl_col_sym("de") %>% as.character() %>% pal::wrap_chr("\x60")` holds the German value labels, their English counterpars are found in the column
#' `r qstnr_lbl_col_sym("en") %>% as.character() %>% pal::wrap_chr("\x60")`. `qstnr_lbl_col_sym()` is intended to ease language-agnostic questionnaire data
#' programming.
#'
#' @inheritParams proposal_name
#'
#' @return `r pkgsnip::return_label("symbol")`
#' @family qstnr_predicate
#' @keywords internal
#'
#' @examples
#' fokus:::qstnr_lbl_col_sym(lang = "de")
#' 
#' fokus:::qstnr_lbl_col_sym(lang = "en")
qstnr_lbl_col_sym <- function(lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  as.symbol(ifelse(lang == "de",
                   "response_options",
                   "value_labels"))
}

#' Read in easyvote municipality data
#'
#' Reads in the latest dataset of easyvote municipality information provided to us not earlier than 90 days before and up until 20 days after the `ballot_date`.
#'
#' If both columns `min_age` and `max_age` are `NA` in the data returned, it means that
#'
#' -   the municipality did not provide easyvote with specific information on the target age range, and
#' -   the municipality has subscribed to parcel mailing (instead of direct delivery to households) and delivers the brochures itself -- very likely to young
#'     adults between 18--25 years.
#'
#' @inheritParams raw_qstnr_suppl_lvl_canton
#'
#' @return `r pkgsnip::param_label("data")`
#' @keywords internal
#'
#' @examples
#' # private FOKUS directory needs to be accessible for this function to work
#' try(
#'   fokus:::read_easyvote_municipalities(ballot_date = "2020-09-27",
#'                                        canton = "aargau")
#' )
read_easyvote_municipalities <- function(ballot_date,
                                         canton) {
  
  # get date of latest dataset delivered *not earlier than 90 days before ballot date* and *up until 20 days after ballot date*
  date_boundary_lower <- lubridate::as_date(ballot_date) - 90L
  date_boundary_upper <- lubridate::as_date(ballot_date) + 20L
  
  date_data <-
    path_private("input/data", canton) %>%
    fs::dir_ls(type = "file",
               regexp = "easyvote_municipalities_\\d{4}-\\d{2}-\\d{2}\\.csv$") %>%
    stringr::str_extract("\\d{4}-\\d{2}-\\d{2}(?=\\.csv$)") %>%
    lubridate::as_date() %>%
    magrittr::extract(. >= date_boundary_lower & . <= date_boundary_upper)
  
  if (length(date_data)) {
    date_data %<>% max()
  } else {
    cli::cli_abort(paste0("No easyvote municipality data present for canton {.val {canton}} with effective date at minimum 90 days before and at maximum 20 ",
                          "days after the ballot date {.val {ballot_date}}."))
  }
  
  path_private("input/data", canton, glue::glue("easyvote_municipalities_{date_data}.csv")) %>%
    readr::read_csv(col_types = "ciii")
}

read_online_participation_codes <- function(ballot_date,
                                            canton) {
  
  path_input <- path_private(glue::glue("input/data/{canton}/online_participation_codes_{ballot_date}.txt"))
  
  if (!fs::file_exists(path_input)) {
    cli::cli_abort("No online participation codes present for canton {.val {canton}} @ {.val {ballot_date}}.")
  }
  
  readr::read_lines(file = path_input,
                    skip_empty_rows = TRUE)
}

read_voting_register_data_extra <- function(ballot_date,
                                            canton) {
  pal::assert_pkg("readxl")
  
  # get date of latest dataset delivered *before* ballot date
  date_data <-
    path_private("input/data", canton) %>%
    fs::dir_ls(type = "file",
               regexp = "voting_register_data_extra_\\d{4}-\\d{2}-\\d{2}\\.xlsx$") %>%
    stringr::str_extract("\\d{4}-\\d{2}-\\d{2}(?=\\.xlsx$)") %>%
    lubridate::as_date() %>%
    magrittr::extract(. < lubridate::as_date(ballot_date))
  
  if (length(date_data)) {
    date_data %<>% max()
  } else {
    cli::cli_abort("No voting register data present for canton {.val {canton}} with effective date before the ballot on {.val {ballot_date}}.")
  }
  
  data <-
    path_private(glue::glue("input/data/{canton}/voting_register_data_extra_{date_data}.xlsx")) %>%
    readxl::read_xlsx(col_types = "text") %>%
    # rename variables to our scheme
    dplyr::rename(id = `ID-Nummer`,
                  sex_official = Geschlecht,
                  year_of_birth_official = Jahrgang,
                  marital_status_official = Zivilstand,
                  household_size_official = "Haushaltsgr\u00f6sse Anzahl Personen Total",
                  n_adults_in_household_official = "Haushaltsgr\u00f6sse Anzahl Personen \u00fcber 18 Jahren",
                  n_kids_in_household_official = "Haushaltsgr\u00f6sse Anzahl Personen unter 18 Jahren") %>%
    # convert numeric columns to type integer
    dplyr::mutate(dplyr::across(c(id,
                                  year_of_birth_official,
                                  household_size_official,
                                  n_adults_in_household_official,
                                  n_kids_in_household_official),
                                as.integer)) %>%
    # transform variable values to our scheme
    dplyr::mutate(dplyr::across(c(sex_official, marital_status_official),
                                stringr::str_to_lower)) %>%
    dplyr::mutate(marital_status_official = dplyr::case_match(.x = marital_status_official,
                                                              "eingetragene partnerschaft"    ~ "in eingetragener Partnerschaft",
                                                              "aufgel\u00f6ste partnerschaft" ~ "aufgel\u00f6ste Partnerschaft",
                                                              "unverheiratet"                 ~ "ledig",
                                                              .default = marital_status_official))
  
  # integrity check 1: ensure no unexpected columns occur
  if (ncol(data) > 7L) {
    
    unknown_colnames <-
      colnames(data) %>%
      setdiff(c(id,
                sex_official,
                year_of_birth_official,
                marital_status_official,
                household_size_official,
                n_adults_in_household_official,
                n_kids_in_household_official))
    
    cli::cli_abort("Unexpected column(s) detected in {.file input/data/{canton}/voting_register_data_extra_{date_data}.xlsx}: {.val unknown_colnames}",
                   .internal = TRUE)
  }
  
  # TODO!
  # # integrity check 2: ensure no unexpected values occur
  # ## in `sex_official`
  # unknown_sex_official_i <-
  #   data$sex_official %>%
  #   magrittr::is_in(fa_fct_labels(var_name = "sex_official",
  #                                 check_var_presence = FALSE,
  #                                 lang = "de")) %>%
  #   magrittr::not() %>%
  #   which()
  #
  # if (length(unknown_sex_official_i)) {
  #   
  #   rlang::abort(message = style_error(paste0(
  #     style_var_name("sex_official"), " in raw extra voting register data has unknown values: ",
  #     data$sex_official[unknown_sex_official_i] %>%
  #       unique() %>%
  #       style_arg_invalid() %>%
  #       list_pretty(lang = "en")
  #   )))
  # }
  # ## in `marital_status_official`
  # unknown_marital_status_official_i <-
  #   data$marital_status_official %>%
  #   magrittr::is_in(fa_fct_labels(var_name = "marital_status_official",
  #                                 check_var_presence = FALSE,
  #                                 lang = "de")) %>%
  #   magrittr::not() %>%
  #   which()
  #
  # if (length(unknown_marital_status_official_i)) {
  #   
  #   rlang::abort(message = style_error(paste0(
  #     style_var_name("marital_status_official"), " in raw extra voting register data has unknown values: ",
  #     data$sex_official[unknown_marital_status_official_i] %>%
  #       unique() %>%
  #       style_arg_invalid() %>%
  #       list_pretty(lang = "en")
  #   )))
  # }
  
  data
}

read_voting_register_ids <- function(ballot_date,
                                     canton) {
  
  path_input <- path_private(glue::glue("input/data/{canton}/voting_register_ids_{ballot_date}.csv"))
  
  if (!fs::file_exists(path_input)) {
    cli::cli_abort("No voting register ID data present for canton {.val {canton}} @ {.val {ballot_date}}.")
  }
  
  path_input %>%
    readr::read_csv(col_types = "i") %>%
    # integrity check
    pal::when(ncol(.) > 1L ~
                cli::cli_abort("More than one column present in {.file input/data/{canton}/voting_register_ids_{ballot_date}.csv}. Please debug.",
                               .internal = TRUE),
              ~ .) %>%
    dplyr::first()
}

assert_countish <- function(x,
                            positive = TRUE,
                            null_ok = FALSE) {
  
  if (null_ok && is.null(x)) {
    x
    
  } else {
    checkmate::assert_count(as.integer(x),
                            positive = positive)
  }
}

assert_integerish <- function(x,
                              lower = -Inf,
                              upper = Inf,
                              any_missing = FALSE,
                              all_missing = FALSE,
                              null_ok = FALSE) {
  
  if (null_ok && is.null(x)) {
    x
    
  } else {
    checkmate::assert_integerish(as.integer(x),
                                 lower = lower,
                                 upper = upper,
                                 any.missing = any_missing,
                                 all.missing = all_missing,
                                 coerce = TRUE)
  }
}

assert_var_names <- function(var_names,
                             as_scalar = FALSE,
                             null_ok = FALSE) {
  
  checkmate::assert_flag(as_scalar)
  
  if (as_scalar) {
    
    checkmate::assert_choice(var_names,
                             choices = unique(fokus::qstnrs$variable_name),
                             null.ok = null_ok)
    
  } else {
    
    purrr::map_chr(var_names,
                   checkmate::assert_choice,
                   choices = unique(fokus::qstnrs$variable_name),
                   null.ok = null_ok)
  }
}

as_flat_list <- function(x) {
  
  result <- x
  depth <- purrr::pluck_depth(result)
  
  # unlist until only a single list level remains
  while (depth > 2L) {
    
    result %<>% unlist(recursive = FALSE)
    depth <- purrr::pluck_depth(result)
  }
  
  # wrap in list if necessary
  if (depth < 2L && !is.list(x)) {
    
    result <- list(x)
  }
  
  result
}

collapse_break <- function(s) {
  
  paste0(s, collapse = "<br>")
}

wrap_backtick <- function(x) {
  
  dplyr::if_else(x == "-" | stringr::str_detect(string = x,
                                                pattern = "^(_.*_|\\*.*\\*)$"),
                 as.character(x),
                 paste0("`", x, "`"))
}

this_pkg <- utils::packageName()

cli_theme <-
  cli::builtin_theme() %>%
  purrr::list_modify(h2 = list("margin-bottom" = 0.0),
                     h3 = list("margin-top" = 0.0))

global_max_cache_age <- "30 days"

pkg_opts <-
  tibble::tibble(name = "fokus.path_repo_private",
                 description = paste0("path to the working directory (the local instance of the ",
                                      "[`fokus_private` repository](https://gitlab.com/zdaarau/private/fokus_private)); defaults to the current working ",
                                      "directory"),
                 has_fallback = TRUE) |>
  tibble::add_row(name = "fokus.global_max_cache_age",
                  description = glue::glue("default maximum cache age for all functions taking a `max_cache_age` argument; defaults to ",
                                           global_max_cache_age),
                  has_fallback = TRUE)

#' Questionnaire item keys
#'
#' A tibble of item keys supported in the [raw FOKUS questionnaire data][raw_qstnr].
#'
#' @format `r pkgsnip::return_label("data")`
#' @docType data
#' @family metadata
#' @keywords internal
#' 
#' @name qstnr_item_keys
#' 
#' @examples
#' fokus:::qstnr_item_keys
NULL

qstnr_md_table_header <-
  tibble::tribble(
    ~name,                                         ~width, ~alignment,
    "\\#",                                         2L,     "left",
    "Thema",                                       5L,     "left",
    "Wer",                                         3L,     "left",
    "Frage",                                       15L,    "left",
    "Mehrfachnennungen",                           3L,     "left",
    "Variablenname",                               5L,     "left",
    "Variablenname (gek\u00fcrzt auf 32 Zeichen)", 5L,     "left",
    "Variablenlabel",                              15L,    "left",
    "Antwortoptionen",                             5L,     "left",
    "Variablenauspr\u00e4gungen",                  5L,     "left",
    "Auspr\u00e4gungslabels",                      5L,     "left",
    "Antwortoptionen in Zufallsreihenfolge",       3L,     "left",
    "Antwort obligatorisch",                       3L,     "left"
  ) %>%
  dplyr::mutate(sep = purrr::map2_chr(.x = width,
                                      .y = alignment,
                                      .f = ~
                                        rep(x = "-",
                                            times = .x) %>%
                                        paste0(collapse = "") %>%
                                        pal::when(.y == "left" ~ stringr::str_replace(string = .,
                                                                                      pattern = "^.",
                                                                                      replacement = ":"),
                                                  .y == "right" ~ stringr::str_replace(string = .,
                                                                                       pattern = ".$",
                                                                                       replacement = ":"),
                                                  .y == "center" ~ stringr::str_replace_all(string = .,
                                                                                            pattern = "(^.|.$)",
                                                                                            replacement = ":"),
                                                  ~ .))) %$%
  c(paste0(name, collapse = " | "),
    paste0(sep, collapse = " | "))

unicode_checkmark <- "\u2705"
unicode_crossmark <- "\u274C"
unicode_ellipsis  <- "\u2026"

url_survey_host <- list(aargau = "https://umfrage.fokus.ag")
url_parameter_survey <- list(aargau = "pw")

#' FOKUS-covered ballot dates
#'
#' A vector of ballot dates covered by FOKUS surveys up until `r max(all_ballot_dates)`.
#'
#' @format `r pkgsnip::return_label("dates")`
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_ballot_dates
"all_ballot_dates"

#' FOKUS-covered cantons
#'
#' A vector of all [cantons][cantons] covered by FOKUS surveys.
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_cantons
"all_cantons"

#' Ballot types
#'
#' A vector of all possible [ballot types][ballot_types].
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_ballot_types
"all_ballot_types"

#' Political levels
#'
#' A vector of all possible [political levels][lvls].
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_lvls
"all_lvls"

#' Election procedures
#'
#' A vector of all possible [election procedures][prcds].
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_prcds
"all_prcds"

#' Referendum proposal types
#'
#' A vector of all possible [referendum proposal types][proposal_type].
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_proposal_types
"all_proposal_types"

#' Referendum proposal argument sides
#'
#' A vector of all possible referendum proposal argument sides.
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_argument_sides
"all_argument_sides"

#' Response option types
#'
#' A vector of all possible response option types defined in the [raw FOKUS questionnaire data][raw_qstnr].
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_response_option_types
"all_response_option_types"

#' Postal dispatch types
#'
#' A vector of all possible postal dispatch types.
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_postal_dispatch_types
"all_postal_dispatch_types"

#' Postal dispatch ways
#'
#' A vector of all possible [postal dispatch ways][postal_dispatch_way].
#'
#' @format A character vector.
#' @family metadata
#' @export
#'
#' @examples
#' fokus::all_postal_dispatch_ways
"all_postal_dispatch_ways"

#' Get cantons covered by FOKUS survey
#'
#' Determines the cantons covered by the FOKUS survey at the specified ballot date.
#'
#' @param ballot_date FOKUS-covered ballot date. One of
#' `r pal::as_md_val_list(as.character(all_ballot_dates))`
#'
#' @return A character vector.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::cantons(ballot_date = "2018-09-23")
#'
#' # determine all cantons covered per ballot date
#' library(magrittr)
#' 
#' fokus::all_ballot_dates %>%
#'   magrittr::set_names(., .) %>%
#'   purrr::map_chr(fokus::cantons)
cantons <- function(ballot_date = all_ballot_dates) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  cantons_at[[ballot_date]]
}

#' Get ballot's political levels
#'
#' Determines the [political levels][all_lvls] covered by the FOKUS survey for the specified canton of the specified ballot type at the specified ballot date.
#'
#' @inheritParams cantons
#' @param canton Canton name. One of
#' `r pal::as_md_val_list(all_cantons)`
#' @param ballot_type Ballot type. One of
#' `r pal::as_md_val_list(all_ballot_types)`
#'
#' @return A character vector.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::lvls(ballot_date = "2018-09-23",
#'             canton = "aargau")
#'
#' fokus::lvls(ballot_date = "2018-09-23",
#'             canton = "aargau",
#'             ballot_type = "election")
lvls <- function(ballot_date = all_ballot_dates,
                 canton = cantons(ballot_date),
                 ballot_type = ballot_types(ballot_date = ballot_date,
                                            canton = canton)) {
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  canton <- rlang::arg_match(canton,
                             values = all_cantons)
  ballot_type <- rlang::arg_match(ballot_type,
                                  values = all_ballot_types)
  raw <- raw_qstnr_suppl(ballot_date = ballot_date)
  
  if (ballot_type == "referendum") {
    
    result <- c("cantonal"[length(raw$cantonal[[canton]]$proposal) > 0L],
                "federal"[length(raw$federal$proposal) > 0L])
  } else {
    
    result <- c("cantonal"[any(purrr::map_lgl(all_prcds,
                                              ~ length(raw$cantonal[[canton]]$election[[.x]]) > 0L))],
                "federal"[any(purrr::map_lgl(all_prcds,
                                             ~ length(raw$federal[[canton]]$election[[.x]]) > 0L))])
  }
  
  result
}

#' Get ballot types
#'
#' Determines the [types of the ballot][all_ballot_types] covered by the FOKUS survey for the specified canton on the specified political level(s) at the
#' specified ballot date.
#'
#' @inheritParams lvls
#' @param lvls Political level(s). One or more of
#' `r pal::as_md_val_list(all_lvls)`
#'
#' @return A character vector.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::ballot_types(ballot_date = "2018-09-23",
#'                     canton = "aargau")
#'
#' # in case of no ballot types at lvl, an empty character vector is returned
#' fokus::ballot_types(ballot_date = "2020-10-18",
#'                     lvls = "federal",
#'                     canton = "aargau")
ballot_types <- function(ballot_date = all_ballot_dates,
                         lvls = all_lvls,
                         canton = cantons(ballot_date)) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = all_lvls,
                                          empty.ok = FALSE))
  canton <- rlang::arg_match(canton,
                             values = all_cantons)
  result <- NULL
  raw <- raw_qstnr_suppl(ballot_date = ballot_date)
  
  if ("federal" %in% lvls) {
    
    result <- c("referendum"[length(raw$federal$proposal) > 0L],
                "election"[any(purrr::map_lgl(all_prcds,
                                              ~ length(raw$federal[[canton]]$election[[.x]]) > 0L))])
  }
  
  if ("cantonal" %in% lvls) {
    
    result %<>% c("referendum"[length(raw$cantonal[[canton]]$proposal) > 0L],
                  "election"[any(purrr::map_lgl(all_prcds,
                                                ~ length(raw$cantonal[[canton]]$election[[.x]]) > 0L))])
  }
  
  unique(result)
}

#' Get ballot's election procedures
#'
#' Determines the [election procedures][all_prcds] covered by the FOKUS survey for the specified canton on the specified political level at the specified ballot
#' date.
#'
#' @inheritParams lvls
#' @param lvl Political level. One of
#' `r pal::as_md_val_list(all_lvls)`
#'
#' @return A character vector.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::prcds(ballot_date = "2019-10-20",
#'              lvl = "cantonal",
#'              canton = "aargau")
#'              
#' fokus::prcds(ballot_date = "2019-10-20",
#'              lvl = "federal",
#'              canton = "aargau")
#'
#' # in case of no elections, an empty character vector is returned
#' fokus::prcds(ballot_date = "2020-10-18",
#'              lvl = "federal",
#'              canton = "aargau")
prcds <- function(ballot_date = all_ballot_dates,
                  lvl = lvls(ballot_date,
                             canton,
                             ballot_type = "election"),
                  canton = cantons(ballot_date)) {
  
  if (length(lvl)) {
    lvl <- rlang::arg_match(lvl,
                            values = all_lvls)
  }
  canton <- rlang::arg_match(canton,
                             values = all_cantons)
  result <- character()
  raw <- raw_qstnr_suppl(ballot_date = ballot_date)
  
  if (isTRUE(lvl == "federal")) {
    
    result <-
      names(raw$federal[[canton]]$election) %>%
      intersect(all_prcds) %>%
      as.character()
    
  } else if (isTRUE(lvl == "cantonal")) {
    
    result <-
      names(raw$cantonal[[canton]]$election) %>%
      intersect(all_prcds) %>%
      as.character()
  }
  
  result
}

#' Get ballot's referendum proposal numbers
#'
#' Determines the referendum proposal numbers covered by the FOKUS survey for the specified canton at the specified ballot date on the specified political
#' level.
#'
#' @inheritParams prcds
#' @param canton Canton name. One of
#' `r pal::as_md_val_list(all_cantons)`
#' 
#' Only relevant if `lvl = "cantonal"`.
#'
#' @return An integer vector.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::proposal_nrs(ballot_date = "2018-09-23",
#'                     lvl = "cantonal",
#'                     canton = "aargau")
#'                     
#' fokus::proposal_nrs(ballot_date = "2018-09-23",
#'                     lvl = "federal",
#'                     canton = "aargau")
#'
#' # in case of no referendum proposals, an empty integer vector is returned
#' fokus::proposal_nrs(ballot_date = "2019-10-20",
#'                     lvl = "cantonal",
#'                     canton = "aargau")
proposal_nrs <- function(ballot_date = all_ballot_dates,
                         lvl = lvls(ballot_date,
                                    canton,
                                    ballot_type = "referendum"),
                         canton = cantons(ballot_date)) {
  if (length(lvl)) {
    lvl <- rlang::arg_match(lvl,
                            values = all_lvls)
  }
  
  result <- integer()
  raw <- raw_qstnr_suppl(ballot_date = ballot_date)
  
  if (isTRUE(lvl == "federal")) {
    
    result <-
      raw$federal$proposal %>%
      names() %>%
      as.integer()
    
  } else if (isTRUE(lvl == "cantonal")) {
    
    canton <- rlang::arg_match(canton,
                               values = all_cantons)
    result <-
      raw$cantonal[[canton]]$proposal %>%
      names() %>%
      as.integer()
  }
  
  result
}

#' Get ballot's election numbers
#'
#' Determines the election numbers covered by the FOKUS survey for the specified canton at the specified ballot date on the specified political level(s) and of
#' the specified election procedure(s).
#'
#' @inheritParams prcds
#' @param prcd Election procedure. One of
#' `r pal::as_md_val_list(all_prcds)`
#'
#' @return An integer vector.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::election_nrs(ballot_date = "2019-10-20",
#'                     lvl = "federal",
#'                     canton = "aargau",
#'                     prcd = "majoritarian")
#'
#' # in case of no (matching) elections, an empty integer vector is returned
#' fokus::election_nrs(ballot_date = "2019-10-20",
#'                     lvl = "cantonal",
#'                     canton = "aargau",
#'                     prcd = "proportional")
election_nrs <- function(ballot_date = all_ballot_dates,
                         lvl = lvls(ballot_date,
                                    canton,
                                    ballot_type = "election"),
                         canton = cantons(ballot_date),
                         prcd = prcds(ballot_date = ballot_date,
                                      lvl = lvl,
                                      canton = canton)) {
  if (length(lvl)) {
    lvl <- rlang::arg_match(lvl,
                            values = all_lvls)
  }
  canton <- rlang::arg_match(canton,
                             values = all_cantons)
  if (length(prcd)) {
    prcd <- rlang::arg_match(prcd,
                             values = all_prcds)
  }
  
  result <- integer()
  raw <- raw_qstnr_suppl(ballot_date = ballot_date)
  
  if (isTRUE(lvl == "federal")) {
    
    result <- as.integer(names(raw$federal[[canton]]$election[[prcd]]))
  }
  
  if (isTRUE(lvl == "cantonal")) {
    
    result <- as.integer(names(raw$cantonal[[canton]]$election[[prcd]]))
  }
  
  result
}

#' Get number of referendum proposals
#'
#' Determines the number of referendum proposals covered by the FOKUS survey for the specified canton at the specified ballot date on the specified political
#' level(s).
#'
#' The number of *federal* proposals is independent from the canton, i.e. the returned number of *federal* proposals at a specific ballot date is always the
#' same, thus `canton` is ignored if `!("cantonal" %in% lvls)`.
#'
#' @inheritParams ballot_types
#' @param canton Canton name. One of
#' `r pal::as_md_val_list(all_cantons)`
#' 
#' Only relevant if `lvls` includes `"cantonal"`.
#'
#' @return An integer vector of the same length as and named after `lvls`.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::n_proposals(ballot_date = "2018-09-23",
#'                    canton = "aargau")
#'                    
#' fokus::n_proposals(ballot_date = "2018-09-23",
#'                    lvls = "cantonal",
#'                    canton = "aargau")
#'
#' fokus::n_proposals(ballot_date = "2019-10-20")
n_proposals <- function(ballot_date = all_ballot_dates,
                        lvls = all_lvls,
                        canton = cantons(ballot_date)) {
  
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = all_lvls,
                                          empty.ok = TRUE))
  result <- integer()
  raw <- raw_qstnr_suppl(ballot_date = ballot_date)
  
  if ("cantonal" %in% lvls) {
    
    canton <- rlang::arg_match(canton,
                               values = all_cantons)
    
    result <- c(cantonal = length(raw$cantonal[[canton]]$proposal))
  }
  
  if ("federal" %in% lvls) {
    
    result %<>% c(federal = length(raw$federal$proposal))
  }
  
  result
}

#' Get number of elections
#'
#' Determines the number of elections covered by the FOKUS survey for the specified canton at the specified ballot date on the specified political level(s) and
#' of the specified election procedure(s).
#'
#' @inheritParams ballot_types
#' @param prcds Election procedure(s). One or more of
#' `r pal::as_md_val_list(all_prcds)`
#'
#' @return An integer vector of length `lvls` × `prcds`, named after `lvls.prcds`.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::n_elections(ballot_date = "2018-09-23",
#'                    canton = "aargau")
#'                    
#' fokus::n_elections(ballot_date = "2018-09-23",
#'                    lvls = "federal",
#'                    canton = "aargau")
#'                    
#' fokus::n_elections(ballot_date = "2018-09-23",
#'                    lvls = "federal",
#'                    canton = "aargau",
#'                    prcds = "majoritarian")
n_elections <- function(ballot_date = all_ballot_dates,
                        lvls = all_lvls,
                        canton = cantons(ballot_date),
                        prcds = all_prcds) {
  
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = all_lvls,
                                          empty.ok = TRUE))
  canton <- rlang::arg_match(canton,
                             values = all_cantons)
  prcds <- unique(checkmate::assert_subset(prcds,
                                           choices = all_prcds,
                                           empty.ok = TRUE))
  result <- integer()
  raw <- raw_qstnr_suppl(ballot_date = ballot_date)
  
  if ("federal" %in% lvls) {
    
    result <-
      prcds %>%
      magrittr::set_names(., .) %>%
      purrr::map_int(~ length(raw$federal[[canton]]$election[[.x]])) %>%
      list(federal = .) %>%
      unlist()
  }
  
  if ("cantonal" %in% lvls) {
    
    result <-
      prcds %>%
      magrittr::set_names(., .) %>%
      purrr::map_int(~ length(raw$cantonal[[canton]]$election[[.x]])) %>%
      list(cantonal = .) %>%
      unlist() %>%
      c(result)
  }
  
  result
}

#' Determine whether ballot includes a referendum
#'
#' Determines whether or not the FOKUS survey for the specified canton at the specified ballot date on the specified political level(s) covered a referendum.
#'
#' @inheritParams n_proposals
#'
#' @return A logical vector of the same length as and named after `lvls`.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_referendum(ballot_date = "2018-09-23",
#'                       canton = "aargau")
#'
#' fokus::has_referendum(ballot_date = "2018-09-23",
#'                       lvls = "federal",
#'                       canton = "aargau")
has_referendum <- function(ballot_date = all_ballot_dates,
                           lvls = all_lvls,
                           canton = cantons(ballot_date)) {
  
  n_proposals(ballot_date = ballot_date,
              lvls = lvls,
              canton = canton) > 0L
}

#' Determine whether ballot includes an election
#'
#' Determines whether or not the FOKUS survey for the specified canton at the specified ballot date on the specified political level(s) covered an election of
#' the specified election procedure(s).
#'
#' @inheritParams n_elections
#'
#' @return A logical vector of length `lvls` × `prcds`, named after `lvls.prcds`.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_election(ballot_date = "2019-10-20",
#'                     canton = "aargau")
#'
#' fokus::has_election(ballot_date = "2019-10-20",
#'                     lvls = "federal",
#'                     canton = "aargau")
#'
#' fokus::has_election(ballot_date = "2018-09-23",
#'                     lvls = "federal",
#'                     canton = "aargau",
#'                     prcds = "proportional")
has_election <- function(ballot_date = all_ballot_dates,
                         lvls = all_lvls,
                         canton = cantons(ballot_date),
                         prcds = all_prcds) {
  
  n_elections(ballot_date = ballot_date,
              lvls = lvls,
              canton = canton,
              prcds = prcds) > 0L
}

#' Determine whether ballot includes type
#'
#' Determines whether or not the FOKUS survey for the specified canton at the specified ballot date on the specified political level(s) covered the specified
#' [ballot types][ballot_types] (of the specified election procedure(s)).
#'
#' @inheritParams n_elections
#' @param canton Canton name. One of
#' `r pal::as_md_val_list(all_cantons)`
#' 
#' Only relevant if `lvls` includes `"cantonal"` or `ballot_type = "election"`.
#' @param ballot_type Ballot type to test for. One of
#' `r pal::as_md_val_list(all_ballot_types)`
#' @param prcds Election procedure(s). One or more of
#' `r pal::as_md_val_list(all_prcds)`
#' 
#' Only relevant if `ballot_type = "election"`.
#'
#' @return A logical vector of the same length as `lvl` (× `prcds`), named after `lvls(.prcds).ballot_type`.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_ballot_type(ballot_date = "2018-09-23",
#'                        canton = "aargau")
#'                         
#' fokus::has_ballot_type(ballot_date = "2018-09-23",
#'                        canton = "aargau",
#'                        ballot_type = "election")
#'                         
#' fokus::has_ballot_type(ballot_date = "2019-10-20",
#'                        canton = "aargau",
#'                        ballot_type = "election",
#'                        prcds = "proportional")
has_ballot_type <- function(ballot_date = all_ballot_dates,
                            lvls = all_lvls,
                            canton = cantons(ballot_date),
                            ballot_type = ballot_types(ballot_date = ballot_date,
                                                       lvls = lvls,
                                                       canton = canton),
                            prcds = all_prcds) {
  
  ballot_type <- rlang::arg_match(ballot_type,
                                  values = all_ballot_types)
  
  if (isTRUE(ballot_type == "election")) {
    
    result <-
      has_election(ballot_date = ballot_date,
                   lvls = lvls,
                   canton = canton,
                   prcds = prcds) %>%
      magrittr::set_names(paste(names(.), "election",
                                sep = "."))
  } else if (isTRUE(ballot_type == "referendum")) {
    
    result <-
      has_referendum(ballot_date = ballot_date,
                     lvls = lvls,
                     canton = canton) %>%
      magrittr::set_names(paste(names(.), "referendum",
                                sep = "."))
  }
  
  result
}

#' Determine whether ballot includes a political level
#'
#' Determines whether or not the FOKUS survey for the specified canton at the specified ballot date covered the specified political level.
#'
#' @inheritParams cantons
#' @param lvl Political level to test for. One of
#' `r pal::as_md_val_list(all_lvls)`
#' @param canton Canton name. One of
#' `r pal::as_md_val_list(all_cantons)`
#' 
#' Only relevant if `lvl = "cantonal"` or `ballot_types` includes `"election"`.
#' @param ballot_types Ballot type(s). One or more of
#' `r pal::as_md_val_list(all_ballot_types)`
#' @param prcds Election procedure(s). One or more of
#' `r pal::as_md_val_list(all_prcds)`
#' 
#' Only relevant if `ballot_types` includes `"election"`.
#'
#' @return A logical vector of the same length as (`prcds` ×) `ballot_types`, named after `lvl(.prcds).ballot_types`.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_lvl(ballot_date = "2018-09-23",
#'                lvl = "federal",
#'                canton = "aargau")
#'
#' fokus::has_lvl(ballot_date = "2018-09-23",
#'                lvl = "federal",
#'                canton = "aargau",
#'                ballot_types = "election")
#'
#' fokus::has_lvl(ballot_date = "2019-10-20",
#'                lvl = "federal",
#'                canton = "aargau",
#'                ballot_types = "election")
has_lvl <- function(ballot_date = all_ballot_dates,
                    lvl = lvls(ballot_date,
                               canton),
                    canton = cantons(ballot_date),
                    ballot_types = all_ballot_types,
                    prcds = all_prcds) {
  
  if (length(lvl)) {
    lvl <- rlang::arg_match(lvl,
                            values = all_lvls)
  }
  ballot_types <- unique(checkmate::assert_subset(ballot_types,
                                                  choices = all_ballot_types,
                                                  empty.ok = FALSE))
  result <- logical()
  
  if ("election" %in% ballot_types) {
    
    result <-
      has_election(ballot_date = ballot_date,
                   lvls = lvl,
                   canton = canton,
                   prcds = prcds) %>%
      magrittr::set_names(paste(names(.), "election",
                                sep = "."))
  }
  
  if ("referendum" %in% ballot_types) {
    
    result <-
      has_referendum(ballot_date = ballot_date,
                     lvls = lvl,
                     canton = canton) %>%
      magrittr::set_names(paste(names(.), "referendum",
                                sep = ".")) %>%
      c(result)
  }
  
  result
}

#' Determine whether ballot includes referendum proposals
#'
#' Determines whether or not the FOKUS survey for the specified canton at the specified ballot date on the specified political levels covered the specified
#' referendum proposal numbers.
#'
#' @inheritParams n_proposals
#' @param proposal_nrs Proposals number(s) to test for. An integerish vector or `NULL`. If `NULL`, falls back to [`1:n_proposals()`][n_proposals] present
#'   matching the specified parameters.
#'
#' @return Either
#' - **an unnamed logical scalar** if `proposal_nrs` is `NULL` and there was no FOKUS-covered referendum at `ballot_date` on any `lvls`, or
#' - **a logical vector** of the same length as `lvls` × `proposal_nrs`, **named** after `lvls.proposal_nrs`.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_proposal_nrs(ballot_date = "2018-09-23",
#'                         canton = "aargau")
#'
#' fokus::has_proposal_nrs(ballot_date = "2018-09-23",
#'                         lvls = "federal",
#'                         canton = "aargau")
#'                         
#' fokus::has_proposal_nrs(ballot_date = "2018-09-23",
#'                         canton = "aargau",
#'                         proposal_nrs = 1:5)
#'
#' fokus::has_proposal_nrs(ballot_date = "2019-10-20",
#'                         canton = "aargau")
#'
#' fokus::has_proposal_nrs(ballot_date = "2021-11-28",
#'                         lvls = "cantonal",
#'                         canton = "aargau")
has_proposal_nrs <- function(ballot_date = all_ballot_dates,
                             lvls = all_lvls,
                             canton = cantons(ballot_date),
                             proposal_nrs = NULL) {
  
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = all_lvls,
                                          empty.ok = TRUE))
  
  checkmate::assert_integerish(proposal_nrs,
                               lower = 1L,
                               any.missing = FALSE,
                               null.ok = TRUE)
  lvls %>%
    magrittr::set_names(., .) %>%
    purrr::map(~ {
      
      present_proposal_nrs <- proposal_nrs(ballot_date = ballot_date,
                                           lvl = .x,
                                           canton = canton)
      if (is.null(proposal_nrs)) {
        proposal_nrs <- present_proposal_nrs
      }
      
      proposal_nrs %>%
        magrittr::set_names(., .) %>%
        purrr::map(~ .x %in% present_proposal_nrs)
    }) %>%
    unlist() %>%
    pal::when(is.null(.) ~ FALSE,
              ~ .)
}

#' Determine whether ballot includes elections
#'
#' Determines whether or not the FOKUS survey for the specified canton at the specified ballot date on the specified political levels covered the specified
#' election numbers of the specified procedures.
#'
#' @inheritParams n_elections
#' @param election_nrs Election number(s) to test for. An integerish vector or `NULL`. If `NULL`, falls back to [`1:n_elections()`][n_elections] present
#'   matching the specified parameters.
#'
#' @return Either
#' - **an unnamed logical scalar** if `election_nrs` is `NULL` and there was no FOKUS-covered election of any `prcds` at `ballot_date` on any `lvls`, or
#' - **a logical vector** of the same length as `lvls` × `prcds` × `election_nrs`, **named** after `lvls.prcds.election_nrs`.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_election_nrs(ballot_date = "2019-10-20",
#'                         canton = "aargau")
#'
#' fokus::has_election_nrs(ballot_date = "2019-10-20",
#'                         lvls = "federal",
#'                         canton = "aargau",
#'                         prcds = "proportional")
#'                         
#' fokus::has_election_nrs(ballot_date = "2019-10-20",
#'                         canton = "aargau",
#'                         election_nrs = 1:2)
#'
#' fokus::has_election_nrs(ballot_date = "2018-09-23",
#'                         canton = "aargau")
#'
#' fokus::has_election_nrs(ballot_date = "2020-10-18",
#'                         lvls = "federal",
#'                         canton = "aargau")
has_election_nrs <- function(ballot_date = all_ballot_dates,
                             lvls = all_lvls,
                             canton = cantons(ballot_date),
                             prcds = all_prcds,
                             election_nrs = NULL) {
  
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = all_lvls,
                                          empty.ok = TRUE))
  
  checkmate::assert_integerish(election_nrs,
                               lower = 1L,
                               any.missing = FALSE,
                               null.ok = TRUE)
  lvls %>%
    magrittr::set_names(., .) %>%
    purrr::map(function(lvl) {
      
      prcds %>%
        magrittr::set_names(., .) %>%
        purrr::map(lvl = lvl,
                   .f = function(prcd,
                                 lvl) {
                     
                     present_election_nrs <- election_nrs(ballot_date = ballot_date,
                                                          lvl = lvl,
                                                          canton = canton,
                                                          prcd = prcd)
                     if (is.null(election_nrs)) {
                       election_nrs <- present_election_nrs
                     }
                     
                     election_nrs %>%
                       magrittr::set_names(., .) %>%
                       purrr::map(~ .x %in% present_election_nrs)
                   })
    }) %>%
    unlist() %>%
    pal::when(is.null(.) ~ FALSE,
              ~ .)
}

#' Get proposal type
#'
#' @inheritParams proposal_name
#'
#' @return Proposal type. One of
#' `r pal::as_md_val_list(all_proposal_types)`
#'
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_type(ballot_date = "2018-09-23",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      proposal_nr = 1)
proposal_type <- function(ballot_date = all_ballot_dates,
                          lvl = lvls(ballot_date,
                                     canton,
                                     ballot_type = "referendum"),
                          canton = cantons(ballot_date),
                          proposal_nr = 1L) {
  
  raw_qstnr_suppl_proposal(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           proposal_nr = proposal_nr) %>%
    purrr::chuck("type")
}

#' Get proposal name
#'
#' Returns the name of the specified proposal in the specified language.
#'
#' @inheritParams proposal_nrs
#' @inheritParams lang_to_locale
#' 
#' @param proposal_nr Proposal number. A positive integerish scalar.
#' @param type Name type. One of
#'   - `"short"`
#'   - `"long"`
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_name(ballot_date = "2018-09-23",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      proposal_nr = 1,
#'                      type = "long")
proposal_name <- function(ballot_date = all_ballot_dates,
                          lvl = lvls(ballot_date,
                                     canton,
                                     ballot_type = "referendum"),
                          canton = cantons(ballot_date),
                          proposal_nr = 1L,
                          lang = c("de", "en"),
                          type = c("short", "long")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  
  raw_qstnr_suppl_proposal_name(ballot_date = ballot_date,
                                lvl = lvl,
                                canton = canton,
                                proposal_nr = proposal_nr) %>%
    purrr::chuck(lang, type, "text")
}

#' Get German proposal name's grammatical gender
#'
#' Returns the grammatical gender of the German name of the specified proposal.
#'
#' @inheritParams proposal_name
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_name_gender(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1,
#'                             type = "short")
proposal_name_gender <- function(ballot_date = all_ballot_dates,
                                 lvl = lvls(ballot_date,
                                            canton,
                                            ballot_type = "referendum"),
                                 canton = cantons(ballot_date),
                                 proposal_nr = 1L,
                                 type = c("short", "long")) {
  
  type <- rlang::arg_match(type)
  
  raw_qstnr_suppl_proposal_name(ballot_date = ballot_date,
                                lvl = lvl,
                                canton = canton,
                                proposal_nr = proposal_nr) %>%
    purrr::chuck("de", type, "gender")
}

#' Get proposal's arguments
#'
#' Returns text, side and number of all arguments on the specified proposal.
#'
#' @inheritParams proposal_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_arguments(ballot_date = "2018-09-23",
#'                           lvl = "cantonal",
#'                           canton = "aargau",
#'                           proposal_nr = 1)
proposal_arguments <- function(ballot_date = all_ballot_dates,
                               lvl = lvls(ballot_date,
                                          canton,
                                          ballot_type = "referendum"),
                               canton = cantons(ballot_date),
                               proposal_nr = 1L) {
  
  raw_qstnr_suppl_arguments(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            proposal_nr = proposal_nr) %>%
    purrr::map(as_flat_list) %>%
    purrr::map(tibble::as_tibble) %>%
    purrr::list_rbind()
}

#' Get proposal argument
#'
#' Returns the specified proposal argument's text of the specified type in the specified language.
#'
#' @inheritParams proposal_arguments
#' @inheritParams proposal_name
#' @param argument_nr Proposal argument number. A positive integerish scalar.
#' @param side Proposal argument side. One of
#' `r pal::as_md_val_list(all_argument_sides)`
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_argument(ballot_date = "2018-09-23",
#'                          lvl = "cantonal",
#'                          canton = "aargau",
#'                          proposal_nr = 1,
#'                          argument_nr = 3,
#'                          side = "contra",
#'                          type = "long")
proposal_argument <- function(ballot_date = all_ballot_dates,
                              lvl = lvls(ballot_date,
                                         canton,
                                         ballot_type = "referendum"),
                              canton = cantons(ballot_date),
                              proposal_nr = 1L,
                              argument_nr = 1L,
                              side = all_argument_sides,
                              lang = c("de", "en"),
                              type = c("short", "long")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  
  raw_qstnr_suppl_argument(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           proposal_nr = proposal_nr,
                           argument_nr = argument_nr,
                           side = side) %>%
    purrr::chuck(lang, type)
}

#' Get proposal's number of arguments
#'
#' Determines the number of arguments on the specified proposal of the specified sides.
#'
#' @inheritParams proposal_name
#' @param sides Proposal argument side(s). One or more of
#' `r pal::as_md_val_list(all_argument_sides)`
#'
#' @return An integer scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::n_proposal_arguments(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1)
#'
#' fokus::n_proposal_arguments(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1,
#'                             sides = "pro")
n_proposal_arguments <- function(ballot_date = all_ballot_dates,
                                 lvl = lvls(ballot_date,
                                            canton,
                                            ballot_type = "referendum"),
                                 canton = cantons(ballot_date),
                                 proposal_nr = 1L,
                                 sides = all_argument_sides) {
  
  sides <- unique(checkmate::assert_subset(sides,
                                           choices = all_argument_sides,
                                           empty.ok = FALSE))
  
  raw_qstnr_suppl_proposal(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           proposal_nr = proposal_nr) %>%
    purrr::pluck("argument") %>%
    purrr::keep(~ .x$side %in% sides) %>%
    length()
}

#' Get proposal's main motives
#'
#' Returns text and code number of all main motives on the specified proposal.
#'
#' @inheritParams proposal_name
#' @param type Main motive type. One of
#'   - `"yes"`
#'   - `"no"`
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_main_motives(ballot_date = "2018-09-23",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              proposal_nr = 1,
#'                              type = "no")
proposal_main_motives <- function(ballot_date = all_ballot_dates,
                                  lvl = lvls(ballot_date,
                                             canton,
                                             ballot_type = "referendum"),
                                  canton = cantons(ballot_date),
                                  proposal_nr = 1L,
                                  type = c("yes",
                                           "no")) {
  type <- rlang::arg_match(type)
  
  raw_qstnr_suppl_main_motives(ballot_date = ballot_date,
                               lvl = lvl,
                               canton = canton,
                               proposal_nr = proposal_nr) %>%
    purrr::chuck(type) %>%
    purrr::map(tibble::as_tibble) %>%
    purrr::list_rbind()
}

#' Get proposal's number of main motives
#'
#' Determines the number of main motives on the specified proposal.
#'
#' @inheritParams proposal_main_motives
#'
#' @return An integer scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::n_proposal_main_motives(ballot_date = "2018-09-23",
#'                                lvl = "cantonal",
#'                                canton = "aargau",
#'                                proposal_nr = 1,
#'                                type = "no")
n_proposal_main_motives <- function(ballot_date = all_ballot_dates,
                                    lvl = lvls(ballot_date,
                                               canton,
                                               ballot_type = "referendum"),
                                    canton = cantons(ballot_date),
                                    proposal_nr = 1L,
                                    type = c("yes",
                                             "no")) {
  type <- rlang::arg_match(type)
  
  raw_qstnr_suppl_proposal(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           proposal_nr = proposal_nr) %>%
    purrr::pluck("main_motive") %>%
    purrr::pluck(type) %>%
    length()
}

#' Get election name
#'
#' Returns the name of the specified election in the specified language.
#'
#' @inheritParams election_nrs
#' @inheritParams proposal_name
#' @param election_nr Election number. A positive integerish scalar.
#' @param type Name type. One of
#'   - `"short"`
#'   - `"long"`
#'   - `"body"`
#'   - `"body_alt"`
#'
#' @return A character scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_name(ballot_date = "2019-10-20",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      prcd = "majoritarian",
#'                      election_nr = 1,
#'                      type = "body")
election_name <- function(ballot_date = all_ballot_dates,
                          lvl = lvls(ballot_date,
                                     canton,
                                     ballot_type = "election"),
                          canton = cantons(ballot_date),
                          prcd = prcds(ballot_date,
                                       lvl,
                                       canton),
                          election_nr = 1L,
                          lang = c("de", "en"),
                          type = c("short", "long", "body", "body_alt")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  # this is required to trigger a proper error message in case `prcds` is not explicitly set and there are no elections (`prcd = character()`)
  if (!length(prcd)) {
    cli::cli_abort(paste0("{.arg prcd} must be one of ", pal::prose_ls(paste0("{.val ", all_prcds, "}"), last_sep = " or "), "."))
  }
  
  raw_qstnr_suppl_election_name(ballot_date = ballot_date,
                                lvl = lvl,
                                canton = canton,
                                prcd = prcd,
                                election_nr = election_nr) %>%
    purrr::chuck(lang, type, "text")
}

#' Get combined elections name
#'
#' Returns the combined name of all elections at the specified date on the specified level(s) for the specified canton in the specified language.
#'
#' @inheritParams n_elections
#' @inheritParams proposal_name
#' @param federal_first Whether or not to list federal elections before cantonal ones. Only has an effect if `"federal" %in% lvls`.
#'
#' @return A character scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_names_combined(ballot_date = "2019-10-20",
#'                                lvls = "federal",
#'                                canton = "aargau")
#'
#' fokus::election_names_combined(ballot_date = "2019-10-20",
#'                                canton = "aargau")
#'
#' fokus::election_names_combined(ballot_date = "2019-10-20",
#'                                canton = "aargau",
#'                                federal_first = FALSE)
election_names_combined <- function(ballot_date = all_ballot_dates,
                                    lvls = all_lvls,
                                    canton = cantons(ballot_date),
                                    lang = c("de", "en"),
                                    federal_first = TRUE) {
  
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = all_lvls,
                                          empty.ok = FALSE))
  lang <- rlang::arg_match(lang)
  checkmate::assert_flag(federal_first)
  
  lvls %>%
    intersect(lvls(ballot_date = ballot_date,
                   canton = canton,
                   ballot_type = "election")) %>%
    purrr::map_chr(~ raw_qstnr_suppl_elections(ballot_date = ballot_date,
                                               lvl = .x,
                                               canton = canton) %>%
                     purrr::chuck("names_combined", lang, "short")) %>%
    pal::when(federal_first ~ .[sort(x = seq_along(.),
                                     decreasing = TRUE)],
              ~ .) %>%
    pal::prose_ls(last_sep = switch(EXPR = lang,
                                    "de" = " sowie ",
                                    "en" = " as well as "))
}

#' Get number of majoritarian election seats
#'
#' Determines the number of election seats of the specified type for the specified majoritarian election.
#'
#' @inheritParams ballot_types
#' @inheritParams election_name
#' @param type Seat type. One of
#'  - `"vacant"`
#'  - `"total"`
#'
#' @return An integer scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::n_election_seats(ballot_date = "2019-10-20",
#'                         lvl = "cantonal",
#'                         canton = "aargau",
#'                         type = "total")
n_election_seats <- function(ballot_date = all_ballot_dates,
                             lvl = lvls(ballot_date,
                                        canton,
                                        ballot_type = "election"),
                             canton = cantons(ballot_date),
                             election_nr = 1L,
                             type = c("vacant", "total")) {
  
  type <- rlang::arg_match(type)
  
  raw_qstnr_suppl_election(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           prcd = "majoritarian",
                           election_nr = election_nr) %>%
    purrr::chuck("n_seats", type)
}

#' Get majoritarian election's candidates
#'
#' Returns the name and party of all candidates running for the specified majoritarian election.
#'
#' @inheritParams n_election_seats
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_candidates(ballot_date = "2019-10-20",
#'                            lvl = "cantonal",
#'                            canton = "aargau")
election_candidates <- function(ballot_date = all_ballot_dates,
                                lvl = lvls(ballot_date,
                                           canton,
                                           ballot_type = "election"),
                                canton = cantons(ballot_date),
                                election_nr = 1L) {
  
  raw_qstnr_suppl_election(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           prcd = "majoritarian",
                           election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    purrr::map(tibble::as_tibble) %>%
    purrr::list_rbind()
}

#' Get number of (officially registered) majoritarian election candidates
#'
#' Determines the number of (officially registered) candidates of a majoritarian election at the specified ballot date on the specified political level.
#'
#' @inheritParams n_election_seats
#'
#' @return An integer scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::n_election_candidates(ballot_date = "2019-10-20",
#'                              lvl = "cantonal",
#'                              canton = "aargau")
n_election_candidates <- function(ballot_date = all_ballot_dates,
                                  lvl = lvls(ballot_date,
                                             canton,
                                             ballot_type = "election"),
                                  canton = cantons(ballot_date),
                                  election_nr = 1L) {
  
  raw_qstnr_suppl_election(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           prcd = "majoritarian",
                           election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    length()
}

#' Assemble majoritarian election's candidate string(s)
#'
#' Assembles one or more majoritarian election candidate string(s) consisting of the candidate's first name, last name and optionally political party (in
#' parentheses).
#'
#' @inheritParams n_election_seats
#' @param candidate_nrs Election candidate numbers to include. A vector of positive integers or `NULL`. If `NULL`, all candidates will be included.
#' @param incl_party Whether or not to include the candidate's political party in the resulting string (in parentheses).
#'
#' @return A character vector.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_candidate_prose(ballot_date = "2019-10-20",
#'                                 lvl = "cantonal",
#'                                 canton = "aargau",
#'                                 candidate_nrs = 1:3)
election_candidate_prose <- function(ballot_date = all_ballot_dates,
                                     lvl = lvls(ballot_date,
                                                canton,
                                                ballot_type = "election"),
                                     canton = cantons(ballot_date),
                                     election_nr = 1L,
                                     candidate_nrs = NULL,
                                     incl_party = TRUE) {
  
  data_candidates <- election_candidates(ballot_date = ballot_date,
                                         lvl = lvl,
                                         canton = canton,
                                         election_nr = election_nr)
  
  checkmate::assert_integerish(candidate_nrs,
                               lower = 1L,
                               upper = nrow(data_candidates),
                               any.missing = FALSE,
                               null.ok = TRUE)
  checkmate::assert_flag(incl_party)
  
  if (length(candidate_nrs)) {
    data_candidates %<>% dplyr::filter(dplyr::row_number() %in% candidate_nrs)
  }
  
  data_candidates %>% purrr::pmap_chr(incl_party = incl_party,
                                      .f = function(first_name, last_name, party, ..., incl_party) {
                                        paste0(first_name, " ", last_name, paste0(" (", party, ")")[incl_party])
                                      })
}

#' Get proportional election's political parties
#'
#' Returns the questionnaire code as well as different versions of the name of all parties for the specified proportional election.
#'
#' @inheritParams n_election_seats
#' @param past Whether to extract the current or the predecessor election's parties.
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_parties(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau")
#'
#' fokus::election_parties(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau",
#'                         past = TRUE)
election_parties <- function(ballot_date = all_ballot_dates,
                             lvl = lvls(ballot_date,
                                        canton,
                                        ballot_type = "election"),
                             canton = cantons(ballot_date),
                             election_nr = 1L,
                             past = FALSE) {
  
  checkmate::assert_flag(past)
  
  raw_qstnr_suppl_election(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           prcd = "proportional",
                           election_nr = election_nr) %>%
    purrr::chuck(ifelse(past,
                        "past_party",
                        "party")) %>%
    purrr::map(as_flat_list) %>%
    purrr::map(tibble::as_tibble) %>%
    purrr::list_rbind()
}

#' Get proportional election's tickets
#'
#' Returns the name, number and party of all tickets for the specified proportional election.
#'
#' @inheritParams n_election_seats
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_tickets(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau")
election_tickets <- function(ballot_date = all_ballot_dates,
                             lvl = lvls(ballot_date,
                                        canton,
                                        ballot_type = "election"),
                             canton = cantons(ballot_date),
                             election_nr = 1L) {
  
  raw_qstnr_suppl_election(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           prcd = "proportional",
                           election_nr = election_nr) %>%
    purrr::chuck("ticket") %>%
    purrr::map(tibble::as_tibble) %>%
    purrr::list_rbind()
}

#' Determine whether majoritarian election requires candidate registration
#'
#' Determines whether or not candidates must be officially registered prior to the specified majority election.
#'
#' The absence of a candidate registration requirement usually means that every eligible citizen can be elected, i.e. receive valid votes.
#'
#' @inheritParams n_election_seats
#'
#' @return A logical scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::requires_candidate_registration(ballot_date = "2019-10-20",
#'                                        lvl = "federal",
#'                                        canton = "aargau")
requires_candidate_registration <- function(ballot_date = all_ballot_dates,
                                            lvl = lvls(ballot_date,
                                                       canton,
                                                       ballot_type = "election"),
                                            canton = cantons(ballot_date),
                                            election_nr = 1L) {
  
  raw_qstnr_suppl_election(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           prcd = "majoritarian",
                           election_nr = election_nr) %>%
    purrr::chuck("requires_candidate_registration")
}

#' Get skill question numbers
#'
#' Determines the skill questions numbers at the specified ballot date on the specified political level. Note that by default (`proposal_nr = NULL`),
#' non-proposal-specific skill question numbers are returned.
#'
#' @inheritParams proposal_nrs
#' @param proposal_nr Proposal number. A positive integerish scalar or `NULL`. If `NULL`, the numbers of non-proposal-specific skill questions are returned.
#'
#' @return An integer vector.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_nrs(ballot_date = "2018-09-23",
#'                           lvl = "cantonal",
#'                           canton = "aargau",
#'                           proposal_nr = 1)
#'
#' # note that by default, non-proposal-specific skill question numbers are returned
#' fokus::skill_question_nrs(ballot_date = "2018-09-23",
#'                           lvl = "cantonal",
#'                           canton = "aargau")
#'
#' fokus::skill_question_nrs(ballot_date = "2019-10-20",
#'                           lvl = "cantonal",
#'                           canton = "aargau")
skill_question_nrs <- function(ballot_date = all_ballot_dates,
                               lvl = lvls(ballot_date,
                                          canton),
                               canton = cantons(ballot_date),
                               proposal_nr = NULL) {
  
  pal::safe_seq_len(n_skill_questions(ballot_date = ballot_date,
                                      lvl = lvl,
                                      canton = canton,
                                      proposal_nr = proposal_nr))
}

#' Get number of skill questions
#'
#' Determines the number of skill questions at the specified ballot date on the specified political level. Note that by default (`proposal_nr = NULL`), the
#' number of non-proposal-specific skill questions is returned.
#'
#' @inheritParams proposal_nrs
#' @param proposal_nr Proposal number. A positive integerish scalar or `NULL`. If `NULL`, the number of non-proposal-specific skill questions is returned.
#'
#' @return An integer scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::n_skill_questions(ballot_date = "2018-09-23",
#'                          lvl = "cantonal",
#'                          canton = "aargau",
#'                          proposal_nr = 1)
#'
#' # note that by default, the number of non-proposal-specific skill questions is returned
#' fokus::n_skill_questions(ballot_date = "2018-09-23",
#'                          lvl = "cantonal",
#'                          canton = "aargau")
#'
#' fokus::n_skill_questions(ballot_date = "2019-10-20",
#'                          lvl = "cantonal",
#'                          canton = "aargau")
n_skill_questions <- function(ballot_date = all_ballot_dates,
                              lvl = lvls(ballot_date,
                                         canton),
                              canton = cantons(ballot_date),
                              proposal_nr = NULL) {
  
  lvl <- rlang::arg_match(lvl,
                          values = all_lvls)
  if (lvl == "cantonal") {
    canton <- rlang::arg_match(canton,
                               values = cantons(ballot_date))
  }
  checkmate::assert_count(proposal_nr,
                          positive = TRUE,
                          null.ok = TRUE)
  
  raw_qstnr_suppl(ballot_date = ballot_date) %>%
    purrr::pluck(lvl) %>%
    pal::when(lvl == "cantonal" ~ purrr::pluck(., canton),
              ~ .) %>%
    # get non-proposal-specific skill questions if `proposal_nr = NULL`
    pal::when(length(proposal_nr) > 0L ~ purrr::pluck(., "proposal", proposal_nr),
              ~ .) %>%
    purrr::pluck("skill_question") %>%
    length()
}

#' Get skill question
#'
#' Returns the skill question text in the specified language. Note that by default (`proposal_nr = NULL`), only non-proposal-specific skill questions are
#' returned.
#'
#' @inheritParams proposal_name
#' @param proposal_nr Proposal number. A positive integerish scalar or `NULL`. If `NULL`, it is considered to be a non-proposal-specific skill question
#'   (the case at elections).
#' @param skill_question_nr Skill question number. A positive integerish scalar.
#'
#' @return A character scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question(ballot_date = "2018-09-23",
#'                       lvl = "cantonal",
#'                       canton = "aargau",
#'                       proposal_nr = 1,
#'                       skill_question_nr = 2,
#'                       lang = "en")
skill_question <- function(ballot_date = all_ballot_dates,
                           lvl = lvls(ballot_date,
                                      canton),
                           canton = cantons(ballot_date),
                           proposal_nr = NULL,
                           skill_question_nr = 1L,
                           lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  raw_qstnr_suppl_skill_question(ballot_date = ballot_date,
                                 lvl = lvl,
                                 canton = canton,
                                 proposal_nr = proposal_nr,
                                 skill_question_nr = skill_question_nr) %>%
    purrr::chuck(lang)
}

#' Get skill question response options
#'
#' Returns the response options of the specified skill question together with the information whether they are correct or not.
#'
#' @inheritParams skill_question
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_response_options(ballot_date = "2018-09-23",
#'                                        lvl = "cantonal",
#'                                        canton = "aargau",
#'                                        proposal_nr = 1,
#'                                        skill_question_nr = 2)
skill_question_response_options <- function(ballot_date = all_ballot_dates,
                                            lvl = lvls(ballot_date,
                                                       canton),
                                            canton = cantons(ballot_date),
                                            proposal_nr = NULL,
                                            skill_question_nr = 1L) {
  
  raw_qstnr_suppl_skill_question(ballot_date = ballot_date,
                                 lvl = lvl,
                                 canton = canton,
                                 proposal_nr = proposal_nr,
                                 skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map(tibble::as_tibble) %>%
    purrr::list_rbind()
}

#' Get correct skill question answer number
#'
#' Returns the sequential number of the correct answer for the specified skill question.
#'
#' @inheritParams skill_question
#'
#' @return An integer scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_answer_nr(ballot_date = "2018-09-23",
#'                                 lvl = "cantonal",
#'                                 canton = "aargau",
#'                                 proposal_nr = 1,
#'                                 skill_question_nr = 2)
skill_question_answer_nr <- function(ballot_date = all_ballot_dates,
                                     lvl = lvls(ballot_date,
                                                canton),
                                     canton = cantons(ballot_date),
                                     proposal_nr = NULL,
                                     skill_question_nr = 1L) {
  
  raw_qstnr_suppl_skill_question(ballot_date = ballot_date,
                                 lvl = lvl,
                                 canton = canton,
                                 proposal_nr = proposal_nr,
                                 skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map_depth(.depth = 1L,
                     .f = ~ .x$is_correct) %>%
    purrr::list_c(ptype = logical()) %>%
    which()
}

#' Get referendum proposal numbers with skill questions
#'
#' Determines the referendum proposal numbers covered by the FOKUS survey for the specified canton at the specified ballot date on the specified political
#' level that have at least one skill question.
#'
#' @inheritParams proposal_nrs
#'
#' @return An integer vector.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_proposal_nrs(ballot_date = "2018-09-23",
#'                                    lvl = "cantonal",
#'                                    canton = "aargau")
skill_question_proposal_nrs <- function(ballot_date = all_ballot_dates,
                                        lvl = lvls(ballot_date,
                                                   canton,
                                                   ballot_type = "referendum"),
                                        canton = cantons(ballot_date)) {
  lvl <- rlang::arg_match(lvl,
                          values = all_lvls)
  if (lvl == "cantonal") {
    canton <- rlang::arg_match(canton,
                               values = cantons(ballot_date))
  }
  
  raw_qstnr_suppl(ballot_date = ballot_date) %>%
    purrr::pluck(lvl) %>%
    pal::when(lvl == "cantonal" ~ purrr::pluck(., canton),
              ~ .) %>%
    purrr::pluck("proposal") %>%
    purrr::keep(~ rlang::has_name(.x,
                                  "skill_question")) %>%
    names() %>%
    as.integer()
}

#' Get ballot title
#'
#' Returns the ballot title consisting of the [ballot type][ballot_types()] and the ballot date in German prose.
#'
#' @inheritParams lvls
#' @inheritParams proposal_name
#'
#' @return A character scalar.
#' @family predicate_other
#' @export
#'
#' @examples
#' fokus::ballot_title(ballot_date = "2019-10-20",
#'                     canton = "aargau")
ballot_title <- function(ballot_date = all_ballot_dates,
                         canton = cantons(ballot_date),
                         lang = c("de", "en")) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  lang <- rlang::arg_match(lang)
  
  ballot_types <- ballot_types(ballot_date = ballot_date,
                               canton = canton)
  
  if (!length(ballot_types)) {
    cli::cli_abort("No ballot type could be determined. Please debug.",
                   .internal = TRUE)
  }
  
  if (lang == "de") {
    
    result <-
      ballot_types %>%
      pal::when(length(.) > 1L ~ "Abstimmungs- und Wahl",
                . == "referendum" ~ "Abstimmungs",
                . == "election" ~ "Wahl") %>%
      paste0("termin vom ", stringi::stri_datetime_format(time = ballot_date,
                                                          format = "date_long",
                                                          locale = lang_to_locale(lang)))
    
  } else if (lang == "en") {
    
    result <-
      ballot_types %>%
      pal::when(length(.) > 1L ~ "Referendum and election",
                ~ stringr::str_to_sentence(.)) %>%
      paste0(" date of ", stringi::stri_datetime_format(time = ballot_date,
                                                        format = "date_long",
                                                        locale = lang_to_locale(lang)))
  }
  
  result
}

#' Get political issues
#'
#' Returns the political issues in the specified language at the specified ballot date.
#'
#' @inheritParams proposal_name
#'
#' @return A character vector.
#' @family predicate_other
#' @export
#'
#' @examples
#' fokus::political_issues(ballot_date = "2019-10-20",
#'                         lang = "en")
political_issues <- function(ballot_date = all_ballot_dates,
                             lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  result <-
    raw_qstnr_suppl(ballot_date = ballot_date) %>%
    purrr::pluck("political_issues")
  
  if (is.null(result)) {
    
    # reduce to proper arg value for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(all_ballot_dates))
    
    cli::cli_abort("No political issues present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.",
                   .internal = TRUE)
  }
  
  result %>%
    purrr::chuck("issue") %>%
    purrr::map_depth(1L, purrr::chuck, lang) %>%
    purrr::list_c(ptype = character())
}

#' Get postal dispatch way
#'
#' Returns the FOKUS survey's postal dispatch way of the specified type in the specified language for the specified canton at the specified ballot date.
#'
#' @inheritParams lvls
#' @param dispatch_type Postal dispatch type. One of
#' `r pal::as_md_val_list(all_postal_dispatch_types)`
#'
#' @return A character scalar.
#' @family predicate_other
#' @seealso [postal_dispatch_way_prose()]
#' @export
#'
#' @examples
#' fokus::postal_dispatch_way(ballot_date = "2018-09-23",
#'                            canton = "aargau",
#'                            dispatch_type = "invitation")
postal_dispatch_way <- function(ballot_date = all_ballot_dates,
                                canton = cantons(ballot_date),
                                dispatch_type = all_postal_dispatch_types) {
  
  dispatch_type <- rlang::arg_match(dispatch_type)
  
  raw_qstnr_suppl_mode(ballot_date = ballot_date,
                       canton = canton) %>%
    purrr::chuck("postal_dispatch", "type", dispatch_type)
}

#' Get response options
#'
#' Returns response options of the specified type and optionally subtype(s) from the [raw FOKUS questionnaire data][raw_qstnr].
#'
#' Note that only recurring response options are returned which are defined under the `response_options` top-level key in the file
#' `data-raw/questionnaire/questionnaire.toml`.
#'
#' @inheritParams proposal_name
#' @param type Response option type. One of
#' `r pal::as_md_val_list(all_response_option_types)`
#' @param subtypes Hierarchical response option subtypes as a character vector, or `NULL`. If `NULL`, all subtypes are returned.
#'
#' @return A character vector.
#' @family predicate_other
#' @export
#'
#' @examples
#' fokus:::response_options(type = "abstain",
#'                          lang = "de")
#'
#' fokus:::response_options(type = "abstain",
#'                          lang = "de",
#'                          subtypes = "election")
#'
#' fokus:::response_options(type = "abstain",
#'                          lang = "de",
#'                          subtypes = c("election", "proportional"))
response_options <- function(type = all_response_option_types,
                             lang = c("de", "en"),
                             subtypes = NULL) {
  
  type <- rlang::arg_match(type)
  lang <- rlang::arg_match(lang)
  checkmate::assert_character(subtypes,
                              any.missing = FALSE,
                              min.len = 1L,
                              null.ok = TRUE)
  raw_qstnr %>%
    purrr::chuck("response_options", type, lang, !!!subtypes) %>%
    pal::as_chr()
}

#' Questionnaire data
#'
#' A tibble containing the data of all FOKUS questionnaires.
#'
#' `qstnrs` was generated based on the following steps:
#'
#' 1. [gen_qstnr_tibble()] was run for all valid combinations of `canton` and `ballot_date`, some validation checks were performed, and the results were merged
#'    into a single tibble.
#' 2. List columns were [expanded][expand_qstnr_tibble] to [long format](https://en.wikipedia.org/wiki/Wide_and_narrow_data).
#' 3. Columns [`question_intro_i` and `question_intro_j`](https://rpkg.dev/fokus/articles/raw_qstnr_schema.html#supported-keys) were merged into the single
#'    column `question_intro`.
#' 4. Column [`question_full`](https://rpkg.dev/fokus/articles/raw_qstnr_schema.html#supported-keys) was complemented, i.e. made to fall back on `question` if
#'    `NA`.
#' 5. Columns [`question_common`](https://rpkg.dev/fokus/articles/raw_qstnr_schema.html#supported-keys) and
#'    [`variable_label_common`](https://rpkg.dev/fokus/articles/raw_qstnr_schema.html#supported-keys) were complemented, i.e. made to fall back on
#'    `question_full` and `variable_label` respectively if `NA`.
#' 6. Markdown formatting was [stripped][pal::strip_md] from all character columns.
#'
#' @family qstnr_survey
#' @format `r pkgsnip::return_label("data")`
#'
#' @examples
#' fokus::qstnrs
"qstnrs"

#' Proposal data
#'
#' A tibble containing basic referendum proposal data of all FOKUS questionnaires.
#'
#' @family qstnr_survey
#' @format `r pkgsnip::return_label("data")`
#'
#' @examples
#' fokus::proposals
"proposals"

#' Election data
#'
#' A tibble containing basic election data of all FOKUS questionnaires.
#'
#' @family qstnr_survey
#' @format `r pkgsnip::return_label("data")`
#'
#' @examples
#' fokus::elections
"elections"

#' Export questionnaire data
#'
#' Generates the [questionnaire tibble][gen_qstnr_tibble], the [Markdown questionnaire][gen_qstnr_md] and optionally a CSV, an HTML and an XLSX version of it,
#' and writes all of them to the [private FOKUS directory][print_fokus_private_structure] and optionally deploys them as a static site (`local_deploy_path`) and
#' uploads them to a Google Drive folder (`g_drive_folder`).
#'
#' @inheritParams gen_qstnr_tibble
#' @param verbose Whether or not to print detailed progress information during questionnaire generation and Google Drive file upload. Note that questionnaire
#'   generation takes considerably more time when this is set to `TRUE`.
#' @param incl_csv Whether or not to also generate and export a CSV version of the questionnaire.
#' @param incl_html Whether or not to also generate and export an HTML version of the questionnaire.
#' @param incl_xlsx Whether or not to also generate and export an XLSX version of the questionnaire.
#' @param deploy Whether or not to deploy the generated files as a static site to the Git repository specified under `local_deploy_path`.
#' @param local_deploy_path Local filesystem path to the Git repository of the static site to deploy the generated files files to. Ignored if `deploy = FALSE`.
#' @param upload_to_g_drive Whether or not to upload the generated files to the Google Drive folder `g_drive_folder`.
#' @param g_drive_folder Google Drive folder to deploy the generated files to. Ignored if `upload_to_g_drive = FALSE`.
#'
#' @family qstnr_survey
#' @export
export_qstnr <- function(ballot_date = all_ballot_dates,
                         canton = cantons(ballot_date),
                         verbose = FALSE,
                         incl_csv = TRUE,
                         incl_html = TRUE,
                         incl_xlsx = incl_html,
                         deploy = TRUE,
                         local_deploy_path = getOption("fokus.qstnr.local_deploy_path"),
                         upload_to_g_drive = TRUE,
                         g_drive_folder = "fokus/aargau/Umfragen/Dateien f\u00fcr Umfrageinstitut/Fragebogen/") {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  canton <- rlang::arg_match(canton,
                             values = cantons(ballot_date))
  checkmate::assert_flag(incl_csv)
  checkmate::assert_flag(incl_html)
  checkmate::assert_flag(incl_xlsx)
  if (incl_xlsx && !incl_html) {
    cli::cli_abort("{.arg incl_html} must be set to {.val TRUE} when {.code incl_xlsx = TRUE} because the XLSX file is generated from the HTML file.")
  }
  checkmate::assert_flag(deploy)
  checkmate::assert_string(local_deploy_path,
                           null.ok = TRUE)
  checkmate::assert_flag(upload_to_g_drive)
  pal::assert_pkg("rmarkdown")
  pal::assert_pkg("yay")
  
  md_path <- path_private(glue::glue("output/questionnaires/questionnaire_{ballot_date}_{canton}.md"))
  
  # Generate questionnaire tibble and Markdown version
  qstnr_tibble <- gen_qstnr_tibble(ballot_date = ballot_date,
                                   verbose = verbose)
  
  qstnr_tibble %>%
    gen_qstnr_md() %>%
    readr::write_lines(file = md_path)
  
  # create CSV version from tibble if requested
  if (incl_csv) {
    
    status_msg <- "Converting questionnaire tibble to CSV..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    csv_path <- md_path %>% fs::path_ext_set(ext = "csv")
    
    qstnr_tibble %>%
      clean_qstnr_tibble() %>%
      dplyr::mutate(variable_name_32 =
                      purrr::map2_chr(.x = variable_name,
                                      .y = dplyr::if_else(block %in% c("x_polling_agency", "y_generated", "z_generated")
                                                          | stringr::str_detect(string = variable_name,
                                                                                pattern = paste0("^", pal::fuse_regex(c("agreement_contra_argument_",
                                                                                                                        "information_source_",
                                                                                                                        "reason_non_participation_",
                                                                                                                        "political_occasions_")))),
                                                          32L,
                                                          30L),
                                      .f = ~ shorten_var_names(var_names = .x,
                                                               max_n_char = .y)),
                    .after = variable_name) %>%
      dplyr::select(-ends_with("_common"),
                    -c(lvl,
                       i,
                       j,
                       question_intro_i,
                       question_intro_j,
                       question_full)) %>%
      expand_qstnr_tibble() %>%
      readr::write_csv(file = csv_path,
                       na = "")
  }
  
  # create HTML version from Markdown questionnaire if requested
  if (incl_html) {
    
    html_path <- fs::path_ext_set(path = md_path,
                                  ext = "html")
    path_dir <- fs::path_dir(html_path)
    
    status_msg <- "Converting Markdown questionnaire to HTML using Pandoc..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    rmarkdown::pandoc_convert(input = md_path,
                              to = "html5",
                              from = "markdown",
                              output = html_path,
                              options = c("--standalone",
                                          "--css=github-pandoc.css",
                                          glue::glue('--metadata=title:FOKUS-{ stringr::str_to_sentence(canton) }-Fragebogen f\u00fcr den ',
                                                     ballot_title(ballot_date = ballot_date,
                                                                  canton = canton))),
                              verbose = FALSE)
    cli::cli_progress_done()
  }
  
  # create XLSX version from HTML questionnaire if requested
  if (incl_xlsx) {
    
    status_msg <- "Converting HTML questionnaire to XLSX using LibreOffice..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    system2(command = "flatpak",
            args = glue::glue("run --command=libreoffice",
                              "org.libreoffice.LibreOffice",
                              "--calc",
                              "--headless",
                              "--convert-to xlsx",
                              "--outdir \"{path_dir}\"",
                              "\"{html_path}\"",
                              .sep = " "),
            stdout = ifelse(verbose, "", FALSE))
    cli::cli_progress_done()
  }
  
  # deploy HTML to GitLab Pages if requested
  if (deploy) {
    
    status_msg <- "Deploying questionnaire to GitLab Pages..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    # TODO: either deploy to this pkg's pkgdown site or introduce pkg option for `to_path` instead of hardcoding it
    yay::deploy_static_site(from_path = path_dir,
                            to_path = "~/Arbeit/ZDA/Git/c2d-zda/c2d-zda.gitlab.io/public/",
                            clean_to_path = FALSE,
                            quiet = !verbose)
    cli::cli_progress_done()
  }
  
  # upload files to Google Drive for polling agency if requested
  if (upload_to_g_drive) {
    
    upload_to_g_drive(filepaths = c(md_path,
                                    csv_path[incl_csv],
                                    html_path[incl_html],
                                    fs::path(path_dir, "github-pandoc.css")[incl_html],
                                    fs::path_ext_set(path = html_path,
                                                     ext = "xlsx")[incl_xlsx]),
                      g_drive_folder = g_drive_folder,
                      quiet = !verbose)
  }
}

#' Export all questionnaires
#'
#' Exports *all* questionnaires, *softly* by default (i.e. without an XLSX version, without deploying as a static site and without uploading to Google Drive).
#'
#' Useful to efficiently test and inspect latest changes in generated questionnaire files.
#'
#' @inheritParams export_qstnr
#'
#' @family qstnr_survey
#' @export
export_qstnr_all <- function(verbose = FALSE,
                             incl_csv = TRUE,
                             incl_html = TRUE,
                             incl_xlsx = FALSE,
                             deploy = FALSE,
                             local_deploy_path = getOption("fokus.qstnr.local_deploy_path"),
                             upload_to_g_drive = FALSE,
                             g_drive_folder = "fokus/aargau/Umfragen/Dateien f\u00fcr Umfrageinstitut/Fragebogen/") {
  all_ballot_dates %>%
    magrittr::set_names(., .) %>%
    purrr::map(cantons) %>%
    purrr::iwalk(function(cantons, ballot_date) {
      
      cantons %>%
        purrr::walk(~ export_qstnr(ballot_date = ballot_date,
                                   canton = .x,
                                   verbose = verbose,
                                   incl_csv = incl_csv,
                                   incl_html = incl_html,
                                   incl_xlsx = incl_xlsx,
                                   deploy = deploy,
                                   local_deploy_path = local_deploy_path,
                                   upload_to_g_drive = upload_to_g_drive,
                                   g_drive_folder = g_drive_folder))
    })
}

#' Export QR codes with personalized survey URL
#'
#' Exports a ZIP file that contains a [QR code](https://en.wikipedia.org/wiki/QR_code) in SVG and in EPS format for each survey participant storing the
#' personalized survey URL to the [private FOKUS directory][print_fokus_private_structure].
#'
#' @inheritParams export_qstnr
#' @inheritParams upload_to_g_drive
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the contents of the created ZIP archive, invisibly.
#' @family qstnr_survey
#' @export
export_qr_codes <- function(ballot_date = all_ballot_dates,
                            canton = cantons(ballot_date),
                            upload_to_g_drive = TRUE,
                            g_drive_folder = "fokus/aargau/Umfragen/Dateien f\u00fcr Umfrageinstitut/QR-Codes/",
                            quiet = TRUE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  canton <- rlang::arg_match(canton,
                             values = cantons(ballot_date))
  checkmate::assert_flag(upload_to_g_drive)
  pal::assert_pkg("archive")
  pal::assert_pkg("qrencoder")
  pal::assert_pkg("rsvg")
  
  participation_codes <- read_online_participation_codes(ballot_date = ballot_date,
                                                         canton = canton)
  tmp_dir <-
    glue::glue("fokus_qr_codes_{ballot_date}_{canton}") %>%
    fs::path_temp() %>%
    fs::dir_create()
  
  on.exit(fs::dir_delete(tmp_dir))
  
  tmp_dir_svg <-
    fs::path(tmp_dir, "svg") %>%
    fs::dir_create()
  
  tmp_dir_eps <-
    fs::path(tmp_dir, "eps") %>%
    fs::dir_create()
  
  # create SVG and EPS image files
  status_msg <- "Generating {length(participation_codes)} personalized QR code{?s} in SVG and EPS format for canton {.val {canton}} @ {.val {ballot_date}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"),
                         .auto_close = FALSE)
  
  participation_codes %>%
    cli::cli_progress_along() %>%
    purrr::walk2(.x = participation_codes,
                 .y = .,
                 .f = ~ {
                   
                   path_svg <- fs::path(tmp_dir_svg, .x,
                                        ext = "svg")
                   # create SVG file
                   url <- url_survey_host %>% purrr::chuck(canton)
                   url_parameter <- url_parameter_survey %>% purrr::chuck(canton)
                   
                   qrencoder::qrencode_svg(to_encode = glue::glue("{url}?{url_parameter}={.x}"),
                                           level = 3L) %>%
                     readr::write_file(file = path_svg)
                   
                   # create EPS file from SVG file
                   rsvg::rsvg_eps(svg = path_svg,
                                  file = fs::path(tmp_dir_eps, .x,
                                                  ext = "eps"))
                 })
  
  cli::cli_progress_done()
  
  # create ZIP archive of SVG and EPS files
  status_msg <- "Compressing SVG and EPS QR code files to ZIP archive..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"),
                         .auto_close = FALSE)
  
  dir_output <- fs::dir_create(path_private("output/images/qr_codes"))
  path_zip <- fs::path(dir_output, glue::glue("{ballot_date}_{canton}.zip"))
  
  result <- archive::archive_write_dir(archive = path_zip,
                                       dir = tmp_dir,
                                       format = "zip")
  cli::cli_progress_done()
  
  # upload files to Google Drive for polling agency if requested
  if (upload_to_g_drive) {
    
    upload_to_g_drive(filepaths = path_zip,
                      g_drive_folder = g_drive_folder,
                      quiet = quiet)
  }
  
  invisible(result)
}

#' Export print recipients data
#'
#' Exports a CSV dataset containing the two columns `id` and `receives_print` to the [private FOKUS directory][print_fokus_private_structure].
#'
#' @inheritParams ballot_title
#'
#' @return `NULL` if no export for the specified ballot date is possible, otherwise a [tibble][tibble::tbl_df] of the exported data, invisibly.
#' @family qstnr_survey
#' @export
export_print_recipients <- function(ballot_date = all_ballot_dates,
                                    canton = cantons(ballot_date)) {
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  canton <- rlang::arg_match(canton,
                             values = cantons(ballot_date))
  
  # only export if `reminder_print_*` constraint present
  if (raw_qstnr_suppl_mode(ballot_date = ballot_date,
                           canton = canton) %>%
      purrr::pluck("constraints") %>%
      stringr::str_detect("^reminder_print_.+") %>%
      any()) {
    
    status_msg <- "Exporting print recipients data for canton {.val {canton}} @ {.val {ballot_date}}..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    # read in statistical office IDs used for current survey
    ids <- read_voting_register_ids(ballot_date = ballot_date,
                                    canton = canton)
    # ensure output folder exists
    fs::dir_create(path_private(glue::glue("output/data/polling_agency/{canton}")))
    
    # export data
    result <-
      read_voting_register_data_extra(ballot_date = ballot_date,
                                      canton = canton) %>%
      dplyr::filter(id %in% !!ids) %>%
      dplyr::mutate(receives_print = year_of_birth_official < 1970L) %>%
      dplyr::select(id, receives_print) %>%
      readr::write_csv(file = path_private(glue::glue("output/data/polling_agency/{canton}/{ballot_date}_print_recipients.csv")))
    
  } else {
    
    cli::cli_alert_info("No print recipients data export sensible or possible for canton {.val {canton}} @ {.val {ballot_date}}.")
    result <- NULL
  }
  
  invisible(result)
}

#' Export easyvote municipality details
#'
#' Exports a CSV dataset containing the columns `municipality`, `municipality_id`, `min_age` and `max_age` to the [private FOKUS
#' directory][print_fokus_private_structure].
#'
#' The meaning of the individual columns is as follows:
#'
#' | **column name** | **description** |
#' | --------------- | --------------- |
#' | `municipality` | official name of the municipality |
#' | `municipality_id` | [official Swiss community identification number](https://en.wikipedia.org/wiki/Community_Identification_Number#Switzerland) (also called "GEOSTAT"/"BFS" number, see the [corresponding German Wikipedia article](https://de.wikipedia.org/wiki/Gemeindenummer)) |
#' | `min_age` | `r var_lbl("easyvote_municipality_min_age")` |
#' | `max_age` | `r var_lbl("easyvote_municipality_max_age")` |
#'
#' @inheritParams export_qstnr
#' @inheritParams upload_to_g_drive
#'
#' @return A [tibble][tibble::tbl_df] of the exported data, invisibly.
#' @family qstnr_survey
#' @export
export_easyvote_municipalities <- function(ballot_date = all_ballot_dates,
                                           canton = cantons(ballot_date),
                                           upload_to_g_drive = TRUE,
                                           g_drive_folder = paste0("fokus/aargau/Umfragen/Dateien f\u00fcr Umfrageinstitut/",
                                                                   "easyvote-Gemeinden/"),
                                           quiet = TRUE) {
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(all_ballot_dates))
  canton <- rlang::arg_match(canton,
                             values = cantons(ballot_date))
  checkmate::assert_flag(upload_to_g_drive)
  
  path_csv <- path_private(glue::glue("output/data/polling_agency/{canton}/{ballot_date}_easyvote_municipalities.csv"))
  
  result <-
    read_easyvote_municipalities(ballot_date = ballot_date,
                                 canton = canton) %>%
    # assume 18-25 age range if both min/max age are NA
    dplyr::mutate(is_likely_default = is.na(min_age) & is.na(max_age),
                  min_age = dplyr::if_else(is_likely_default,
                                           18L,
                                           min_age),
                  max_age = dplyr::if_else(is_likely_default,
                                           25L,
                                           max_age)) %>%
    dplyr::select(-is_likely_default) %>%
    readr::write_csv(file = path_csv)
  
  if (upload_to_g_drive) {
    
    upload_to_g_drive(filepaths = path_csv,
                      g_drive_folder = g_drive_folder,
                      quiet = quiet)
  }
  
  invisible(result)
}

#' Determine whether variable is skill question
#'
#' Determines for each variable whether or not it is a skill question.
#'
#' Note that the determination is performed by simply parsing `var_names`.
#'
#' @param var_names A character vector of FOKUS variable names.
#'
#' @return A logical vector of the same length as `var_names`.
#' @family vars
#' @export
is_skill_question_var <- function(var_names) {
  
  var_names %>%
    checkmate::assert_character() %>%
    stringr::str_detect(pattern = "^skill_question_\\d+_(cantonal|federal)(_proposal_\\d+)?$")
}

#' Get variable label
#'
#' Extracts a variable's (common) label from the [questionnaire data][qstnrs].
#'
#' If no `ballot_date` and `canton` are specified, [`variable_label_common`](https://rpkg.dev/fokus/articles/raw_qstnr_schema.html#supported-keys) is returned,
#' otherwise [`variable_label`](https://rpkg.dev/fokus/articles/raw_qstnr_schema.html#supported-keys). Note that `ballot_date` and `canton` either must both be
#' `NULL` or set to a valid canton name and ballot date respectively.
#'
#' @param var_name Variable name. A character scalar.
#' @param ballot_date `NULL` or a FOKUS-covered ballot date, i.e. one of
#' `r pal::as_md_val_list(as.character(all_ballot_dates))`
#' @param canton `NULL` or a canton name, i.e. one of
#' `r pal::as_md_val_list(all_cantons)`
#'
#' @return A character scalar.
#' @family vars
#' @export
#'
#' @examples
#' # if `ballot_date` and `canton` are not supplied, `variable_label_common` is returned:
#' fokus::var_lbl("participation_federal")
#'
#' # otherwise `variable_label`:
#' fokus::var_lbl(var_name = "participation_federal",
#'                ballot_date = "2018-09-23",
#'                canton = "aargau")
#'             
#' fokus::var_lbl(var_name = "participation_federal",
#'                ballot_date = "2019-10-20",
#'                canton = "aargau")
var_lbl <- function(var_name,
                    ballot_date = NULL,
                    canton = NULL) {
  
  assert_var_names(var_names = var_name,
                   as_scalar = TRUE)
  
  is_common <- is.null(ballot_date) && is.null(canton)
  
  if (is_common) {
    
    result <-
      fokus::qstnrs %>%
      dplyr::filter(variable_name == !!var_name) %$%
      variable_label_common
    
  } else {
    
    is_arg_invalid <- purrr::map_lgl(list(ballot_date, canton),
                                     is.null)
    arg_names <- c("ballot_date", "canton")
    
    if (any(is_arg_invalid)) {
      cli::cli_abort(paste0("Either {.arg ballot_date} and {.arg canton} must both be {.val NULL} or set to a valid canton name and ballot date, but ",
                            "{.arg {arg_names[is_arg_invalid]}} is {.val NULL} while {.arg {arg_names[!is_arg_invalid]}} is ",
                            "{.val {get(arg_names[!is_arg_invalid])}}."))
    }
    
    result <-
      fokus::qstnrs %>%
      dplyr::filter(canton == !!canton
                    & ballot_date == !!ballot_date
                    & variable_name == !!var_name) %$%
      variable_label
  }
  
  (checkmate::assert_string(unique(result),
                            na.ok = TRUE,
                            .var.name = ifelse(is_common,
                                               "variable_label_common",
                                               "variable_label")))
}

#' Determine variable's political level(s)
#'
#' Determines a variable's political level(s).
#'
#' Note that the political levels are determined by simply parsing `var_name`.
#'
#' @inheritParams var_lbl
#'
#' @return A character vector of political levels, of length 0 if no specific levels could be determined.
#' @family vars
#' @export
#'
#' @examples
#' fokus::var_lvls("skill_question_1_cantonal_proposal_1")
var_lvls <- function(var_name) {
  
  checkmate::assert_string(var_name,
                           na.ok = TRUE)
  
  is_cantonal <- var_name %>% stringr::str_detect(pattern = "cantonal")
  is_federal <- var_name %>% stringr::str_detect(pattern = "federal")
  
  c("cantonal"[is_cantonal], "federal"[is_federal])
}

#' Determine variable's proposal number
#'
#' Determines the proposal number each variable corresponds to. In case no proposal number could be determined for a variable, `NA_character` is returned.
#'
#' @inherit is_skill_question_var details
#'
#' @inheritParams is_skill_question_var
#'
#' @return An integer vector of the same length as `var_names`.
#' @family vars
#' @export
var_proposal_nr <- function(var_names) {
  
  var_names %>%
    checkmate::assert_character() %>%
    stringr::str_extract("(?<=_proposal_)\\d+") %>%
    as.integer()
}

#' Determine variable's skill question number
#'
#' Determines the skill question number each variable corresponds to. In case no skill question number could be determined for a variable, `NA_character` is
#' returned.
#'
#' @inherit var_proposal_nr details return
#'
#' @inheritParams is_skill_question_var
#'
#' @family vars
#' @export
var_skill_question_nr <- function(var_names) {
  
  var_names %>%
    checkmate::assert_character() %>%
    stringr::str_extract("(?<=skill_question_)\\d+") %>%
    as.integer()
}

#' Shorten variable names to a maximum length of 32 characters
#'
#' @param var_names A character vector of variable names.
#' @param reverse Whether to apply the inversion of the shortening logic, i.e. to restore original/unshortened variable names.
#' @param max_n_char Maximum allowed number of characters. Either `NULL` to skip the check or otherwise an integerish scalar in which case it is ensured that 
#'   the maximum resulting variable name length doesn't exceed it. Doesn't have any influence on the applied shortening logic.
#'
#' @return A character vector of the same length as `var_names`.
#' @family var_name_shortening
#' @export
shorten_var_names <- function(var_names,
                              reverse = FALSE,
                              max_n_char = 32L) {
  
  checkmate::assert_character(var_names,
                              any.missing = FALSE)
  checkmate::assert_flag(reverse)
  checkmate::assert_count(max_n_char,
                          null.ok = TRUE)
  rules <- shortening_rules
  
  if (reverse) colnames(rules) %<>% .[c(2L, 1L, 3L)]
  
  rules %<>% dplyr::mutate(pattern = purrr::map2_chr(
    .x = string,
    .y = allowed_at,
    .f = ~ .y %>% pal::when(. == "begin" ~
                              paste0("^", .x, "(?=_)"),
                            . == "middle" ~
                              paste0("(?<=_)", .x, "(?=_)"),
                            . == "end" ~
                              paste0("(?<=_)", .x, "$"),
                            . == "begin-middle" ~
                              paste0("(?<=(^|_))", .x, "(?=_)"),
                            . == "begin-end" ~
                              paste0("(^", .x, "(?=_)|(?<=_)", .x, "$)"),
                            . == "middle-end" ~
                              paste0("(?<=_)", .x, "(?=(_|$))"),
                            . == "begin-middle-end" ~
                              paste0("(?<=(^|_))", .x, "(?=(_|$))"),
                            ~ cli::cli_abort("Unknown {.var allowed_at} type: {.val {.}}.",
                                             .internal = TRUE))
  ))
  
  pattern_replacement <- rules$replacement
  names(pattern_replacement) <- rules$pattern
  
  var_names_new <- var_names %>% stringr::str_replace_all(pattern = pattern_replacement)
  
  # ensure we did our job
  if (!is.null(max_n_char) && !reverse && any(nchar(var_names_new) > max_n_char)) {
    
    # NOTE: `cli::cli_abort()` doesn't properly print the output of `pal::capture_print()` because:
    #        - it just seems to ignore the output if it includes ANSI escape sequences (this can be worked around by an additional `cli::ansi_strip()`)
    #        - it normalizes whitespace chars **incl. tabs** to a single regular whitespace, thus breaking the formatting
    rlang::abort(glue::glue("There are still variable names left of a length greater than {max_n_char} characters after applying `shorten_var_names()`. ",
                            "Affected are the following (shortened) variable names:\n\n",
                            tibble::tibble(var_name = var_names,
                                           var_name_short = var_names_new,
                                           n_char = nchar(var_names),
                                           n_char_short = nchar(var_names_new)) %>%
                              dplyr::filter(n_char_short > max_n_char) %>%
                              pal::capture_print(collapse = "\n"),
                            .null = NA_character_,
                            .trim = FALSE))
  }
  
  var_names_new
}

#' Shorten column names to a maximum length of 32 characters
#'
#' This is useful for DTA export since Stata has a built-in variable name length limit of [32
#' characters](https://www.stata.com/manuals/r.pdf#rLimits) (see also
#' [here](https://www.statalist.org/forums/forum/general-stata-discussion/general/1452366-number-of-characters-in-variable-names)).
#'
#' @inheritParams shorten_var_names
#' @param x `r pkgsnip::param_label("tabular_data")`
#'
#' @return `x` with column names shortened to a maximum length of 32 characters.
#' @family var_name_shortening
#' @export
shorten_colnames <- function(x,
                             max_n_char = 32L) {
  
  x %>% magrittr::set_colnames(value = shorten_var_names(var_names = colnames(x),
                                                         max_n_char = max_n_char))
}

#' Restore original/unshortened column names
#'
#' Applies the inversion of [shorten_colnames()].
#'
#' @inheritParams shorten_colnames
#' @inheritParams shorten_var_names
#'
#' @return `x` with original/unshortened column names restored.
#' @family var_name_shortening
#' @export
restore_colnames <- function(x) {
  
  x %>% magrittr::set_colnames(value = shorten_var_names(var_names = colnames(x),
                                                         reverse = TRUE))
}

#' Transform ballot type into prose string
#'
#' Transforms a [ballot type][all_ballot_types] into a full prose string representation.
#'
#' @inheritParams lvls
#' @inheritParams proposal_name
#'
#' @return A character scalar.
#' @family prose
#' @export
#'
#' @examples
#' fokus::all_ballot_types |>
#'   purrr::map(~ tibble::tibble(type = .x,
#'                               de = fokus::ballot_type_prose(ballot_type = .x,
#'                                                             lang = "de"),
#'                               en = fokus::ballot_type_prose(ballot_type = .x,
#'                                                             lang = "en"))) %>%
#'   purrr::list_rbind()
ballot_type_prose <- function(ballot_type = all_ballot_types,
                              lang = c("de", "en")) {
  
  ballot_type <- rlang::arg_match(ballot_type)
  lang <- rlang::arg_match(lang)
  
  switch(EXPR = lang,
         de = switch(EXPR = ballot_type,
                     referendum = "Abstimmungen",
                     election = "Wahlen"),
         en = switch(EXPR = ballot_type,
                     referendum = "referendums",
                     election = "elections"))
}

#' Transform postal dispatch type into prose string
#'
#' Transforms a [postal dispatch type][all_postal_dispatch_types] into a full prose string representation.
#'
#' @inheritParams postal_dispatch_way
#' @inheritParams proposal_name
#'
#' @return A character scalar.
#' @family prose
#' @export
#'
#' @examples
#' fokus::all_postal_dispatch_types |>
#'   purrr::map(~ tibble::tibble(type = .x,
#'                               de = fokus::postal_dispatch_type_prose(dispatch_type = .x,
#'                                                                      lang = "de"),
#'                               en = fokus::postal_dispatch_type_prose(dispatch_type = .x,
#'                                                                      lang = "en"))) %>%
#'   purrr::list_rbind()
postal_dispatch_type_prose <- function(dispatch_type = all_postal_dispatch_types,
                                       lang = c("de", "en")) {
  
  dispatch_type <- rlang::arg_match(dispatch_type)
  lang <- rlang::arg_match(lang)
  
  switch(EXPR = lang,
         de = switch(EXPR = dispatch_type,
                     invitation = "Einladungsschreiben",
                     reminder = "Erinnerungsschreiben",
                     prepaid_reply_envelope = "vorfrankiertes R\u00fcckantwortcouvert"),
         en = switch(EXPR = dispatch_type,
                     invitation = "invitation letter",
                     reminder = "reminder letter",
                     prepaid_reply_envelope = "prepaid reply envelope"))
}

#' Transform postal dispatch way into prose string
#'
#' Transforms a [postal dispatch way][postal_dispatch_way] into a full prose string representation.
#'
#' @inheritParams proposal_name
#' @param dispatch_way Postal dispatch way One of
#' `r pal::as_md_val_list(all_postal_dispatch_ways)`
#'
#' @return A character scalar.
#' @family prose
#' @export
#'
#' @examples
#' fokus::postal_dispatch_way(ballot_date = "2018-09-23",
#'                            canton = "aargau",
#'                            dispatch_type = "invitation") |>
#'   fokus::postal_dispatch_way_prose()
postal_dispatch_way_prose <- function(dispatch_way = all_postal_dispatch_ways,
                                      lang = c("de", "en")) {
  
  dispatch_way <- rlang::arg_match(dispatch_way)
  lang <- rlang::arg_match(lang)
  
  switch(EXPR = lang,
         de = switch(EXPR = dispatch_way,
                     "A" = "A-Post",
                     "B" = "B-Post",
                     "B bulk mailing" = "B-Post-Massensendung"),
         en = switch(EXPR = dispatch_way,
                     "A" = "A priority mail",
                     "B" = "B mail",
                     "B bulk mailing" = "B bulk mailing"))
}

#' Authorize googledrive using GCP Service Account Key
#'
#' Authorizes the googledrive package to access and manage files on your Google Drive via a [Google Cloud Platform (GCP) Service
#' Account Key](https://cloud.google.com/iam/docs/creating-managing-service-account-keys) file (in JSON format). See the [relevant googledrive
#' documentation](https://gargle.r-lib.org/articles/non-interactive-auth.html#provide-a-service-account-token-directly) for details.
#'
#' The recommended way to provide the filesystem path to the GCP Service Account Key file is to set the [environment
#' variable](https://en.wikipedia.org/wiki/Environment_variable) `PATH_GCP_KEY_ZDA` to that path, e.g. via the [`.Renviron`
#' file](https://rstats.wtf/r-startup.html#renviron).
#'
#' @param path_gcp_service_account_key Path to the GCP Service Account Key JSON file.
#'
#' @return `path_gcp_service_account_key`, invisibly.
#' @family g_apps
#' @keywords internal
auth_g_drive_gcp <- function(path_gcp_service_account_key = Sys.getenv("PATH_GCP_KEY_ZDA")) {
  
  pal::assert_pkg("googledrive")
  is_file <- checkmate::test_file_exists(path_gcp_service_account_key,
                                         access = "r")
  
  if (is_file) {
    googledrive::drive_auth(path = path_gcp_service_account_key,
                            use_oob = TRUE)
    
  } else {
    cli::cli_abort(paste0("No Google Cloud Platform service account key found under {.path {path_gcp_service_account_key}}. ",
                          "Instructions to store such a key can be found here: ",
                          "{.url https://gargle.r-lib.org/articles/non-interactive-auth.html#provide-a-service-account-token-directly}"))
  }
  
  invisible(path_gcp_service_account_key)
}

#' Authorize googlesheets4 using GCP Service Account Key
#'
#' Authorizes the googlesheets4 package to access and manage Google Sheets via a [Google Cloud Platform (GCP) Service
#' Account Key](https://cloud.google.com/iam/docs/creating-managing-service-account-keys) file (in JSON format). See the [relevant googledrive
#' documentation](https://gargle.r-lib.org/articles/non-interactive-auth.html#provide-a-service-account-token-directly) for details.
#'
#' The recommended way to provide the filesystem path to the GCP Service Account Key file is to set the [environment
#' variable](https://en.wikipedia.org/wiki/Environment_variable) `PATH_GCP_KEY_ZDA` to that path, e.g. via the [`.Renviron`
#' file](https://rstats.wtf/r-startup.html#renviron).
#'
#' @param path_gcp_service_account_key Path to the GCP Service Account Key JSON file.
#'
#' @return `path_gcp_service_account_key`, invisibly.
#' @family g_apps
#' @keywords internal
auth_g_sheets_gcp <- function(path_gcp_service_account_key = Sys.getenv("PATH_GCP_KEY_ZDA")) {
  
  pal::assert_pkg("googledrive")
  is_file <- checkmate::test_file_exists(path_gcp_service_account_key,
                                         access = "r")
  
  if (is_file) {
    googledrive::drive_auth(path = path_gcp_service_account_key,
                            use_oob = TRUE)
    
  } else {
    # TODO: Remove the intermittent `url` assignment as soon as [issue #370](https://github.com/r-lib/cli/issues/370) is resolved.
    url <- "https://gargle.r-lib.org/articles/non-interactive-auth.html#provide-a-service-account-token-directly"
    
    cli::cli_abort(paste0("No Google Cloud Platform service account key found under {.path {path_gcp_service_account_key}} ",
                          "Instructions to store such a key can be found here: ",
                          "{.url {url}}"))
  }
  
  invisible(path_gcp_service_account_key)
}

#' Backup Google Drive file locally
#'
#' Creates a local backup of a [Google Drive](https://en.wikipedia.org/wiki/Google_Drive) file.
#' 
#' Essentially a convenience wrapper around [googledrive::drive_download()].
#'
#' If a [Google Sheet](https://en.wikipedia.org/wiki/Google_Sheets) that includes multiple worksheets is backed up to a file `type` that doesn't support
#' worksheets like `"csv"`, only the default (first) worksheet is written. In contrast, [backup_g_sheet()] allows to specify any worksheet to be backed up (but
#' always writes a single worksheet only regardless of the filetype).
#'
#' @inheritParams g_file_mod_time 
#' @inheritParams upload_to_g_drive
#' @param path Path to the local file backup destination. A character scalar.
#' @param type Desired type of the Google Drive file to be backed up. Only consulted if `g_id` identifies a native Google Apps file. Will be processed via
#'   [googledrive::drive_mime_type()], so it can either be a file extension like `"pdf"`, a full MIME type like `"application/pdf"`, or `NULL` to determine the
#'   type based on the file extension of `path` (if none is specified, falls back on the default type determined by the [Google Drive
#'   API](https://developers.google.com/drive/api/v3/)). Note that `type` takes precedence over a possible file extension of `path`, but specifying only the
#'   latter should normally suffice.
#' @param overwrite Whether or not to overwrite an already existing file under `path`.
#' @param force Whether or not to force overwriting the file regardless whether it has changed since the last backup or not.
#'
#' @return An object of class [dribble][googledrive::dribble], a tibble with one row per file if local backup was (over)written, otherwise `NULL`, meaning
#'   the remote file hasn't deviated from the local backup since the last run, invisibly.
#' @family g_apps
#' @export
backup_g_file <- function(g_id,
                          path,
                          type = NULL,
                          path_gcp_service_account_key = Sys.getenv("PATH_GCP_KEY_ZDA"),
                          overwrite = TRUE,
                          force = FALSE,
                          quiet = TRUE) {
  
  checkmate::assert_string(g_id)
  checkmate::assert_path_for_output(path,
                                    overwrite = TRUE)
  checkmate::assert_flag(overwrite)
  checkmate::assert_flag(force)
  checkmate::assert_flag(quiet)
  pal::assert_pkg("googledrive")
  
  if (quiet) {
    googledrive::local_drive_quiet()
  }
  
  result <- NULL
  remote_mod <- g_file_mod_time(g_id,
                                path_gcp_service_account_key = path_gcp_service_account_key)
  local_mod <- ifelse(fs::file_exists(path),
                      pal::path_mod_time(path),
                      lubridate::as_datetime(0L))
  
  if (local_mod < remote_mod || force) {
    
    result <- googledrive::drive_download(file = googledrive::as_id(g_id),
                                          path = path,
                                          type = type,
                                          overwrite = overwrite)
  }
  
  invisible(result)
}

#' Backup Google Sheet locally
#'
#' Creates a local backup of a [Google Sheet](https://en.wikipedia.org/wiki/Google_Sheets). It is accessed via [googlesheets4::read_sheet()] and written via
#' [readr::write_csv()] or [writexl::write_xlsx()], depending on the file extension of `path`.
#'
#' `backup_g_sheet()` only backs up a single worksheet at once (specified by the optional `sheet` argument). If you intend to backup multiple worksheets of the
#' same Google Sheet, consider using [backup_g_file()] in combination with a file `type` that supports multiple worksheets like `"ods"` or `"xlsx"`.
#'
#' @inheritParams backup_g_file
#' @inheritParams googlesheets4::read_sheet
#' @param ... Further arguments passed on to [googlesheets4::read_sheet()].
#' @param quiet Whether or not to [suppress printing status output from googledrive][googledrive::local_drive_quiet] and [googlesheets4
#'   operations][googlesheets4::local_gs4_quiet].
#'
#' @return A [tibble][tibble::tbl_df] if the local backup was (over)written, otherwise `NULL`, meaning the remote file hasn't deviated from the local backup
#'   since the last run, invisibly.
#' @family g_apps
#' @export
backup_g_sheet <- function(g_id,
                           path,
                           ...,
                           path_gcp_service_account_key = Sys.getenv("PATH_GCP_KEY_ZDA"),
                           overwrite = TRUE,
                           force = FALSE,
                           quiet = TRUE) {
  
  checkmate::assert_string(g_id)
  checkmate::assert_path_for_output(path,
                                    overwrite = TRUE)
  checkmate::assert_flag(overwrite)
  checkmate::assert_flag(force)
  checkmate::assert_flag(quiet)
  pal::assert_pkg("googledrive")
  pal::assert_pkg("googlesheets4")
  
  pal::check_dots_named(...,
                        .fn = googlesheets4::read_sheet,
                        .forbidden = "ss")
  if (quiet) {
    googledrive::local_drive_quiet()
    googlesheets4::local_gs4_quiet()
  }
  
  # authenticate Google account
  auth_g_drive_gcp(path_gcp_service_account_key)
  
  # ensure `g_id` refers to a spreadsheet
  mime_type <-
    googledrive::drive_get(id = g_id) %$%
    drive_resource %>%
    dplyr::first() %$%
    mimeType
  
  if (mime_type != "application/vnd.google-apps.spreadsheet") {
    
    cli::cli_abort("The supplied {.arg g_id} {.val {g_id}} doesn't seem to refer to a Google Sheet. Its Google Drive MIME type is {.val {mime_type}}.")
  }
  
  data <- NULL
  remote_mod <- g_file_mod_time(g_id,
                                path_gcp_service_account_key = path_gcp_service_account_key)
  local_mod <- ifelse(fs::file_exists(path),
                      pal::path_mod_time(path),
                      lubridate::as_datetime(0L))
  
  if (local_mod < remote_mod || force) {
    
    # authenticate Google account
    auth_g_sheets_gcp(path_gcp_service_account_key)
    
    filetype <- fs::path_ext(path)
    data <- googlesheets4::read_sheet(ss = g_id,
                                      ...)
    
    if (overwrite || !fs::file_exists(path)) {
      
      filetype %>%
        pal::when(. == "csv" ~
                    readr::write_csv(x = data,
                                     file = path,
                                     na = ""),
                  
                  . == "xlsx" ~ {
                    pal::assert_pkg("writexl")
                    writexl::write_xlsx(x = data,
                                        path = path)
                  },
                  
                  . == "" ~
                    cli::cli_abort("{.arg path} must have a file extension ({.file .csv} or {.file .xlsx})."),
                  
                  ~ cli::cli_abort("Exporting filetype {.file {.}} not yet implemented."))
      
    } else {
      cli::cli_alert_warning("A file already exists under {.arg path} {.file {path}} but {.arg overwrite} was set to {.val FALSE}. Nothing done.")
    }
  }
  
  invisible(data)
}

#' Upload files to Google Drive
#'
#' Uploads one or more files to Google Drive.
#' 
#' Essentially a convenience wrapper around [googledrive::drive_put()].
#'
#' @inheritParams g_file_mod_time
#' @param filepaths Local path(s) to the file(s) to be uploaded.
#' @param g_drive_folder Destination path on Google Drive where the files are to be uploaded to.
#' @param quiet Whether or not to [suppress printing status output from googledrive operations][googledrive::local_drive_quiet].
#'
#' @return `filepaths`, invisibly.
#' @family g_apps
#' @export
upload_to_g_drive <- function(filepaths,
                              g_drive_folder = "fokus/aargau/",
                              path_gcp_service_account_key = Sys.getenv("PATH_GCP_KEY_ZDA"),
                              quiet = FALSE) {
  
  checkmate::assert_character(filepaths,
                              any.missing = FALSE)
  checkmate::assert_string(g_drive_folder)
  checkmate::assert_flag(quiet)
  
  # mute googledrive msgs if requested
  if (quiet) googledrive::local_drive_quiet()
  
  # extract filenames
  filenames <- fs::path_file(filepaths)
  
  # authenticate Google account
  auth_g_drive_gcp(path_gcp_service_account_key)
  
  # upload files
  status_msg <- "Uploading {length(filepaths)} file{?s} to Google Drive folder {.path {g_drive_folder}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  purrr::walk2(.x = filenames,
               .y = filepaths,
               .f = ~ {
                 # overwrite existing file if possible or create new one otherwise
                 googledrive::drive_put(media = .y,
                                        path = g_drive_folder,
                                        name = .x)
               })
  
  invisible(filepaths)
}

#' Get Google Drive file modification timestamp
#'
#' @param g_id Google Drive file ID. A character scalar.
#' @param path_gcp_service_account_key Path to the GCP Service Account Key JSON file. See [auth_g_drive_gcp()] for details.
#'
#' @return `r pkgsnip::return_label("datetime")`
#' @family g_apps
#' @export
g_file_mod_time <- function(g_id,
                            path_gcp_service_account_key = Sys.getenv("PATH_GCP_KEY_ZDA")) {
  
  auth_g_drive_gcp(path_gcp_service_account_key = path_gcp_service_account_key)
  
  googledrive::drive_get(id = g_id) %$%
    drive_resource %>%
    dplyr::first() %$%
    modifiedTime %>%
    lubridate::as_datetime()
}

#' Emphasize xth element of character vector (Markdown)
#'
#' @param x Input as a character vector.
#' @param which Indices of the elements to be emphasized.
#' @param emph Character sequence used for emphasis.
#'
#' @return A character vector of the same length as `x`.
#' @export
md_emphasize <- function(x,
                         which = TRUE,
                         emph = "**") {
  
  x[which] %<>% paste0(emph, ., emph)
  x
}

#' Convert logical vector to Unicode symbols `r unicode_checkmark` and `r unicode_crossmark`
#'
#' @param x A logical vector.
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' fokus::lgl_to_unicode(c(TRUE, TRUE, FALSE, NA))
lgl_to_unicode <- function(x) {
  
  checkmate::assert_logical(x)
  
  dplyr::if_else(x,
                 unicode_checkmark,
                 unicode_crossmark)
}
