# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/fokus.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# fokus: Provides an API around the FOKUS Post-voting Surveys
# Copyright (C) 2021 Centre for Democracy Studies Aarau (ZDA)
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

.onUnload <- function(libpath) {
  
  pkgpins::deregister(pkg = this_pkg)
}

.onLoad <- function(libname, pkgname) {
  
  pkgpins::clear(pkg = pkgname,
                 max_age = getOption(paste0(pkgname, ".global_cache_lifespan"),
                                     default = global_cache_lifespan))
}

utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "all_of",
                                 "ends_with",
                                 "everything",
                                 "where",
                                 # other
                                 "alignment",
                                 "allowed",
                                 "block",
                                 "enumerator",
                                 "enumerator_base",
                                 "has_same_length",
                                 "has_auto_fallback",
                                 "length_response_options",
                                 "length_value_labels",
                                 "length_variable_values",
                                 "matches_length",
                                 "n_cantonal_majoritarian_elections",
                                 "n_cantonal_proportional_elections",
                                 "n_cantonal_proposals",
                                 "n_char_short",
                                 "n_federal_majoritarian_elections",
                                 "n_federal_proportional_elections",
                                 "n_federal_proposals",
                                 "name",
                                 "nr",
                                 "question",
                                 "response_options",
                                 "separator",
                                 "string",
                                 "topic",
                                 "value_labels",
                                 "variable_name",
                                 "variable_values",
                                 "who",
                                 "width"))

# avoid notes about "possible error"s when using non-exported rex shortcuts, cf. https://github.com/kevinushey/rex#using-rex-in-other-packages
rex::register_shortcuts(pkg_name = utils::packageName())

path_private <- function(rel_path) {
  
  dir_private <- getOption("fokus.path_private",
                           default = switch(EXPR = Sys.info()[["user"]],
                                            "salim" = "~/Arbeit/ZDA/Git/zdaarau/private/fokus_private/",
                                            # fall back to current working directory
                                            getwd()))
  
  # ensure path is valid (read access plus file `data/aargau/survey_data_2018-09-23.xlsx` exists)
  is_valid_path <-
    checkmate::test_directory(dir_private, access = "r") && fs::file_exists(path = fs::path(dir_private, "data/aargau/survey_data_2018-09-23.xlsx"))
  
  if (!is_valid_path) {
    
    is_opt_set <- !is.null(getOption("fokus.path_private"))
    
    cli::cli_abort(paste0(dplyr::if_else(is_opt_set,
                                         "The option {.field fokus.path_private} is set to: {.path {dir_private}}\n\n",
                                         "The option {.field fokus.path_private} is unset, thus we fall back to: {.path {dir_private}}\n\n"),
                          "This doesn't seem to be a valid FOKUS working directory. Please correct this in order for this package to work properly."))
  }
  
  fs::path(dir_private, rel_path)
}

opts <- function(pretty_colnames = FALSE) {
  
  tibble::tibble(name = "fokus.path_private",
                 description = paste0("the path to the working directory (the local instance of the ",
                                      "[`fokus_private` repository](https://gitlab.com/zdaarau/private/fokus_private)); initialized automatically for ",
                                      "user=salim, otherwise defaults to the current working directory"),
                 has_auto_fallback = TRUE) |>
    tibble::add_row(name = "fokus.global_cache_lifespan",
                    description = glue::glue("the default cache lifespan for all functions taking a `cache_lifespan` argument; defaults to ",
                                             global_cache_lifespan),
                    has_auto_fallback = TRUE) |>
    purrr::when(checkmate::assert_flag(pretty_colnames) ~ dplyr::rename(.data = .,
                                                                        "automatic fallback if unset" = has_auto_fallback),
                ~ .)
}

print_opts <- function() {
  
  opts(pretty_colnames = TRUE) |>
    dplyr::mutate(name = paste0("`", name, "`"),
                  dplyr::across(all_of("automatic fallback if unset"),
                                lgl_to_unicode)) |>
    pal::pipe_table()
}

#' Raw FOKUS questionnaire data
#'
#' A structured list of the raw questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @seealso [`raw_qx_suppl`][raw_qx_suppl] [`raw_q_suppl`][raw_q_suppl] [`raw_q_suppl_lvl`][raw_q_suppl_lvl] [`raw_q_suppl_lvl_canton`][raw_q_suppl_lvl_canton] 
#'   [`raw_q_suppl_proposal`][raw_q_suppl_proposal] [`raw_q_suppl_election`][raw_q_suppl_election] [`raw_q_suppl_skill_questions`][raw_q_suppl_skill_questions]
#'   [`raw_q_suppl_skill_question`][raw_q_suppl_skill_question]
#' @keywords internal
"raw_q"

#' Raw supplemental date-specific FOKUS questionnaire data
#'
#' A structured list of raw supplemental date-specific questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @seealso [`raw_q`][raw_q] [`raw_q_suppl`][raw_q_suppl] [`raw_q_suppl_lvl`][raw_q_suppl_lvl] [`raw_q_suppl_lvl_canton`][raw_q_suppl_lvl_canton]
#'   [`raw_q_suppl_proposal`][raw_q_suppl_proposal] [`raw_q_suppl_election`][raw_q_suppl_election] [`raw_q_suppl_skill_questions`][raw_q_suppl_skill_questions]
#'   [`raw_q_suppl_skill_question`][raw_q_suppl_skill_question]
#' @keywords internal
#'
#' @examples
#' fokus:::raw_qx_suppl[["2018-09-23"]]$mode
"raw_qx_suppl"

#' Get raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][raw_qx_suppl] for the specified ballot date.
#'
#' @inheritParams ballot_types
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl(ballot_date = "2018-09-23") %$% mode
raw_q_suppl <- function(ballot_date = ballot_dates) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  raw_qx_suppl[[ballot_date]]
}

#' Get a political level's raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl] for the specified ballot date and political level.
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return seealso
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_lvl(ballot_date = "2018-09-23",
#'                         lvl = "cantonal") |>
#'   names()
raw_q_suppl_lvl <- function(ballot_date = ballot_dates,
                            lvl = c("cantonal", "federal")) {
  
  lvl <- rlang::arg_match(lvl)
  
  result <- raw_q_suppl(ballot_date = ballot_date) %>% purrr::pluck(lvl)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    
    cli::cli_abort("No {.val {lvl}} level present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  result
}

#' Get a canton's political-level-specific raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data for the specified ballot date and political level][raw_q_suppl_lvl]
#' that applies for the specified canton only.
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_lvl_canton(ballot_date = "2018-09-23",
#'                                lvl = "cantonal",
#'                                canton = "aargau") |>
#'   names()
raw_q_suppl_lvl_canton <- function(ballot_date = ballot_dates,
                                   lvl = c("cantonal", "federal"),
                                   canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  
  result <-
    raw_q_suppl_lvl(ballot_date = ballot_date,
                    lvl = lvl) %>%
    purrr::pluck(canton)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    
    cli::cli_abort("No {.val {lvl}} supplemental {.val {ballot_date}} FOKUS questionnaire data present for canton {.val {canton}}.")
  }
  
  result
}

#' Get raw proposal supplemental questionnaire data
#'
#' Returns a structured list of a proposal's data from the [supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_proposal(ballot_date = "2018-09-23",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              proposal_nr = 1) %$%
#'   name
raw_q_suppl_proposal <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr) {
  
  lvl <- rlang::arg_match(lvl)
  proposal_nr <- assert_countish(proposal_nr)
  
  proposals <-
    lvl %>%
    purrr::when(. == "federal" ~
                  raw_q_suppl_lvl(ballot_date = ballot_date,
                                  lvl = .),
                ~ raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                                         lvl = .,
                                         canton = canton)) %>%
    purrr::pluck("proposal")
  
  if (is.null(proposals)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} proposals present",
                          " for {.val {canton}}"[lvl == "cantonal"],
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  proposal <- proposals %>% purrr::pluck(as.character(proposal_nr))
  
  if (is.null(proposal)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} proposal {.val {proposal_nr}} present",
                          " for {.val {canton}}"[lvl == "cantonal"],
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  proposal
}

#' Get a proposal's raw name supplemental questionnaire data
#'
#' Returns a structured list of proposal name data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_proposal_name(ballot_date = "2018-11-25",
#'                                   lvl = "cantonal",
#'                                   canton = "aargau",
#'                                   proposal_nr = 2)
raw_q_suppl_proposal_name <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("name")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No names present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get a proposal's raw argument supplemental questionnaire data
#'
#' Returns a structured list of argument data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::proposal_main_motives(ballot_date = "2018-11-25",
#'                               lvl = "cantonal",
#'                               canton = "aargau",
#'                               proposal_nr = 2)
raw_q_suppl_arguments <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("argument")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No arguments present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get a proposal's raw main motive supplemental questionnaire data
#'
#' Returns a structured list of main motive data from the [proposal-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_proposal].
#'
#' @inheritParams proposal_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::proposal_main_motives(ballot_date = "2018-11-25",
#'                               lvl = "cantonal",
#'                               canton = "aargau",
#'                               proposal_nr = 2)
raw_q_suppl_main_motives <- function(ballot_date = ballot_dates,
                                     lvl = c("cantonal", "federal"),
                                     canton = cantons,
                                     proposal_nr = 1L) {
  result <-
    raw_q_suppl_proposal(ballot_date = ballot_date,
                         lvl = lvl,
                         canton = canton,
                         proposal_nr = proposal_nr) %>%
    purrr::pluck("main_motive")
  
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No main motives present for {.val {lvl}} proposal {.val {proposal_nr}} ",
                          "in {.val {canton}} "[lvl == "cantonal"],
                          "in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get raw supplemental election questionnaire data
#'
#' Returns a structured list of election data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl_canton].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_elections(ballot_date = "2019-10-20",
#'                               lvl = "cantonal",
#'                               canton = "aargau") %$%
#'   skill_questions_source
raw_q_suppl_elections <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons) {
  result <-
    raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton) %>%
    purrr::pluck("election")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get an election's raw supplemental questionnaire data
#'
#' Returns a structured list of an election's data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl_canton].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_election(ballot_date = "2019-10-20",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              prcd = "majoritarian") %$%
#'   n_seats
raw_q_suppl_election <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 prcd = c("proportional", "majoritarian"),
                                 election_nr = 1L) {
  
  prcd <- rlang::arg_match(prcd)
  election_nr <- assert_countish(election_nr)
  
  result <-
    raw_q_suppl_elections(ballot_date = ballot_date,
                          lvl = lvl,
                          canton = canton) %>%
    purrr::pluck(prcd)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS ",
                          "questionnaire data."))
  }
  
  result %<>% purrr::pluck(as.character(election_nr))
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} election {.val {election_nr}} for canton {.val {canton}} present in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get raw supplemental election name questionnaire data
#'
#' Returns a structured list of an election's name data from the [political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][raw_q_suppl_lvl].
#'
#' @inheritParams election_name
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_election_name(ballot_date = "2019-10-20",
#'                                   lvl = "cantonal",
#'                                   canton = "aargau",
#'                                   prcd = "majoritarian")
raw_q_suppl_election_name <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      prcd = c("proportional", "majoritarian"),
                                      election_nr = 1L) {
  lvl <- rlang::arg_match(lvl)
  prcd <- rlang::arg_match(prcd)
  election_nr <- assert_countish(election_nr)
  
  # federal proportional election names are defined once for all cantons together
  if (lvl == "federal" && prcd == "proportional") {
    
    result <-
      raw_q_suppl_lvl(ballot_date = ballot_date,
                      lvl = lvl) %>%
      purrr::chuck("election", prcd, as.character(election_nr))
    
  } else {
    
    result <- raw_q_suppl_election(ballot_date = ballot_date,
                                   lvl = lvl,
                                   canton = canton,
                                   prcd = prcd,
                                   election_nr = election_nr)
  }
  
  result %<>% purrr::pluck("name")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No names present for {.val {lvl}} {.val {prcd}} election {.val {election_nr}} in canton {.val {canton}} in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get raw supplemental skill question questionnaire data
#'
#' Returns a structured list of skill question data from the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, non-proposal-specific skill question data is returned.
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_skill_questions(ballot_date = "2018-09-23",
#'                                     lvl = "cantonal",
#'                                     canton = "aargau",
#'                                     proposal_nr = 1) |>
#'   purrr::map_depth(1L, "de") |>
#'   purrr::flatten_chr()
raw_q_suppl_skill_questions <- function(ballot_date = ballot_dates,
                                        lvl = c("cantonal", "federal"),
                                        canton = cantons,
                                        proposal_nr = NULL) {
  lvl <- rlang::arg_match(lvl)
  
  result <-
    lvl %>%
    purrr::when(
      
      # federal non-proposal-specific skill questions (e.g. at federal elections)
      length(proposal_nr) == 0L && . == "federal" ~
        raw_q_suppl_lvl(ballot_date = ballot_date,
                        lvl = .),
      # cantonal non-proposal-specific skill questions (e.g. at cantonal elections)
      length(proposal_nr) == 0L && . == "cantonal" ~
        raw_q_suppl_lvl_canton(ballot_date = ballot_date,
                               lvl = .,
                               canton = canton),
      # federal or cantonal proposal-specific skill questions
      ~ raw_q_suppl_proposal(ballot_date = ballot_date,
                             lvl = .,
                             canton = canton,
                             proposal_nr = proposal_nr)) %>%
    purrr::pluck("skill_question")
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No skill questions present",
                          dplyr::if_else(length(proposal_nr) == 0L,
                                         paste0(" on the {.val {lvl}} level",
                                                " for {.val {canton}}"[lvl == "cantonal"]),
                                         " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get a single skill question's raw supplemental questionnaire data
#'
#' Returns a structured list of a single skill question's data from the [raw supplemental date-specific FOKUS questionnaire data][raw_q_suppl].
#'
#' @inheritParams skill_question
#'
#' @inherit raw_q_suppl return
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
#'
#' @examples
#' fokus:::raw_q_suppl_skill_question(ballot_date = "2018-09-23",
#'                                    lvl = "cantonal",
#'                                    canton = "aargau",
#'                                    proposal_nr = 1,
#'                                    skill_question_nr = 1)
raw_q_suppl_skill_question <- function(ballot_date = ballot_dates,
                                       lvl = c("cantonal", "federal"),
                                       canton = cantons,
                                       proposal_nr = NULL,
                                       skill_question_nr) {
  
  skill_question_nr <- assert_countish(skill_question_nr)
  
  result <-
    raw_q_suppl_skill_questions(ballot_date = ballot_date,
                                lvl = lvl,
                                canton = canton,
                                proposal_nr = proposal_nr) %>%
    purrr::pluck(skill_question_nr)
  
  if (is.null(result)) {
    
    # reduce to proper arg values for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    lvl <- rlang::arg_match(lvl)
    canton <- rlang::arg_match(canton)
    
    cli::cli_abort(paste0("No skill question {.val {skill_question_nr}} present",
                          dplyr::if_else(length(proposal_nr) == 0L,
                                         paste0(" on the {.val {lvl}} level", " for {.val {canton}}"[lvl == "cantonal"]),
                                         " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data. Only {length(skill_questions)} skill questions included."))
  }
  
  result
}

#' Pick right raw questionnaire value
#'
#' Picks the right value of a certain raw questionnaire key based on ballot date and canton (recursively).
#'
#' @param x Questionnaire key. A list object.
#' @inheritParams ballot_types
#'
#' @return Value of `x` that corresponds to `canton` and `ballot_date`.
#' @seealso Raw questionnaire data [`raw_q`][raw_q] [`raw_qx_suppl`][raw_qx_suppl]
#' @family q_raw
#' @keywords internal
raw_pick_right <- function(x,
                           ballot_date,
                           canton) {
  
  # force evaluation of `ballot_date` and `canton` to ensure immediate error (with better msg) in case they are missing
  ballot_date
  canton
  
  if (purrr::vec_depth(x) > 1L) {
    
    x <-
      pick_right_helper(x = x,
                        ballot_date = ballot_date,
                        canton = canton) %>%
      raw_pick_right(ballot_date = ballot_date,
                     canton = canton)
    
  }
  
  x
}

pick_right_helper <- function(x,
                              ballot_date,
                              canton) {
  
  if (purrr::is_list(x) && (length(x) > 1L || purrr::vec_depth(x) > 1L)) {
    
    # create plain ballot date as in subkeys
    ballot_date_squeezed <- stringr::str_remove_all(string = ballot_date,
                                                    pattern = "-")
    # convert ballot date to type date
    ballot_date %<>% lubridate::as_date()
    
    # handle begin-end date subkeys
    begin_end_subkeys <-
      names(x) %>%
      stringr::str_subset(pattern = "^\\d+_\\d+$")
    
    matches_begin_end_subkeys <-
      begin_end_subkeys %>%
      purrr::map_lgl(function(x) {
        
        begin <- x %>% stringr::str_extract(pattern = "^\\d+") %>% lubridate::as_date()
        end <- x %>% stringr::str_extract(pattern = "\\d+$") %>% lubridate::as_date()
        
        begin <= ballot_date && ballot_date <= end
      })
    
    # integrity check: ensure there aren't any overlapping intervals
    if (length(which(matches_begin_end_subkeys)) > 1L) {
      
      cli::cli_abort("Illegal overlapping interval subkeys found: {.var {begin_end_subkeys[matches_begin_end_subkeys]}}\n\nPlease fix this and run again.")
    }
    
    ballot_types <- ballot_types(ballot_date = ballot_date,
                                 canton = canton)
    
    x <- names(x) %>% purrr::when(
      
      # consider overrides for binary keys
      ballot_date %in% x[["false"]] ~ FALSE,
      ballot_date %in% x[["true"]] ~ TRUE,
      
      # consider overrides for non-binary keys
      ## single date subkey
      ballot_date_squeezed %in% . ~ x[[ballot_date_squeezed]],
      ## begin-end date subkey
      length(which(matches_begin_end_subkeys)) > 0L ~ x[[begin_end_subkeys[matches_begin_end_subkeys]]],
      
      # consider overrides for ballot types (we take the first one in case of ambiguity)
      any(ballot_types %in% .) ~ x[[intersect(., ballot_types)[1L]]],
      
      # return default value if defined
      "default" %in% . ~ x[["default"]],
      
      # return TRUE in any remaining cases (implicit `include`)
      ~ TRUE
    )
  }
  
  x
}

add_who_constraint <- function(x,
                               who) {
  if (who != "all") {
    
    result <- who %>% purrr::when(stringr::str_detect(string = x, pattern = "\\)$") ~
                                    stringr::str_replace(string = x,
                                                         pattern = "\\)$",
                                                         replacement = paste0("; only *", ., "*)")),
                                  ~ paste0(x, " (only *", ., "*)"))
  } else {
    
    result <- x
  }
  
  result
}

assemble_q_tibble <- function(ballot_date,
                              canton,
                              raw_q_branch,
                              q_lvl,
                              heritable_map,
                              verbose) {
  
  map <- heritable_map %>% complement_heritable_map(from = raw_q_branch)
  result <- NULL
  
  if ("variable_name" %in% names(raw_q_branch)) {
    
    if (verbose) cli::cli_progress_step(".. ITEM: {.var {map$variable_name}}")
    
    result <- assemble_q_item_tibble(ballot_date = ballot_date,
                                     canton = canton,
                                     item_map = map,
                                     verbose = verbose)
    
  } else if (purrr::vec_depth(raw_q_branch) > 2L) {
    
    if (verbose && dplyr::last(stringr::str_split(q_lvl, "\\.")[[1L]]) == "item") {
      cli::cli_progress_step("Q TABLE LVL: {.val {q_lvl}}")
    }
    
    result <- purrr::map2_dfr(.x = raw_q_branch,
                              .y = names(raw_q_branch) %||% seq_along(raw_q_branch),
                              .f = ~ assemble_q_tibble(ballot_date = ballot_date,
                                                       canton = canton,
                                                       raw_q_branch = .x,
                                                       q_lvl = paste(q_lvl, .y,
                                                                     sep = "."),
                                                       heritable_map = map,
                                                       verbose = verbose))
  }
  
  result
}

assemble_q_item_tibble <- function(ballot_date,
                                   canton,
                                   item_map,
                                   verbose) {
  # iterate over `lvl`...
  purrr::map_dfr(
    .x = resolve_q_val(x = item_map$lvl,
                       ballot_date = ballot_date,
                       canton = canton,
                       key = "lvl",
                       lvl = "",
                       i = "",
                       j = NA_integer_),
    .f = function(lvl) {
      # ...`i`...
      purrr::map_dfr(
        .x = resolve_q_val(x = item_map$i,
                           ballot_date = ballot_date,
                           canton = canton,
                           key = "i",
                           lvl = lvl,
                           i = "",
                           j = NA_integer_),
        lvl = lvl,
        .f = function(i,
                      lvl) {
          # ...and `j`
          purrr::map_dfr(
            .x = resolve_q_val(x = item_map$j,
                               ballot_date = ballot_date,
                               canton = canton,
                               key = "j",
                               lvl = lvl,
                               i = i,
                               j = NA_integer_),
            i = i,
            lvl = lvl,
            .f = function(j,
                          i,
                          lvl) {
              
              # respect keys `include` and `ballot_types`
              is_incl <- resolve_q_val(x = item_map$include,
                                       ballot_date = ballot_date,
                                       canton = canton,
                                       key = "include",
                                       lvl = lvl,
                                       i = i,
                                       j = j)
              has_ballot_type <-
                resolve_q_val(x = item_map$ballot_types,
                              ballot_date = ballot_date,
                              canton = canton,
                              key = "ballot_types",
                              lvl = lvl,
                              i = i,
                              j = j) %>%
                intersect(ballot_types(ballot_date = ballot_date,
                                       canton = canton)) %>%
                rlang::is_empty() %>%
                magrittr::not()
              
              result <- NULL
              
              if (is_incl && has_ballot_type) {
                
                # resolve all keys in item map
                result <-
                  names(item_map) %>%
                  setdiff(c("lvl",
                            "i",
                            "j",
                            "ballot_types",
                            "include")) %>%
                  magrittr::set_names(x = .,
                                      value = .) %>%
                  purrr::map(~ {
                    
                    if (verbose) cli::cli_progress_step(".. .. KEY: {.field {.x}}")
                    
                    resolve_q_val(x = item_map[[.x]],
                                  ballot_date = ballot_date,
                                  canton = canton,
                                  key = .x,
                                  lvl = lvl,
                                  i = i,
                                  j = j) %>%
                      purrr::when(
                        # replace empty scalars with NA
                        length(.) == 0L && .x %in% q_item_keys$key[q_item_keys$is_scalar] ~
                          .[NA],
                        # wrap vectors in list
                        .x %in% q_item_keys$key[!q_item_keys$is_scalar] ~
                          list(.),
                        ~ .
                      )
                  })
                
                # handle special cases
                ## 1: fill empty non-iterator multi-value keys with NA(s) if all other non-empty multi-value keys have the same length
                lengths_multi_val_keys <-
                  q_item_keys_multival %>%
                  magrittr::set_names(., .) %>%
                  purrr::map_int(~ length(result[[.x]][[1L]]))
                
                positive_lengths_multi_val_keys <-
                  lengths_multi_val_keys %>%
                  magrittr::extract(. > 0L)
                
                if (any(lengths_multi_val_keys == 0L) && length(unique(positive_lengths_multi_val_keys)) == 1L) {
                  
                  for (k in (lengths_multi_val_keys %>%
                             magrittr::extract(. == 0L) %>%
                             names())) {
                    
                    result[[k]] <- list(rep(result[[k]][[1L]][NA],
                                            times = length(result[[names(positive_lengths_multi_val_keys)[1L]]][[1L]])))
                  }
                }
                
                ## 2: if no `question_common` is defined, fall back on `question.default` if it exists and actually differs from `question`
                if (is.na(result$question_common) && "default" %in% names(item_map$question)) {
                  
                  default_question <- resolve_q_val(x = item_map$question$default,
                                                    ballot_date = ballot_date,
                                                    canton = canton,
                                                    key = "question",
                                                    lvl = lvl,
                                                    i = i,
                                                    j = j)
                  
                  if (isTRUE(default_question != result$question)) {
                    result$question_common <- default_question
                  }
                }
                
                ## 3: if no `variable_label_common` is defined, fall back on `variable_label.default` if it exists and actually differs from `variable_label`
                if (is.na(result$variable_label_common) && "default" %in% names(item_map$variable_label)) {
                  
                  default_variable_label <- resolve_q_val(x = item_map$variable_label$default,
                                                          ballot_date = ballot_date,
                                                          canton = canton,
                                                          key = "variable_label",
                                                          lvl = lvl,
                                                          i = i,
                                                          j = j)
                  
                  if (isTRUE(default_variable_label != result$variable_label)) {
                    result$variable_label_common <- default_variable_label
                  }
                }
                
                ## 4: add `who`-constraint to `variable_label` and `variable_label_common`
                ### get English `who` value
                who_en <-
                  raw_q$who %>%
                  purrr::detect(~ .x$value$de == stringr::str_replace(string = result$who,
                                                                      pattern = "\\d+",
                                                                      replacement = "{i}")) %>%
                  purrr::chuck("value", "en") %>%
                  cli::pluralize(.trim = FALSE)
                
                ### add who-constraints
                if (!is.na(result$variable_label_common) && !has_who_constraint(result$variable_label_common)) {
                  
                  # ensure `who` doesn't vary over time
                  if (length(item_map$who) > 1L) {
                    cli::cli_abort(paste0("{.field who} of variable {.var {result$variable_name}} has changed over time. Thus an explicit {.field who}-",
                                          "constraint has to be specified at the end of {.field variable_label_common} in the raw {.file questionnaire.toml}."))
                  }
                  result$variable_label_common %<>% add_who_constraint(who = who_en)
                }
                result$variable_label %<>% add_who_constraint(who = who_en)
              }
              
              # convert result to tibble
              tibble::as_tibble(result)
            })
        })
    })
}

complement_heritable_map <- function(x,
                                     from) {
  names <- names(x)
  
  x %>%
    purrr::map2(.x = names,
                .y = .,
                .f = function(k, v) purrr::pluck(.x = from,
                                                 k,
                                                 .default = v)) %>%
    magrittr::set_names(names)
}

expand_q_tibble <- function(q_tibble) {
  
  # run integrity checks...
    validate_q_tibble(q_tibble) %>%
    # ...expand questionnaire data to long format...
    tidyr::unnest(cols = any_of(q_item_keys_multival))
}

#' Generate questionnaire tibble
#'
#' @inheritParams ballot_types
#' @param verbose Whether or not to print progress information during questionnaire generation.
#'
#' @return `r pkgsnip::return_label("data")`
#' @family q_gen
#' @keywords internal
gen_q_tibble <- function(ballot_date = ballot_dates,
                         canton = cantons,
                         verbose = FALSE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  checkmate::assert_flag(verbose)
  
  status_msg <- "Generating questionnaire tibble for canton {.val {canton}} @ {.val {ballot_date}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  purrr::map2_dfr(.x = raw_q,
                  .y = names(raw_q),
                  .f = ~ {
                    
                    if (verbose && !(.y %in% q_non_item_lvls)) cli::cli_h1("BLOCK: {.val {.y}}")
                    
                    assemble_q_tibble(ballot_date = ballot_date,
                                      canton = canton,
                                      raw_q_branch = .x,
                                      q_lvl = .y,
                                      heritable_map = init_heritable_map(block = .y),
                                      verbose = verbose)
                  }) %>%
    # add ballot date and canton
    dplyr::mutate(ballot_date = !!ballot_date,
                  canton = !!canton,
                  .before = 1L)
}

has_who_constraint <- function(x) {
  
  isTRUE(stringr::str_detect(string = x,
                             pattern = "(\\(|; )(\\d{4}-\\d{2}-\\d{2} )?only [^\\)]+\\)$"))
}

init_heritable_map <- function(block) {
  
  xfun::strict_list(lvl = "?",
                    i = "?",
                    j = NA_integer_,
                    block = block,
                    variable_name = "???",
                    topic = NULL,
                    who = NULL,
                    question = NULL,
                    question_common = NULL,
                    multiple_answers_allowed = FALSE,
                    variable_label = NULL,
                    variable_label_common = NULL,
                    response_options = NULL,
                    variable_values = NULL,
                    value_labels = NULL,
                    value_scale = "nominal",
                    randomize_response_options = FALSE,
                    ballot_types = c("referendum", "election"),
                    include = TRUE)
}

interpolate_q_val <- function(vals,
                              ballot_date,
                              canton,
                              key,
                              lvl,
                              i,
                              j) {
  
  if (key %in% q_item_keys$key[q_item_keys$is_scalar]) {
    
    vals <- cli::pluralize(vals,
                           .trim = FALSE)
  } else {
    
    vals %<>%
      purrr::map(.f = glue::glue,
                 .envir = environment(),
                 .trim = FALSE) %>%
      unlist()
  }
  
  vals
}

resolve_q_val <- function(x,
                          ballot_date,
                          canton,
                          key,
                          lvl,
                          i,
                          j) {
  
  checkmate::assert_scalar(lvl, null.ok = TRUE)
  checkmate::assert_scalar(i, null.ok = TRUE)
  checkmate::assert_scalar(j, na.ok = TRUE, null.ok = TRUE)
  
  x %>%
    raw_pick_right(ballot_date = ballot_date,
                   canton = canton) %>%
    purrr::when(is.character(.) ~ interpolate_q_val(.,
                                                    ballot_date = ballot_date,
                                                    canton = canton,
                                                    key = key,
                                                    lvl = lvl,
                                                    i = i,
                                                    j = j),
                ~ .) %>%
    # convert to proper type
    purrr::when(
      # character
      key %in% q_item_keys$key[q_item_keys$type == "character"] ~
        as.character(.),
      # logical
      key %in% q_item_keys$key[q_item_keys$type == "logical"] ~
        as.logical(.),
      # integer
      key %in% q_item_keys$key[q_item_keys$type == "integer"] ~
        as.integer(.),
      # double (theoretical only, none present so far)
      key %in% q_item_keys$key[q_item_keys$type == "double"] ~
        as.double(.),
      # undefined behaviour
      ~ cli::cli_abort("Undefined behaviour in {.fun resolve_q_val}. Please debug.")
    )
}

clean_q_tibble <- function(q_tibble) {
  
  q_tibble %>%
    # remove (single) placeholders
    dplyr::mutate(dplyr::across(any_of(q_item_keys_multival) & where(~ is.character(.x[[1L]])),
                                ~ .x %>% purrr::map(~ { if (length(.x) == 1L && isTRUE(stringr::str_detect(.x, "^_.+_$"))) character() else .x }))) %>%
    # strip MD
    dplyr::mutate(dplyr::across(where(is.character),
                                pal::strip_md),
                  dplyr::across(where(is.list) & where(~ is.character(.x[[1L]])),
                                ~ .x %>% purrr::map(pal::strip_md)))
}

validate_q_tibble <- function(q_tibble) {
  
  # integrity check 1: ensure there are no duplicated topics, variable names and variable labels
  c("topic",
    "variable_name",
    "variable_label") %>%
    purrr::walk(.f = function(v) {
      
      is_dup <- duplicated(q_tibble[[v]])
      
      if (any(is_dup)) {
        
        dup_indices <- which(is_dup)
        
        for (i in dup_indices) {
          
          dup_v <- q_tibble[[v]][i]
          
          cli::cli_alert_danger(paste0("{.var {v}} {.val {dup_v}} is included more than once in the questionnaire."))
        }
      }
    })
  
  # integrity check 2: ensure all multi-value columns have the same length or alternatively are empty, and if not, tell which ones don't
  multi_val_v_lengths <-
    q_tibble %>%
    dplyr::transmute(dplyr::across(where(is.list),
                                   purrr::map_int,
                                   length)) %>%
    dplyr::rename_with(~ paste0("length_", .x)) %>%
    dplyr::mutate(matches_length = length_variable_values == 0L | length_value_labels == 0L | length_variable_values == length_value_labels) %>%
    dplyr::mutate(matches_length =
                    matches_length & (length_response_options == 0L | length_value_labels == 0L | length_response_options == length_value_labels),
                  matches_length =
                    matches_length & (length_response_options == 0L | length_variable_values == 0L | length_response_options == length_variable_values))
  
  i_violated <- which(!multi_val_v_lengths$matches_length)
  
  if (length(i_violated)) {
    
    multi_val_v_names <-
      q_tibble %>%
      dplyr::select(where(is.list)) %>%
      colnames()
    
    # print affected variable names first since long error msg gets truncated
    cli::cli({
      cli::cli_alert_danger("Affected variable names:")
      cli::cli_ul(items = q_tibble$variable_name[i_violated])
    })
    
    cli::cli_abort(paste0("The number of {.var {multi_val_v_names}} differs for the variable names listed above."))
  }
  
  invisible(q_tibble)
}

#' Generate Markdown questionnaire
#'
#' @inheritParams ballot_types
#' @param incl_title Whether or not to generate an `<h1>` questionnaire title at the beginning of the document. If the result is intended to be fed to Pandoc,
#'   it's recommended to set this to `FALSE` and provide the title via [Pandoc's `--metadata` option](https://pandoc.org/MANUAL.html#option--metadata) instead.
#'
#' @return A character vector.
#' @family q_gen
#' @keywords internal
gen_q_md <- function(q_tibble,
                     incl_title = FALSE) {
  
  # ensure we have a single ballot date and canton
  ballot_date <-
    q_tibble %$%
    ballot_date %>%
    unique() %>%
    checkmate::assert_string(.var.name = "ballot_date")
  canton <-
    q_tibble %$%
    canton %>%
    unique() %>%
    checkmate::assert_string(.var.name = "canton")
  
  status_msg <- "Generating Markdown questionnaire for canton {.val {canton}} @ {.val {ballot_date}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  block_lines <-
    q_tibble %>%
    # add block title and across-block item enumerator base/group
    dplyr::mutate(enumerator_base =
                    block %>%
                    purrr::map_int(~ raw_q %>% purrr::pluck(.x, "prefix",
                                                            .default = 0L))) %>%
    # add across-block item enumerator
    dplyr::group_by(enumerator_base) %>%
    dplyr::group_modify(~ tibble::rowid_to_column(.x,
                                                  var = "enumerator")) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(enumerator = enumerator_base + enumerator) %>%
    dplyr::arrange(block, enumerator) %>%
    # iterate over every block and generate block header plus table
    dplyr::group_by(block) %>%
    dplyr::group_map(~ {
      
      block <- .y$block
      block_nr <- block_name_to_nr(block)
      block_title <- raw_q %>% purrr::chuck(block, "title")
      block_intro <-
        raw_q %>%
        purrr::pluck(block, "intro") %>%
        raw_pick_right(ballot_date = ballot_date,
                       canton = canton) %>%
        cli::pluralize(.trim = FALSE)
      
      c(glue::glue("## Block {block_nr}: {block_title}"),
        "",
        block_intro,
        ""[length(block_intro)],
        q_md_table_header(),
        q_md_table_body(q_tibble_block = .x,
                        block = block),
        "",
        "")
    }) %>%
    purrr::flatten_chr()
  
  # add title, technical notes, introduction, footnotes and link references
  title <- paste0("# FOKUS-Aargau-Fragebogen f\u00fcr den ",
                  ballot_title(ballot_date = ballot_date,
                               canton = canton),
                  "\n")
  
  technical_notes <-
    raw_q %$%
    who %>%
    # reduce to who's that actually occur in data
    purrr::keep(~ .x$value$de %>%
                  stringr::str_replace(pattern = "\\{i\\}",
                                       replacement = "\\d+") %>%
                  stringr::str_detect(string = q_tibble$who,
                                      pattern = .) %>%
                  any()) %>%
    # assemble who lines
    purrr::map_depth(.depth = 1L,
                     .f = ~ {
                       
                       i <-
                         .x[["i"]] %>%
                         glue::glue(.trim = FALSE) %>%
                         as.integer()
                       
                       value <-
                         .x$value$de %>%
                         glue::glue(.trim = FALSE) %>%
                         md_emphasize()
                       
                       description <-
                         .x$description$de %>%
                         glue::glue(.trim = FALSE)
                       
                       glue::glue("- {value}: {description}")
                     }) %>%
    purrr::flatten_chr() %>%
    c("## Technische Vorbemerkungen",
      "",
      "### `Wer`",
      "",
      "Die Spalte `Wer` dient dem Fragebogen-Routing. Sie kennt folgende Werte:",
      "",
      .,
      "",
      md_snippets$q_technical_notes_multiple_responses,
      md_snippets$q_technical_notes_free_text_fields)
  
  footnotes <-
    raw_q$footnote %>%
    # reduce to footnotes that actually occur in table body
    purrr::keep(~ any(stringr::str_detect(block_lines, glue::glue("\\[\\^{.x$id}\\]")))) %>%
    purrr::map(~ c(glue::glue("[^{.x$id}]: {.x$text}"), "")) %>%
    purrr::flatten_chr()
  
  link_refs <-
    raw_q$link %>%
    # reduce to link references that actually occur in table body
    purrr::keep(~ any(stringr::str_detect(block_lines, glue::glue("\\[[^]]+\\]\\[{.x$id}\\]")))) %>%
    purrr::map(~ c(glue::glue("[{.x$id}]: {.x$url}"), "")) %>%
    purrr::flatten_chr()
  
  c(title[incl_title],
    technical_notes,
    md_snippets$q_introduction,
    block_lines,
    footnotes,
    link_refs)
}

q_md_table_header <- function() {
  
  tibble::tribble(
    ~name,                                         ~width, ~alignment,
    "\\#",                                         2L,     "left",
    "Thema",                                       5L,     "left",
    "Wer",                                         3L,     "left",
    "Frage",                                       15L,    "left",
    "Mehrfachnennungen",                           3L,     "left",
    "Variablenname",                               5L,     "left",
    "Variablenname (gek\u00fcrzt auf 32 Zeichen)", 5L,     "left",
    "Variablenlabel",                              15L,    "left",
    "Antwortoptionen",                             5L,     "left",
    "Variablenauspr\u00e4gungen",                  5L,     "left",
    "Auspr\u00e4gungslabels",                      5L,     "left",
    "Antwortoptionen in Zufallsreihenfolge",       3L,     "left"
  ) %>%
    dplyr::mutate(separator =
                    purrr::map2_chr(.x = width,
                                    .y = alignment,
                                    .f = ~
                                      rep(x = "-",
                                          times = .x) %>%
                                      paste0(collapse = "") %>%
                                      purrr::when(.y == "left" ~ stringr::str_replace(string = .,
                                                                                      pattern = "^.",
                                                                                      replacement = ":"),
                                                  .y == "right" ~ stringr::str_replace(string = .,
                                                                                       pattern = ".$",
                                                                                       replacement = ":"),
                                                  .y == "center" ~ stringr::str_replace_all(string = .,
                                                                                            pattern = "(^.|.$)",
                                                                                            replacement = ":"),
                                                  ~ .))) %$%
    c(paste0(name, collapse = " | "),
      paste0(separator, collapse = " | "))
}

q_md_table_body <- function(q_tibble_block,
                            block) {
  
  q_tibble_block %>%
    # replace logicals by German ja/nein
    dplyr::mutate(dplyr::across(where(is.logical),
                                ifelse,
                                "ja",
                                "nein")) %>%
    purrr::pmap_chr(function(ballot_date,
                             canton,
                             enumerator,
                             topic,
                             who,
                             question,
                             multiple_answers_allowed,
                             variable_name,
                             variable_label,
                             response_options,
                             variable_values,
                             value_labels,
                             randomize_response_options,
                             ...) {
      paste(enumerator,
            tidyr::replace_na(topic,
                              "-"),
            who,
            tidyr::replace_na(question,
                              "-"),
            multiple_answers_allowed,
            pal::wrap_chr(variable_name,
                          wrap = "`"),
            shorten_v_names(v_names = variable_name,
                            max_n_char = dplyr::if_else(block %in% c("x_publitest", "y_generated", "z_generated")
                                                        || stringr::str_detect(string = variable_name,
                                                                               pattern = paste0("^", pal::fuse_regex(c("agreement_contra_argument_",
                                                                                                                       "information_source_",
                                                                                                                       "reason_non_participation_",
                                                                                                                       "political_occasions_")))),
                                                        32L,
                                                        30L)) %>%
              pal::wrap_chr("`"),
            variable_label,
            response_options %>%
              purrr::when(length(.) == 1L && is.na(.) ~
                            "-",
                          is_skill_question(variable_name) ~
                            md_emphasize(x = .,
                                         which = skill_question_answer_nr(ballot_date = ballot_date,
                                                                          lvl = v_lvls(v_name = variable_name),
                                                                          canton = canton,
                                                                          proposal_nr =
                                                                            variable_name %>%
                                                                            stringr::str_extract("(?<=_proposal_)\\d+") %>%
                                                                            purrr::when(is.na(.) ~ NULL,
                                                                                        ~ .),
                                                                          skill_question_nr =
                                                                            variable_name %>%
                                                                            stringr::str_extract("(?<=skill_question_)\\d+"))) %>%
                            collapse_break(),
                          ~ format_md_multival_col(.)),
            format_md_multival_col(variable_values),
            format_md_multival_col(value_labels),
            randomize_response_options,
            sep = " | ")
    })
}

format_md_multival_col <- function(x) {
  
  result <- x
  
  if (length(x) == 1L && is.na(x)) {
    
    result <- "-"
    
  } else if (length(x) > 1L
             && all(stringr::str_detect(string = x,
                                        pattern = "^_.+_$",
                                        negate = TRUE),
                    na.rm = TRUE)) {
    
    result <- x %>% pal::wrap_chr(wrap = "`") %>% collapse_break()
  }
  
  result
}

block_name_to_nr <- function(x) {
  
  x %>%
    stringr::str_extract("^.[^_]?(_\\d)?") %>%
    stringr::str_replace("_(\\d)", "-\\1") %>%
    stringr::str_remove("^0") %>%
    stringr::str_to_upper()
}

#' Extract questionnaire item field value
#'
#' Extracts a single questionnaire item field value for every first- for every second-level iterator from the [raw FOKUS questionnaire data][raw_q] based on the
#' specified variable name and branch path.
#' 
#' When used in questionnaire item field values via [string interpolation][glue::glue], be careful to not create infinite loops via circular references.
#'
#' @inheritParams ballot_types
#' @param v_name Variable name, without resolved string interpolation, i.e. 1:1 as stated in the raw FOKUS questionnaire data. A character scalar.
#' @param branch_path Sequence of questionnaire table levels that lead to the `item` leaf node where `v_name` is defined. A character vector.
#' @param key Questionnaire item key. One of
#' `r pal::as_md_list(paste0('"', q_item_keys$key, '"'), wrap = '``')`
#' @param i First-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. A character vector.
#' @param j Second-level loop iterator that can be referred to in field value via [string interpolation][glue::glue]. A character vector.
#'
#' @return A vector of the resolved item field values. Type and length resolved values depend on `key`.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_item_val(ballot_date = "2018-09-23",
#'                    canton = "aargau",
#'                    branch_path = c("03_proposal_specific", "004_participants"),
#'                    v_name = "appeal_federal_proposals",
#'                    key = "include")
#'
#' fokus:::q_item_val(
#'   ballot_date = "2019-10-20",
#'   canton = "aargau",
#'   branch_path = c("02_political_start", "002_non_participation",
#'                   "003_election", "z01_hypothetical"),
#'   v_name = "hypothetical_voting_decision_federal_majoritarian_election_{i}_seat_{j}",
#'   key = "topic",
#'   i = 1:2,
#'   j = 1:3
#' )
q_item_val <- function(ballot_date = ballot_dates,
                       canton = cantons,
                       branch_path,
                       v_name,
                       key = q_item_keys$key,
                       lvl = "?",
                       i = "?",
                       j = NA_integer_) {
  
  checkmate::assert_character(branch_path,
                              any.missing = FALSE,
                              min.len = 1L)
  checkmate::assert_string(v_name)
  key <- rlang::arg_match(key)
  
  # traverse questionnaire branch path and complement inheritable map
  parent_map <- init_heritable_map(block = branch_path[1L])
  
  for (branch_depth in purrr::accumulate(branch_path, c)) {
    
    parent_map %<>% complement_heritable_map(from = purrr::chuck(raw_q, !!!branch_depth))
  }
  
  item_map <-
    raw_q %>%
    purrr::chuck(!!!branch_path, "item") %>%
    purrr::keep(.p = ~ isTRUE(.x$variable_name == v_name)) %>%
    purrr::flatten()
  
  if (!rlang::has_name(x = item_map, name = "variable_name")) {
    cli::cli_abort(paste0("There is no item with {.arg variable_name} {.val {v_name}} defined under the questionnaire branch path {.field ",
                          pal::prose_ls(x = branch_path,
                                        separator = " -> ",
                                        last_separator = " -> "),
                          "}."))
  }
  
  raw_val <-
    parent_map %>%
    complement_heritable_map(from = item_map) %>%
    purrr::chuck(key)
  
  lvl %>%
    purrr::map(function(lvl) {
      
      purrr::map(.x = i,
                 lvl = lvl,
                 .f = function(i,
                               lvl) {
                   
                   purrr::map(.x = j,
                              i = i,
                              lvl = lvl,
                              .f = function(j,
                                            i,
                                            lvl) {
                                
                                resolve_q_val(x = raw_val,
                                              ballot_date = ballot_date,
                                              canton = canton,
                                              key = key,
                                              lvl = lvl,
                                              i = i,
                                              j = j)
                              })
                 })
    }) %>%
    unlist()
}

#' Political parties
#'
#' A tibble of political party metadata defined in the [raw FOKUS questionnaire data][raw_q].
#'
#' @return `r pkgsnip::return_label("data")`
#' @family q_internal
#' @keywords internal
q_parties <- function() {
  
  raw_q %>%
    purrr::chuck("party") %>%
    purrr::map(as_flat_list) %>%
    purrr::map_dfr(tibble::as_tibble)
}

#' Extract response options
#'
#' Extracts response options of the specified type and optionally subtype(s) from the [raw FOKUS questionnaire data][raw_q].
#'
#' Note that only recurring response options are returned which are defined under the `response_options` top-level key in the file
#' `data-raw/questionnaire/questionnaire.toml`.
#'
#' @inheritParams election_name
#' @param type Response option type. One of
#' `r pal::as_md_list(paste0('"', response_option_types, '"'), wrap = '``')`
#' @param subtypes Hierarchical response option subtypes as a character vector, or `NULL`. If `NULL`, all subtypes are returned.
#'
#' @return A character vector.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de")
#'
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de",
#'                            subtypes = "election")
#'
#' fokus:::q_response_options(type = "abstain",
#'                            lang = "de",
#'                            subtypes = c("election", "proportional"))
q_response_options <- function(type = response_option_types,
                               lang = c("de", "en"),
                               subtypes = NULL) {
  
  type <- rlang::arg_match(type)
  lang <- rlang::arg_match(lang)
  checkmate::assert_character(subtypes,
                              any.missing = FALSE,
                              min.len = 1L,
                              null.ok = TRUE)
  raw_q %>%
    purrr::chuck("response_options", type, lang, !!!subtypes) %>%
    pal::as_chr()
}

#' Extract response option codes
#'
#' Extracts response option codes of the specified type(s) from the [raw FOKUS questionnaire data][raw_q].
#'
#' Note that only codes of recurring response options are returned which are defined under the `response_options` top-level key in the file
#' `data-raw/questionnaire/questionnaire.toml`.
#'
#' @param types Response option types. One or more of
#' `r pal::as_md_list(paste0('"', response_option_types, '"'), wrap = '``')`
#'
#' @return An integer vector.
#' @family q_internal
#' @keywords internal
#'
#' @examples
#' fokus:::q_response_option_codes(types = "abstain")
#'
#' fokus:::q_response_option_codes(types = c("dunno",
#'                                           "custom",
#'                                           "abstain"))
q_response_option_codes <- function(types = response_option_types) {
  
  types <- unique(checkmate::assert_subset(types,
                                           choices = response_option_types,
                                           empty.ok = FALSE))
  
  types %>% purrr::map_int(~ raw_q %>% purrr::chuck("response_options", .x, "code"))
}

#' Authorize googledrive 
#'
#' Authorizes the googledrive package to access and manage files on your Google Drive via a [Google Cloud Platform (GCP) Service
#' Account Key](https://cloud.google.com/iam/docs/creating-managing-service-account-keys) file in JSON format. See the [relevant googledrive
#' documentation](https://gargle.r-lib.org/articles/non-interactive-auth.html#provide-a-service-account-token-directly) for details.
#'
#' @param path_gcp_service_account_key Path to the GCP Service Account Key JSON file.
#'
#' @return `path_gcp_service_account_key`, invisibly.
#' @family g_apps
#' @keywords internal
auth_g_drive <- function(path_gcp_service_account_key = path_private("config/gcp_service_account_key.json")) {
  
  pal::assert_pkg("googledrive")
  is_file <- checkmate::test_file_exists(path_gcp_service_account_key,
                                         access = "r")
  
  if (is_file) {
    
    status_msg <- "Authenticating Google account..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
    
    googledrive::drive_auth(path = path_gcp_service_account_key,
                            email = TRUE)
    
  } else {
    cli::cli_abort(paste0("No Google Cloud Platform service account key found under {.path {path_gcp_service_account_key}} ",
                          "Instructions to store such a key can be found here: ",
                          # TODO: the `#` char in the URL somehow breaks cli's class formatting (`{.url ...}`) -> report bug!
                          "https://gargle.r-lib.org/articles/non-interactive-auth.html#provide-a-service-account-token-directly"))
  }
  
  invisible(path_gcp_service_account_key)
}

assert_countish <- function(x,
                            positive = TRUE,
                            null_ok = FALSE) {
  
  if (null_ok && is.null(x)) {
    x
    
  } else {
    checkmate::assert_count(as.integer(x),
                            positive = positive)
  }
}

assert_integerish <- function(x,
                              lower = -Inf,
                              upper = Inf,
                              any_missing = FALSE,
                              all_missing = FALSE,
                              null_ok = FALSE) {
  
  if (null_ok && is.null(x)) {
    x
    
  } else {
    checkmate::assert_integerish(as.integer(x),
                                 lower = lower,
                                 upper = upper,
                                 any.missing = any_missing,
                                 all.missing = all_missing,
                                 coerce = TRUE)
  }
}

as_flat_list <- function(x) {
  
  result <- x
  depth <- purrr::vec_depth(result)
  
  # unlist until only a single list level remains
  while (depth > 2L) {
    
    result %<>% unlist(recursive = FALSE)
    depth <- purrr::vec_depth(result)
  }
  
  # wrap in list if necessary
  if (depth < 2L && !is.list(x)) {
    
    result <- list(x)
  }
  
  result
}

ballot_title <- function(ballot_date,
                         canton) {
  
  ballot_types(ballot_date = ballot_date,
               canton = canton) %>%
    purrr::when(length(.) > 1L ~ "Abstimmungs- und Wahl",
                . == "referendum" ~ "Abstimmungs",
                . == "election" ~ "Wahl",
                ~ cli::cli_abort("Undefined behavior. Please debug.")) %>%
    glue::glue("termin vom {prettify_date(ballot_date, locale = 'de')}")
}

collapse_break <- function(s) {
  
  paste0(s, collapse = "<br>")
}

wrap_backtick <- function(s) {
  
  purrr::map_chr(.x = s,
                 .f = ~ dplyr::if_else(.x == "-" | stringr::str_detect(string = .x,
                                                                       pattern = "^(_.*_|\\*.*\\*)$"),
                                       as.character(.x),
                                       paste0("`", .x, "`")))
}

this_pkg <- utils::packageName()



unicode_checkmark <- "\u2705"
unicode_crossmark <- "\u274C"
unicode_ellipsis  <- "\u2026"

global_cache_lifespan <- "30 days"

# questionnaire item subkeys (lowest level only, i.e. without ballot types)
q_item_subkeys <- c("true",
                    "false",
                    "default",
                    "YYYYMMDD",
                    "YYYYMMDD_YYYYMMDD")

#' List FOKUS-covered ballot dates
#'
#' A vector of ballot dates covered by FOKUS surveys up until `r max(ballot_dates)`.
#'
#' @format `r pkgsnip::return_label("dates")`
#' @seealso [`cantons`][cantons] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys] [`proposal_types`][proposal_types]
#' @export
"ballot_dates"

#' List cantons that are covered in *any* FOKUS survey
#'
#' A vector of cantons that were part of at least one FOKUS survey up until `r max(ballot_dates)`.
#'
#' @format A character vector.
#' @seealso [`ballot_dates`][ballot_dates] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys] [`proposal_types`][proposal_types]
#' @export
"cantons"

#' Referendum proposal types
#'
#' A vector of all [referendum proposal types][proposal_type].
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`response_option_types`][response_option_types] [`q_item_keys`][q_item_keys]
#' @export
"proposal_types"

#' List available response option types
#'
#' A vector of all response option types defined in the [raw FOKUS questionnaire data][raw_q].
#'
#' @format A character vector.
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`proposal_types`][proposal_types] [`q_item_keys`][q_item_keys]
#' @export
"response_option_types"

#' List supported questionnaire item keys
#'
#' A tibble of item keys supported in the [raw FOKUS questionnaire data][raw_q].
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons] [`response_option_types`][response_option_types] [`proposal_types`][proposal_types]
#' @export
"q_item_keys"

#' Determine ballot types
#'
#' Determines the types of the ballot for the specified canton at the specified date.
#'
#' @param ballot_date A valid FOKUS-covered cantonal ballot date. One of
#' `r pal::as_md_list(paste0('"', ballot_dates, '"'), wrap = '``')`
#' @param canton A valid FOKUS canton. One of
#' `r pal::as_md_list(paste0('"', cantons, '"'), wrap = '``')`
#'
#' @return A character vector of ballot types. One or more of
#'   - `"referendum"`
#'   - `"election"`
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::ballot_types(ballot_date = "2018-09-23",
#'                     canton = "aargau")
ballot_types <- function(ballot_date = ballot_dates,
                         canton = cantons) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  has_election <- has_election(ballot_date = ballot_date,
                               canton = canton)
  
  has_referendum <- has_referendum(ballot_date = ballot_date,
                                   canton = canton)
  
  c("referendum"[has_referendum],
    "election"[has_election])
}

#' Get number of referendum proposals
#'
#' Determines the number of referendum proposals for a canton at the specified ballot date on the specified political level(s).
#'
#' Technically, the number of *federal* proposals is independent from the canton, but this function still expects a valid `canton`. Nonetheless, the returned
#' number of *federal* proposals at a specific ballot date is always the same regardless of `canton`.
#'
#' @inheritParams n_elections
#'
#' @inherit n_elections return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::n_proposals(ballot_date = "2018-09-23",
#'                    canton = "aargau")
n_proposals <- function(ballot_date = ballot_dates,
                        lvls = c("cantonal", "federal"),
                        canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = c("cantonal", "federal"),
                                          empty.ok = FALSE))
  
  raw <- raw_q_suppl(ballot_date = ballot_date)
  result <- 0L
  
  if ("federal" %in% lvls) {
    result %<>% magrittr::add(length(raw$federal$proposal))
  }
  
  if ("cantonal" %in% lvls) {
    result %<>% magrittr::add(length(raw$cantonal[[canton]]$proposal))
  }
  
  result
}

#' Get number of elections
#'
#' Determines the number of elections for a canton at the specified ballot date on the specified political level(s) and of the specified election procedure(s).
#'
#' @inheritParams ballot_types
#' @param lvls Political level(s). One or more of
#'   - `"cantonal"`
#'   - `"federal"`
#' @param prcds Election procedure(s). One or more of
#'   - `"proportional"`
#'   - `"majoritarian"`
#'
#' @return An integer.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::n_elections(ballot_date = "2018-09-23",
#'                    canton = "aargau")
n_elections <- function(ballot_date = ballot_dates,
                        lvls = c("cantonal", "federal"),
                        canton = cantons,
                        prcds = c("proportional", "majoritarian")) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  lvls <- unique(checkmate::assert_subset(lvls,
                                          choices = c("cantonal", "federal"),
                                          empty.ok = FALSE))
  canton <- rlang::arg_match(canton)
  prcds <- unique(checkmate::assert_subset(prcds,
                                           choices = c("proportional", "majoritarian"),
                                           empty.ok = FALSE))
  result <- 0L
  raw <- raw_q_suppl(ballot_date = ballot_date)
  
  if ("federal" %in% lvls) {
    
    result <-
      prcds %>%
      purrr::map_int(~ length(raw$federal$election[[.x]])) %>%
      sum() %>%
      purrr::when(length(.) == 0L ~ 0L,
                  ~ .) %>%
      magrittr::add(result)
  }
  
  if ("cantonal" %in% lvls) {
    
    result <-
      prcds %>%
      purrr::map_int(~ length(raw$cantonal[[canton]]$election[[.x]])) %>%
      sum() %>%
      purrr::when(length(.) == 0L ~ 0L,
                  ~ .) %>%
      magrittr::add(result)
  }
  
  result
}

#' Determine whether ballot type includes a referendum
#'
#' Determines whether or not the ballot in the specified canton at the specified date on the specified political level(s) includes a referendum.
#'
#' Note that if more than one `lvls` are provided (the default), they are interpreted according to the rules of [logical
#' disjunction](https://en.wikipedia.org/wiki/Logical_disjunction), i.e. `TRUE` is returned if *any* `lvls` are included in the specified ballot.
#' 
#' For [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction), use `has_referendum(lvls = "cantonal") && has_referendum(lvls = "federal")`.
#'
#' @inheritParams n_elections
#'
#' @inherit has_election return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_referendum(ballot_date = "2018-09-23",
#'                       lvls = "federal",
#'                       canton = "aargau")
has_referendum <- function(ballot_date = ballot_dates,
                           lvls = c("cantonal", "federal"),
                           canton = cantons) {
  
  n_proposals(ballot_date = ballot_date,
              lvls = lvls,
              canton = canton) > 0L
}

#' Determine whether ballot type includes an election
#'
#' Determines whether or not the ballot for the specified canton at the specified date on the specified political level(s) includes an election of the specified
#' election procedure(s).
#'
#' Note that if more than one `lvls`/`prcds` are provided (the default), they are interpreted according to the rules of [logical
#' disjunction](https://en.wikipedia.org/wiki/Logical_disjunction), i.e. `TRUE` is returned if *any* `lvls`/`prcds` are included in the specified ballot.
#' 
#' For [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction), use e.g. `has_election(lvls = "cantonal") && has_election(lvls = "federal")`.
#'
#' @inheritParams n_elections
#'
#' @return A logical scalar.
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_election(ballot_date = "2018-09-23",
#'                     canton = "aargau")
has_election <- function(ballot_date = ballot_dates,
                         lvls = c("cantonal", "federal"),
                         canton = cantons,
                         prcds = c("proportional", "majoritarian")) {
  
  n_elections(ballot_date = ballot_date,
              lvls = lvls,
              canton = canton,
              prcds = prcds) > 0L
}

#' Determine whether ballot includes a political level
#'
#' Determines whether or not the ballot in the specified canton at the specified date includes the specified political level.
#'
#' @inheritParams election_name
#'
#' @inherit has_election return
#' @family predicate_fundamental
#' @export
#'
#' @examples
#' fokus::has_lvl(ballot_date = "2018-09-23",
#'                lvl = "federal",
#'                canton = "aargau")
has_lvl <- function(ballot_date = ballot_dates,
                    lvl = c("cantonal", "federal"),
                    canton = cantons) {
  
  lvl <- rlang::arg_match(lvl)
  
  has_election(ballot_date = ballot_date,
               lvls = lvl,
               canton = canton) ||
    has_referendum(ballot_date = ballot_date,
                   lvls = lvl,
                   canton = canton)
}

#' Get proposal type
#'
#' @inheritParams proposal_name
#'
#' @return Proposal type. One of
#' `r pal::as_md_list(paste0('"', proposal_types, '"'), wrap = '``')`
#' 
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_type(ballot_date = "2018-09-23",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      proposal_nr = 1)
proposal_type <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          proposal_nr = 1L) {
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::chuck("type")
}

#' Get proposal name
#'
#' Returns the name of the specified proposal in the specified language.
#'
#' @inheritParams ballot_types
#' @param lvl Political level. One of
#'   - `"cantonal"`
#'   - `"federal"`
#' @param proposal_nr Proposal number. A positive integer scalar.
#' @param lang Language. One of
#'   - `"de"`
#'   - `"en"`
#' @param type Name type. One of
#'   - `"short"`
#'   - `"long"`
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_name(ballot_date = "2018-09-23",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      proposal_nr = 1,
#'                      type = "long")
proposal_name <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          proposal_nr = 1L,
                          lang = c("de", "en"),
                          type = c("short", "long")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            proposal_nr = proposal_nr) %>%
    purrr::chuck(lang, type, "text")
}

#' Get German proposal name's grammatical gender
#'
#' Returns the grammatical gender of the German name of the specified proposal.
#'
#' @inheritParams proposal_name
#'
#' @return A character scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_name_gender(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1,
#'                             type = "short")
proposal_name_gender <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr = 1L,
                                 type = c("short", "long")) {
  
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            proposal_nr = proposal_nr) %>%
    purrr::chuck("de", type, "gender")
}

#' Get proposal's arguments
#'
#' Returns text, side and number of all arguments on the specified proposal.
#'
#' @inheritParams proposal_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_arguments(ballot_date = "2018-09-23",
#'                           lvl = "cantonal",
#'                           canton = "aargau",
#'                           proposal_nr = 1)
proposal_arguments <- function(ballot_date = ballot_dates,
                               lvl = c("cantonal", "federal"),
                               canton = cantons,
                               proposal_nr = 1L) {
  
  raw_q_suppl_arguments(ballot_date = ballot_date,
                        lvl = lvl,
                        canton = canton,
                        proposal_nr = proposal_nr) %>%
    purrr::map(as_flat_list) %>%
    purrr::map_dfr(tibble::as_tibble)
}

#' Get proposal's main motives
#'
#' Returns text and code number of all main motives on the specified proposal.
#'
#' @inheritParams proposal_name
#' @param type Main motive type. One of
#'   - `"yes"`
#'   - `"no"`
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::proposal_main_motives(ballot_date = "2018-09-23",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              proposal_nr = 1,
#'                              type = "no")
proposal_main_motives <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  proposal_nr = 1L,
                                  type = c("yes",
                                           "no")) {
  type <- rlang::arg_match(type)
  
  raw_q_suppl_main_motives(ballot_date = ballot_date,
                           lvl = lvl,
                           canton = canton,
                           proposal_nr = proposal_nr) %>%
    purrr::chuck(type) %>%
    purrr::map_dfr(tibble::as_tibble)
}

#' Get proposal's number of main motives
#'
#' Determines the number of main motives on the specified proposal.
#'
#' @inheritParams proposal_main_motives
#'
#' @return An integer scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::n_proposal_main_motives(ballot_date = "2018-09-23",
#'                                lvl = "cantonal",
#'                                canton = "aargau",
#'                                proposal_nr = 1,
#'                                type = "no")
n_proposal_main_motives <- function(ballot_date = ballot_dates,
                                    lvl = c("cantonal", "federal"),
                                    canton = cantons,
                                    proposal_nr = 1L,
                                    type = c("yes",
                                             "no")) {
  type <- rlang::arg_match(type)
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::pluck("main_motive") %>%
    purrr::pluck(type) %>%
    length()
}

#' Get proposal's number of arguments
#'
#' Determines the number of arguments on the specified proposal.
#'
#' @inheritParams proposal_main_motives
#'
#' @return An integer scalar.
#' @family predicate_proposal
#' @export
#'
#' @examples
#' fokus::n_proposal_arguments(ballot_date = "2018-09-23",
#'                             lvl = "cantonal",
#'                             canton = "aargau",
#'                             proposal_nr = 1)
n_proposal_arguments <- function(ballot_date = ballot_dates,
                                 lvl = c("cantonal", "federal"),
                                 canton = cantons,
                                 proposal_nr = 1L) {
  
  raw_q_suppl_proposal(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       proposal_nr = proposal_nr) %>%
    purrr::pluck("argument") %>%
    length()
}

#' Get number of (officially registered) majoritarian election candidates
#'
#' Determines the number of (officially registered) candidates of a majoritarian election at the specified ballot date on the specified political level.
#'
#' @inheritParams election_name
#'
#' @return An integer scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::n_election_candidates(ballot_date = "2019-10-20",
#'                              lvl = "cantonal",
#'                              canton = "aargau")
n_election_candidates <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    length()
}

#' Get number of majoritarian election seats
#'
#' Determines the number of election seats of the specified type for the specified majoritarian election.
#'
#' @inheritParams election_name
#' @param type Seat type. One of
#'  - `"vacant"`
#'  - `"total"`
#'
#' @return An integer scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::n_election_seats(ballot_date = "2019-10-20",
#'                         lvl = "cantonal",
#'                         canton = "aargau",
#'                         type = "total")
n_election_seats <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L,
                             type = c("vacant", "total")) {
  
  type <- rlang::arg_match(type)
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("n_seats", type)
}

#' Get election name
#'
#' Returns the name of the specified election in the specified language.
#'
#' @inheritParams proposal_name
#' @param prcd Election procedure. One of
#'   - `"proportional"`
#'   - `"majoritarian"`
#' @param election_nr Election number. A positive integer scalar (in almost all cases `1L`).
#' @param type Name type. One of
#'   - `"short"`
#'   - `"long"`
#'   - `"body"`
#'   - `"body_alt"`
#'
#' @return A character scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_name(ballot_date = "2019-10-20",
#'                      lvl = "cantonal",
#'                      canton = "aargau",
#'                      prcd = "majoritarian",
#'                      election_nr = 1,
#'                      type = "body")
election_name <- function(ballot_date = ballot_dates,
                          lvl = c("cantonal", "federal"),
                          canton = cantons,
                          prcd = c("proportional", "majoritarian"),
                          election_nr = 1L,
                          lang = c("de", "en"),
                          type = c("short", "long", "body", "body_alt")) {
  
  lang <- rlang::arg_match(lang)
  type <- rlang::arg_match(type)
  
  raw_q_suppl_election_name(ballot_date = ballot_date,
                            lvl = lvl,
                            canton = canton,
                            prcd = prcd,
                            election_nr = election_nr) %>%
    purrr::chuck(lang, type, "text")
}

#' Get combined elections name
#'
#' Returns the combined name of all elections at the specified date on the specified level for the specified canton.
#'
#' @inheritParams election_name
#'
#' @return A character scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_names_combined(ballot_date = "2019-10-20",
#'                                lvl = "federal",
#'                                canton = "aargau")
election_names_combined <- function(ballot_date = ballot_dates,
                                    lvl = c("cantonal", "federal"),
                                    canton = cantons) {
  
  raw_q_suppl_elections(ballot_date = ballot_date,
                        lvl = lvl,
                        canton = canton) %>%
    purrr::chuck("names_combined", "de", "short")
}

#' Get majoritarian election's candidates
#'
#' Returns the name and party of all candidates running for the specified majoritarian election.
#'
#' @inheritParams election_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_candidates(ballot_date = "2019-10-20",
#'                            lvl = "cantonal",
#'                            canton = "aargau")
election_candidates <- function(ballot_date = ballot_dates,
                                lvl = c("cantonal", "federal"),
                                canton = cantons,
                                election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    purrr::map_dfr(tibble::as_tibble)
}

#' Assemble majoritarian election's candidate string(s)
#'
#' Assembles one or more majoritarian election candidate string(s) consisting of the candidate's first name, last name and optionally political party (in
#' parentheses).
#'
#' @inheritParams election_name
#' @param candidate_nrs Election candidate numbers to include. A vector of positive integers or `NULL`. If `NULL`, all candidates will be included.
#' @param incl_party Whether or not to include the candidate's political party in the resulting string (in parentheses).
#'
#' @return A character vector.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_candidate_string(ballot_date = "2019-10-20",
#'                                  lvl = "cantonal",
#'                                  canton = "aargau",
#'                                  candidate_nrs = 1:3)
election_candidate_string <- function(ballot_date = ballot_dates,
                                      lvl = c("cantonal", "federal"),
                                      canton = cantons,
                                      election_nr = 1L,
                                      candidate_nrs = NULL,
                                      incl_party = TRUE) {
  
  data_candidates <- election_candidates(ballot_date = ballot_date,
                                         lvl = lvl,
                                         canton = canton,
                                         election_nr = election_nr)
  
  candidate_nrs <- assert_integerish(candidate_nrs,
                                     lower = 1L,
                                     upper = nrow(data_candidates),
                                     null_ok = TRUE)
  checkmate::assert_flag(incl_party)
  
  if (length(candidate_nrs)) {
    data_candidates %<>% dplyr::filter(dplyr::row_number() %in% candidate_nrs)
  }
  
  data_candidates %>% purrr::pmap_chr(incl_party = incl_party,
                                      .f = function(first_name, last_name, party, ..., incl_party) {
                                        paste0(first_name, " ", last_name, paste0(" (", party, ")")[incl_party])
                                      })
}

#' Get proportional election's political parties
#'
#' Returns the questionnaire code as well as different versions of the name of all parties for the specified proportional election.
#'
#' @inheritParams election_name
#' @param past Whether to extract the current or the predecessor election's parties.
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_parties(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau")
#'
#' fokus::election_parties(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau",
#'                         past = TRUE)
election_parties <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L,
                             past = FALSE) {
  
  checkmate::assert_flag(past)
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "proportional",
                       election_nr = election_nr) %>%
    purrr::chuck(dplyr::if_else(past,
                                "past_party",
                                "party")) %>%
    purrr::map(as_flat_list) %>%
    purrr::map_dfr(tibble::as_tibble)
}

#' Get proportional election's tickets
#'
#' Returns the name, number and party of all tickets for the specified proportional election.
#'
#' @inheritParams election_name
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::election_tickets(ballot_date = "2019-10-20",
#'                         lvl = "federal",
#'                         canton = "aargau")
election_tickets <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "proportional",
                       election_nr = election_nr) %>%
    purrr::chuck("ticket") %>%
    purrr::map_dfr(tibble::as_tibble)
}

#' Determine whether majoritarian election requires candidate registration
#'
#' Determines whether or not candidates must be officially registered prior to the specified majority election.
#' 
#' The absence of a candidate registration requirement usually means that every eligible citizen can be elected, i.e. receive valid votes.
#'
#' @inheritParams election_name
#'
#' @return A logical scalar.
#' @family predicate_election
#' @export
#'
#' @examples
#' fokus::requires_candidate_registration(ballot_date = "2019-10-20",
#'                                        lvl = "federal",
#'                                        canton = "aargau")
requires_candidate_registration <- function(ballot_date = ballot_dates,
                                            lvl = c("cantonal", "federal"),
                                            canton = cantons,
                                            election_nr = 1L) {
  
  raw_q_suppl_election(ballot_date = ballot_date,
                       lvl = lvl,
                       canton = canton,
                       prcd = "majoritarian",
                       election_nr = election_nr) %>%
    purrr::chuck("requires_candidate_registration")
}

#' Get number of skill questions
#'
#' Determines the number of skill questions at the specified ballot date on the specified political level.
#'
#' @inheritParams election_name
#' @param canton A valid FOKUS canton. One of
#' `r pal::as_md_list(paste0('"', cantons, '"'), wrap = '``')`
#' 
#' Only relevant if `lvl = "cantonal"`.
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, the number of non-proposal-specific skill questions is returned.
#'
#' @return An integer scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::n_skill_questions(ballot_date = "2018-09-23",
#'                          lvl = "cantonal",
#'                          canton = "aargau",
#'                          proposal_nr = 1)
n_skill_questions <- function(ballot_date = ballot_dates,
                              lvl = c("cantonal", "federal"),
                              canton = cantons,
                              proposal_nr = NULL) {
  
  lvl <- rlang::arg_match(lvl)
  canton <- rlang::arg_match(canton)
  proposal_nr <- assert_countish(proposal_nr,
                                 null_ok = TRUE)
  lvl %>%
    purrr::when(
      
      # federal non-proposal-specific skill questions (e.g. at federal elections)
      length(proposal_nr) == 0L && . == "federal" ~
        raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl),
      # cantonal non-proposal-specific skill questions (e.g. at cantonal elections)
      length(proposal_nr) == 0L && . == "cantonal" ~
        raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl) %>%
        purrr::pluck(canton),
      # federal or cantonal proposal-specific skill questions
      ~ raw_q_suppl(ballot_date = ballot_date) %>%
        purrr::pluck(lvl) %>%
        purrr::when(lvl == "cantonal" ~ purrr::pluck(., canton),
                    ~ .) %>%
        purrr::pluck("proposal") %>%
        purrr::pluck(proposal_nr)
    ) %>%
    purrr::pluck("skill_question") %>%
    length()
}

#' Get skill question
#'
#' Returns the skill question text in the specified language.
#'
#' @inheritParams proposal_name
#' @param proposal_nr Proposal number. A positive integer scalar or `NULL`. If `NULL`, it is considered to be a non-proposal-specific skill question 
#'   (the case at elections).
#' @param skill_question_nr Skill question number. A positive integer scalar.
#'
#' @return A character scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question(ballot_date = "2018-09-23",
#'                       lvl = "cantonal",
#'                       canton = "aargau",
#'                       proposal_nr = 1,
#'                       skill_question_nr = 2,
#'                       lang = "en")
skill_question <- function(ballot_date = ballot_dates,
                           lvl = c("cantonal", "federal"),
                           canton = cantons,
                           proposal_nr = NULL,
                           skill_question_nr,
                           lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck(lang)
}

#' Get skill question response options
#'
#' Returns the response options of the specified skill question together with the information whether they are correct or not.
#'
#' @inheritParams skill_question
#'
#' @return `r pkgsnip::return_label("data")`
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_response_options(ballot_date = "2018-09-23",
#'                                        lvl = "cantonal",
#'                                        canton = "aargau",
#'                                        proposal_nr = 1,
#'                                        skill_question_nr = 2)
skill_question_response_options <- function(ballot_date = ballot_dates,
                                            lvl = c("cantonal", "federal"),
                                            canton = cantons,
                                            proposal_nr = NULL,
                                            skill_question_nr) {
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map_dfr(tibble::as_tibble)
}

#' Get correct skill question answer number
#'
#' Returns the sequential number of the correct answer for the specified skill question.
#'
#' @inheritParams skill_question
#'
#' @return An integer scalar.
#' @family predicate_skill_question
#' @export
#'
#' @examples
#' fokus::skill_question_answer_nr(ballot_date = "2018-09-23",
#'                                 lvl = "cantonal",
#'                                 canton = "aargau",
#'                                 proposal_nr = 1,
#'                                 skill_question_nr = 2)
skill_question_answer_nr <- function(ballot_date = ballot_dates,
                                     lvl = c("cantonal", "federal"),
                                     canton = cantons,
                                     proposal_nr = NULL,
                                     skill_question_nr) {
  
  raw_q_suppl_skill_question(ballot_date = ballot_date,
                             lvl = lvl,
                             canton = canton,
                             proposal_nr = proposal_nr,
                             skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map_depth(.depth = 1L,
                     .f = ~ .x$is_correct) %>%
    purrr::flatten_lgl() %>%
    which()
}

#' Get political issues
#'
#' Returns the political issues in the specified language.
#'
#' @inheritParams proposal_name
#'
#' @return A character vector.
#' @family predicate_other
#' @export
#'
#' @examples
#' fokus::political_issues(ballot_date = "2019-10-20",
#'                         lang = "en")
political_issues <- function(ballot_date = ballot_dates,
                             lang = c("de", "en")) {
  
  lang <- rlang::arg_match(lang)
  
  result <-
    raw_q_suppl(ballot_date = ballot_date) %>%
    purrr::pluck("political_issues")
  
  if (is.null(result)) {
    
    # reduce to proper arg value for error msg
    ballot_date %<>% as.character()
    ballot_date <- rlang::arg_match(ballot_date,
                                    values = as.character(ballot_dates))
    
    cli::cli_abort("No political issues present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  result %>%
    purrr::chuck("issue") %>%
    purrr::map_depth(1L, purrr::chuck, lang) %>%
    purrr::flatten_chr()
}

#' Generate questionnaire
#'
#' This is the main questionnaire generation interface that's doing all the magic. This function is only called for its side effects, it doesn't return
#' anything.
#'
#' @inheritParams ballot_types
#' @param quiet `r pkgsnip::param_label("quiet")`
#'   
#' Either as a character or a [date][base::Date] scalar.
#'
#' @return `NULL`, invisibly.
#' @family q_gen
#' @keywords internal
gen_q <- function(ballot_date = ballot_dates,
                  canton = cantons,
                  quiet = FALSE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  checkmate::assert_flag(quiet)
  
  # generate questionnaire tibble
  if (!quiet) {
    status_msg <- "Generating questionnaire data..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  q_tibble <- q_tibble(ballot_date = ballot_date,
                       canton = canton)
  
  # expand questionnaire tibble to long data format
  if (!quiet) {
    status_msg <- "Expanding questionnaire data to long format..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  q_tibble %<>% expand_q_tibble()
  
  readr::write_rds(file = path_private(glue::glue("output/data/internal/r/questionnaire_{ballot_date}_{canton}.rds")),
                   compress = "xz",
                   compression = 9L)
  
  # generate Markdown questionnaire
  if (!quiet) {
    status_msg <- "Generating Markdown questionnaire..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  knitr::knit2pandoc(input = path_private("rmd/questionnaire.Rmd"),
                     output = path_private(glue::glue("output/questionnaires/questionnaire_{ballot_date}_{canton}.md")),
                     quiet = TRUE,
                     tangle = FALSE,
                     to = "gfm",
                     encoding = "UTF-8")
  
  invisible(NULL)
}

#' Determine whether variable is skill question
#'
#' Determines whether or not a variable is a skill question. Vectorized.
#'
#' @param v_names A character vector of FOKUS variable names.
#'
#' @return A logical vector.
#' @family variable
#' @export
is_skill_question <- function(v_names) {
  
  stringr::str_detect(string = v_names,
                      pattern = "^skill_question_\\d+_(cantonal|federal)(_proposal_\\d+)?$")
}

#' Determine variable's political level(s)
#'
#' Determines a variable's political level(s).
#' 
#' Note that the political levels are determined by simply parsing `v_name`.
#'
#' @param v_name Variable name. A character scalar.
#'
#' @return A character vector of political levels, of length 0 if no specific levels could be determined.
#' @family variable
#' @export
#'
#' @examples
#' fokus::v_lvls("skill_question_1_cantonal_proposal_1")
v_lvls <- function(v_name) {
  
  is_cantonal <- v_name %>% stringr::str_detect(pattern = "cantonal")
  is_federal <- v_name %>% stringr::str_detect(pattern = "federal")
  
  c("cantonal"[is_cantonal], "federal"[is_federal])
}

#' Shorten variable names to a maximum length of 32 characters
#'
#' @param v_names A character vector of variable names.
#' @param reverse Whether to apply the inversion of the shortening logic, i.e. to restore original/unshortened variable names.
#' @param max_n_char Maximum allowed number of characters. Either `NULL` to skip the check or otherwise an integer scalar in which case it is ensured that the
#'   maximum resulting variable name length doesn't exceed it. Doesn't have any influence on the applied shortening logic.
#'
#' @return A character vector of the same length as `v_names`.
#' @family variable
#' @seealso [shorten_colnames()], [restore_colnames()]
#' @export
shorten_v_names <- function(v_names,
                            reverse = FALSE,
                            max_n_char = 32L) {
  
  checkmate::assert_character(v_names,
                              any.missing = FALSE)
  checkmate::assert_flag(reverse)
  checkmate::assert_count(max_n_char)
  rules <- shortening_rules

  if (reverse) colnames(rules) %<>% .[c(2L, 1L, 3L)]
  
  rules %<>% dplyr::mutate(pattern =
                             allowed %>%
                             purrr::map_chr(function(allowed) {
                               
                               allowed %>% purrr::when(. %in% c("begin-middle", "begin-middle-end") ~ "(?<=(^|_))",
                                                       . %in% c("middle", "middle-end") ~ "(?<=_)",
                                                       . %in% c("begin", "begin-end") ~ "^",
                                                       ~ "")
                             }) %>%
                             paste0(string) %>%
                             purrr::map2_chr(.x = allowed,
                                             .f = ~ {
                                               
                                               .x %>% purrr::when(. == "begin" ~ .y,
                                                                  . %in% c("begin-middle-end", "middle-end") ~ paste0(.y, "(?=(_|$))"),
                                                                  . %in% c("begin-middle", "middle") ~ paste0(.y, "(?=_)"),
                                                                  . == "begin-end" ~ paste0(.y, "$"),
                                                                  . == "end" ~ paste0("(?<=_)", .y, "$"),
                                                                  ~ cli::cli_abort("This should not happen."))
                                             }))
  
  pattern_replacement <- rules$replacement
  names(pattern_replacement) <- rules$pattern
  
  v_names_new <- v_names %>% stringr::str_replace_all(pattern = pattern_replacement)
  
  # ensure we did our job
  if (!is.null(max_n_char) && !reverse && any(nchar(v_names_new) > max_n_char)) {
    
    # NOTE: `cli::cli_abort()` doesn't properly print the output of `pal::capture_print()` because:
    #        - it just seems to ignore the output if it includes ANSI escape sequences (this can be worked around by an additional `cli::ansi_strip()`)
    #        - it normalizes whitespace chars **incl. tabs** to a single regular whitespace, thus breaking the formatting
    rlang::abort(glue::glue("There are still variable names left of a length greater than {max_n_char} characters after applying `shorten_v_names()`. ",
                            "Affected are the following (shortened) variable names:\n\n",
                            tibble::tibble(v_name = v_names,
                                           v_name_short = v_names_new,
                                           n_char = nchar(v_names),
                                           n_char_short = nchar(v_names_new)) %>%
                              dplyr::filter(n_char_short > max_n_char) %>%
                              pal::capture_print(collapse = "\n")))
  }
  
  v_names_new
}

#' Shorten column names to a maximum length of 32 characters
#'
#' This is useful for DTA export since Stata has a built-in variable name length limit of [32
#' characters](https://www.stata.com/manuals/r.pdf#rLimits) (see also
#' [here](https://www.statalist.org/forums/forum/general-stata-discussion/general/1452366-number-of-characters-in-variable-names)).
#'
#' @param x `r pkgsnip::param_label("tabular_data")`
#' @inheritParams shorten_v_names
#'
#' @return `x` with column names shortened to a maximum length of 32 characters.
#' @seealso [shorten_v_names()], [restore_colnames()]
#' @export
shorten_colnames <- function(x,
                             max_n_char = 32L) {
  
  x %>% magrittr::set_colnames(value = shorten_v_names(v_names = colnames(x),
                                                       max_n_char = max_n_char))
}

#' Restore original/unshortened column names
#'
#' Applies the inversion of [shorten_colnames()].
#'
#' @inheritParams shorten_colnames
#' @inheritParams shorten_v_names
#'
#' @return `x` with original/unshortened column names restored.
#' @seealso [shorten_v_names()], [shorten_colnames()]
#' @export
restore_colnames <- function(x) {
  
  x %>% magrittr::set_colnames(value = shorten_v_names(v_names = colnames(x),
                                                       reverse = TRUE))
}

#' Upload files to Google Drive
#'
#' Uploads one or more files to your Google Drive.
#'
#' @param filepaths Local path(s) to the file(s) to be uploaded.
#' @param g_drive_folder Destination path on Google Drive where the files are to be uploaded to.
#'
#' @return `filepaths`, invisibly.
#' @family g_apps
#' @export
upload_to_g_drive <- function(filepaths,
                              g_drive_folder = "fokus_aargau/") {
  
  checkmate::assert_character(filepaths,
                              any.missing = FALSE)
  checkmate::assert_string(g_drive_folder)
  pal::assert_pkg("googledrive")
  
  # extract filenames
  filenames <- fs::path_file(filepaths)
  
  # authenticate Google account
  auth_g_drive()
  
  # upload files
  purrr::walk2(.x = filenames,
               .y = filepaths,
               .f = ~ {
                 
                 status_msg <- "Uploading file {.file {.x}}..."
                 cli::cli_progress_step(msg = status_msg,
                                        msg_done = paste(status_msg, "done"),
                                        msg_failed = paste(status_msg, "failed"))
                 
                 # overwrite existing file if possible or create new one otherwise
                 googledrive::drive_put(media = .y,
                                        path = g_drive_folder,
                                        name = .x)
               })
  
  invisible(filepaths)
}

#' Abbreviations used in the **fokus** package
#'
#' Returns a [tibble][tibble::tbl_df] listing an opinionated set of abbreviations used in the \R code and documentation of the **fokus** package.
#'
#' @inheritParams pkgsnip::abbreviations
#'
#' @return `r pkgsnip::param_label("data")`
#' @export
abbreviations <- function(expand = FALSE) {
  
  pal::assert_pkg("pkgsnip")
  
  tibble::tribble(
    ~full_expressions, ~abbreviation,
    "google", "g",
    c("proceed","procedure"), "prcd",
    "procedures", "prcds",
    "questionnaire", "q",
    "questionnaires", "qx",
    "statistik aargau", "sa",
    c("supplemental", "supplementary"), "suppl"
  ) %>%
    dplyr::bind_rows(pkgsnip::abbreviations()) %>%
    dplyr::arrange(dplyr::across()) %>%
    purrr::when(expand ~ tidyr::unnest_longer(data = ., 
                                              col = full_expressions,
                                              values_to = "full_expression"), 
                ~.)
}

#' Print expected structure of the private FOKUS directory
#'
#' Returns a textual representation of the expected structure of the private FOKUS directory, formatted as a Markdown [fenced code
#' block](https://pandoc.org/MANUAL.html#extension-fenced_code_blocks).
#'
#' @includeRmd data-raw/snippets/fokus_private_description.Rmd
#'
#' @return A character scalar.
#' @export
print_fokus_private_structure <- function() {
  cat(md_snippets$fokus_private_structure)
}

#' Emphasize xth element of character vector (Markdown)
#'
#' @param x Input as a character vector.
#' @param which Indices of the elements to be emphasized.
#' @param emph Character sequence used for emphasis.
#'
#' @return A character vector of the same length as `x`.
#' @export
md_emphasize <- function(x,
                         which = TRUE,
                         emph = "**") {
  
  x[which] %<>% paste0(emph, ., emph)
  x
}

#' Convert logical vector to Unicode symbols `r unicode_checkmark` and `r unicode_crossmark`
#'
#' @param x A logical vector.
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' fokus::lgl_to_unicode(c(TRUE, TRUE, FALSE, NA))
lgl_to_unicode <- function(x) {
  
  dplyr::if_else(checkmate::assert_logical(x),
                 unicode_checkmark,
                 unicode_crossmark)
}

#' Prettify date
#'
#' Note that this might only work on (Ubuntu) Linux in the current form since locales are one bitchy hell of a PITA...
#'
#' @param date Date to be prettified. A [date][base::Date] or something coercible to.
#' @param locale Locale the date should be prettified for. Currently only `"en"`/`"en-US"` and `"de"`/`"de-CH"` are implemented.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' fokus::prettify_date(lubridate::today())
prettify_date <- function(date,
                          locale = c("en", "de", "en-US", "de-CH")) {
  
  locale <- rlang::arg_match(locale)
  
  withr::with_locale(new = c("LC_TIME" = purrr::when(. = locale,
                                                     . %in% c("en", "en-US") ~ "C",
                                                     . %in% c("de", "de-CH") ~ "de_CH.utf8")),
                     code =
                       locale %>%
                       purrr::when(. %in% c("en", "en-US") ~
                                     "%B %d, %Y",
                                   . %in% c("de", "de-CH") ~
                                     "%d. %B %Y",
                                   ~ cli::cli_abort("Specified {.arg locale} not implemented yet.")) %>%
                       format(x = lubridate::as_date(date)))
}

#' Read in and parse a TOML file as a strict list
#'
#' Reads in a file in [Tom's Obvious Minimal Language](https://toml.io/) format and returns its content as a (nested) [strict list][xfun::strict_list()].
#'
#' The file is parsed using [`RcppTOML::parseTOML(escape = FALSE)`][RcppTOML::parseTOML].
#'
#' @param path Path to the TOML file. A character scalar.
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @export
read_toml <- function(path) {
  
  pal::assert_pkg("RcppTOML")
  
  path %>%
    purrr::when(length(.) > 0L ~ RcppTOML::parseTOML(input = .,
                                                     escape = FALSE),
                ~ NULL) %>%
    xfun::as_strict_list()
}

deploy_q <- function(ballot_date = "2021-11-28",
                     canton = cantons,
                     verbose = FALSE) {
  
  pal::assert_pkg("rmarkdown")
  pal::assert_pkg("yay")
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  md_path <- path_private(glue::glue("output/questionnaires/questionnaire_{ballot_date}_{canton}.md"))
  
  # Generate questionnaire tibble and Markdown version
  q_tibble <- gen_q_tibble(ballot_date = ballot_date,
                           verbose = verbose)
  
  q_tibble %>%
    gen_q_md() %>%
    readr::write_lines(file = md_path)
  
  # create CSV version from tibble
  csv_path <- md_path %>% fs::path_ext_set(ext = "csv")
  
  q_tibble %>%
    clean_q_tibble() %>%
    dplyr::mutate(variable_name_32 =
                    purrr::map2_chr(.x = variable_name,
                                    .y = dplyr::if_else(block %in% c("x_publitest", "y_generated", "z_generated")
                                                        | stringr::str_detect(string = variable_name,
                                                                              pattern = paste0("^", pal::fuse_regex(c("agreement_contra_argument_",
                                                                                                                      "information_source_",
                                                                                                                      "reason_non_participation_",
                                                                                                                      "political_occasions_")))),
                                                        32L,
                                                        30L),
                                    .f = ~ shorten_v_names(v_names = .x,
                                                           max_n_char = .y)),
                  .after = variable_name) %>%
    dplyr::select(-ends_with("_common")) %>%
    expand_q_tibble() %>%
    readr::write_csv(file = csv_path,
                     na = "")
  
  # create HTML version from Markdown questionnaire
  html_path <- fs::path_ext_set(path = md_path,
                                ext = "html")
  path_dir <- fs::path_dir(html_path)
  
  status_msg <- "Converting Markdown questionnaire to HTML using Pandoc..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  rmarkdown::pandoc_convert(input = md_path,
                            to = "html5",
                            from = "markdown",
                            output = html_path,
                            options = c("--standalone",
                                        "--css=github-pandoc.css",
                                        paste0('--metadata=title:FOKUS-Aargau-Fragebogen f\u00fcr den ', ballot_title(ballot_date = ballot_date,
                                                                                                                 canton = canton))),
                            verbose = FALSE)
  cli::cli_progress_done()
  
  # create XLSX version from HTML questionnaire
  status_msg <- "Converting HTML questionnaire to XLSX using LibreOffice..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  system2(command = "flatpak",
          args = glue::glue("run --command=libreoffice",
                            "org.libreoffice.LibreOffice",
                            "--calc",
                            "--headless",
                            "--convert-to xlsx",
                            "--outdir \"{path_dir}\"",
                            "\"{html_path}\"",
                            .sep = " "))
  cli::cli_progress_done()
  
  # deploy HTML to GitLab Pages
  status_msg <- "Deploying questionnaire to GitLab Pages..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  yay::deploy_static_site(from_path = path_dir,
                          to_path = "~/Arbeit/ZDA/Git/c2d-zda/c2d-zda.gitlab.io/public/",
                          clean_to_path = FALSE)
  cli::cli_progress_done()
  
  # upload files to Google Drive for publitest
  upload_to_g_drive(filepaths = c(md_path,
                                  csv_path,
                                  html_path,
                                  fs::path(path_dir, "github-pandoc.css"),
                                  fs::path_ext_set(path = html_path,
                                                   ext = "xlsx")),
                    g_drive_folder = "fokus_aargau/Umfragen/Dateien f\u00fcr publitest/Fragebogen/")
}
