# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/fokus.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# fokus: Provides an API around the FOKUS Post-voting Surveys
# Copyright (C) 2021 Centre for Democracy Studies Aarau (ZDA)
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

.onUnload <- function(libpath) {
  
  pkgpins::deregister(pkg = this_pkg)
}

.onLoad <- function(libname, pkgname) {
  
  pkgpins::clear(pkg = pkgname,
                 max_age = getOption(paste0(pkgname, ".global_cache_lifespan"),
                                     default = global_cache_lifespan))
}

utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "all_of",
                                 "everything",
                                 # other
                                 "alignment",
                                 "allowed",
                                 "has_same_length",
                                 "has_auto_fallback",
                                 "n_cantonal_majoritarian_elections",
                                 "n_cantonal_proportional_elections",
                                 "n_cantonal_proposals",
                                 "n_char_short",
                                 "n_federal_majoritarian_elections",
                                 "n_federal_proportional_elections",
                                 "n_federal_proposals",
                                 "name",
                                 "nr",
                                 "question",
                                 "response_options",
                                 "separator",
                                 "string",
                                 "topic",
                                 "value_labels",
                                 "variable_values",
                                 "who",
                                 "width"))

# avoid notes about "possible error"s when using non-exported rex shortcuts, cf. https://github.com/kevinushey/rex#using-rex-in-other-packages
rex::register_shortcuts(pkg_name = utils::packageName())

path_private <- function(rel_path) {
  
  dir_private <- getOption("fokus.path_private",
                           default = switch(EXPR = Sys.info()[["user"]],
                                            "salim" = "~/Arbeit/ZDA/Git/zdaarau/private/fokus_private/",
                                            # fall back to current working directory
                                            getwd()))
  
  # ensure path is valid (read access plus file `data/aargau/survey_data_2018-09-23.xlsx` exists)
  is_valid_path <-
    checkmate::test_directory(dir_private, access = "r") && fs::file_exists(path = fs::path(dir_private, "data/aargau/survey_data_2018-09-23.xlsx"))
  
  if (!is_valid_path) {
    
    is_opt_set <- !is.null(getOption("fokus.path_private"))
    
    cli::cli_abort(paste0(dplyr::if_else(is_opt_set,
                                         "The option {.field fokus.path_private} is set to: {.path {dir_private}}\n\n",
                                         "The option {.field fokus.path_private} is unset, thus we fall back to: {.path {dir_private}}\n\n"),
                          "This doesn't seem to be a valid FOKUS working directory. Please correct this in order for this package to work properly."))
  }
  
  fs::path(dir_private, rel_path)
}

opts <- function(pretty_colnames = FALSE) {
  
  tibble::tibble(name = "fokus.path_private",
                 description = paste0("the path to the working directory (the local instance of the ",
                                      "[`fokus_private` repository](https://gitlab.com/zdaarau/private/fokus_private)); initialized automatically for ",
                                      "user=salim, otherwise defaults to the current working directory"),
                 has_auto_fallback = TRUE) |>
    tibble::add_row(name = "fokus.global_cache_lifespan",
                    description = glue::glue("the default cache lifespan for all functions taking a `cache_lifespan` argument; defaults to ",
                                             global_cache_lifespan),
                    has_auto_fallback = TRUE) |>
    purrr::when(checkmate::assert_flag(pretty_colnames) ~ dplyr::rename(.data = .,
                                                                        "automatic fallback if unset" = has_auto_fallback),
                ~ .)
}

print_opts <- function() {
  
  opts(pretty_colnames = TRUE) |>
    dplyr::mutate(name = paste0("`", name, "`"),
                  dplyr::across(all_of("automatic fallback if unset"),
                                lgl_to_unicode)) |>
    pal::pipe_table()
}

add_who_constraint <- function(s,
                               who) {
  if (who != "all") {
    
    who %>%
      purrr::when(stringr::str_detect(string = s,
                                      pattern = "\\)$") ~ stringr::str_replace(string = s,
                                                                               pattern = "\\)$",
                                                                               replacement = paste0("; only ", ., ")")),
                  ~ paste0(s, " (only ", ., ")"))
  } else s
}

assemble_deep <- function(data_q,
                          devisable_map,
                          generate_md = TRUE) {
  
  devisable_map %<>% complement_devisable(from = data_q)
  result <- NULL
  
  if ("variable_name" %in% names(data_q)) {
    
    result <- process_item(v_name = data_q$variable_name,
                           devisable_map = devisable_map,
                           generate_md = generate_md)
    
  } else if (purrr::vec_depth(data_q) > 2L) {
    
    result <-
      data_q %>%
      purrr::map(.f = assemble_deep,
                 devisable_map = devisable_map,
                 generate_md = generate_md) %>%
      purrr::compact()
    
  }
  
  result
}

assemble_md_ref_item <- function(l,
                                 canton,
                                 ballot_date) {
  
  # avoid partial matching
  l %<>% xfun::as_strict_list()
  
  if ("id" %in% names(l)
      && ("text" %in% names(l) || "url" %in% names(l))) {
    
    l$include %<>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical() %>%
      purrr::when(length(.) == 0L ~ TRUE,
                  ~ .) %>%
      checkmate::assert_flag(.var.name = "include")
    
    # return NULL if item isn't included @ ballot date
    if (!l$include) {
      
      result <- NULL
      
    } else {
      
      # determine if item is footnote or reference-style link
      is_footnote <- "text" %in% names(l)
      has_link_title <- !is_footnote & "title" %in% names(l)
      value <- dplyr::if_else(is_footnote,
                              "text",
                              "url")
      
      result <- paste0("[",
                       dplyr::if_else(is_footnote,
                                      "^",
                                      ""),
                       glue::glue(l$id,
                                  .trim = FALSE),
                       "]: ",
                       glue::glue(l[[value]],
                                  .trim = FALSE),
                       dplyr::if_else(has_link_title,
                                      paste0(" '", l$title, "'"),
                                      ""))
    }
  } else {
    cli::cli_abort("At least one of the keys {.field id} or {.field text}/{.field url} is missing from this reference item.")
  }
  
  result
}

assemble_subitem <- function(i = NULL,
                             j = NULL,
                             v_name,
                             devisable_map,
                             canton,
                             ballot_date,
                             q = q) {
  # parse the variable name
  v_name %<>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.trim = FALSE)
  
  # special case: if no `question_common` is defined, use `question.default` instead if it exists
  question <-
    devisable_map %>%
    purrr::pluck("question",
                 .default = NA_character_)
  
  question_common <-
    devisable_map %>%
    purrr::pluck("question_common",
                 .default = NA_character_) %>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.na = NULL,
               .trim = FALSE) %>%
    pal::strip_md()
  
  if (is.na(question_common) && "default" %in% names(question)) {
    
    question_common <-
      question$default %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      pal::strip_md()
  }
  
  # special case: if no `variable_label_common` is defined, use `variable_label.default` instead if it exists
  variable_name <-
    v_name %>%
    pal::strip_md()
  
  who <-
    devisable_map %>%
    purrr::chuck("who") %>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.trim = FALSE) %>%
    pal::strip_md()
  
  who_en <-
    q$who %>%
    purrr::detect(~ .x$value$de == stringr::str_replace(string = who,
                                                        pattern = "\\d+",
                                                        replacement = "{i}")) %>%
    purrr::chuck("value", "en") %>%
    glue::glue(.trim = FALSE) %>%
    pal::strip_md()
  
  variable_label <-
    devisable_map %>%
    purrr::chuck("variable_label")
  
  variable_label_common <-
    devisable_map %>%
    purrr::pluck("variable_label_common",
                 .default = NA_character_) %>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.na = NULL,
               .trim = FALSE) %>%
    pal::strip_md()
  
  if (is.na(variable_label_common) && "default" %in% names(variable_label)) {
    
    # integrity check: ensure there haven't been any changes to `who` over time (if so, an explcicit `variable_label_common` has to be defined!)
    if (length(devisable_map$who) > 1L) {
      
      cli::cli_abort(paste0("{.field who} of variable {.var {variable_name}} has changed over time. Thus a custom {.field variable_label_common} must be ",
                            "defined in {.file questionnaire/questionnaire.toml}."))
    } else {
      
      variable_label_common <-
        variable_label$default %>%
        pick_right(canton = canton,
                   ballot_date = ballot_date) %>%
        glue::glue(.na = NULL,
                   .trim = FALSE) %>%
        pal::strip_md() %>%
        add_who_constraint(who = who_en)
    }
    # add who constraint if necessary
  } else if (!is.na(variable_label_common)
             && !stringr::str_detect(string = variable_label_common,
                                     pattern = "(\\(|; )only .*?\\)$")) {
    
    if (length(devisable_map$who) > 1L) {
      
      cli::cli_abort(paste0("{.field who} of variable {.var {variable_name}} has changed over time. Thus the {.field who} constraint has to be explicitly ",
                            "specified at the end of {.field variable_label_common} in {.file questionnaire/questionnaire.toml}."))
      
    } else variable_label_common %<>% add_who_constraint(who = who_en)
  }
  
  tibble::tibble(
    topic =
      devisable_map %>%
      purrr::pluck("topic",
                   .default = NA_character_) %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      pal::strip_md(),
    who = who,
    question =
      question %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      pal::strip_md(),
    question_common = question_common,
    multiple_answers_allowed =
      devisable_map %>%
      purrr::chuck("multiple_answers_allowed") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical(),
    variable_name = variable_name,
    variable_name_32 =
      variable_name %>%
      # we set `max_n_char = 30L` to account for additional `time_*` vx which will be shortened to `t_*`, i.e. add 2 additional chars to the original v name
      # (except the special-block vx which won't have `time_*` siblings and certain exceptions which will share a common `time_*` v)
      shorten_v_names(max_n_char = dplyr::if_else(devisable_map$block %in% c("x_publitest", "y_generated", "z_generated")
                                                  || stringr::str_detect(string = .,
                                                                         pattern = rex::rex(start, or(c("agreement_contra_argument_",
                                                                                                        "information_source_",
                                                                                                        "reason_non_participation_",
                                                                                                        "political_occasions_")))),
                                                  32L,
                                                  30L)),
    variable_label =
      variable_label %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE) %>%
      pal::strip_md() %>%
      add_who_constraint(who = who_en),
    variable_label_common = variable_label_common,
    response_options =
      devisable_map %>%
      purrr::pluck("response_options",
                   .default = NA_character_) %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      purrr::map(.f = glue::glue,
                 .envir = environment(),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::flatten_chr() %>%
      list(),
    variable_values =
      devisable_map %>%
      purrr::pluck("variable_values",
                   .default = rep(x = NA_integer_,
                                  times =
                                    purrr::pluck(.x = devisable_map,
                                                 "response_options",
                                                 .default = NA_character_) %>%
                                    pick_right(canton = canton,
                                               ballot_date = ballot_date) %>%
                                    purrr::map(.f = glue::glue,
                                               .envir = environment(),
                                               .na = NULL,
                                               .trim = FALSE) %>%
                                    purrr::flatten_chr() %>%
                                    length())) %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      purrr::map(.f = glue::glue,
                 .envir = environment(),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::map(.f = as.integer) %>%
      purrr::flatten_int() %>%
      list(),
    value_labels =
      devisable_map %>%
      purrr::pluck("value_labels",
                   .default = NA_character_) %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      purrr::map(.f = glue::glue,
                 .envir = environment(),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::flatten_chr() %>%
      list(),
    value_scale =
      devisable_map %>%
      purrr::chuck("value_scale") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE) %>%
      pal::strip_md(),
    randomize_response_options =
      devisable_map %>%
      purrr::chuck("randomize_response_options") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical()
  )
}

assemble_table_row <- function(i = NULL,
                               j = NULL,
                               v_name,
                               devisable_map,
                               canton,
                               ballot_date,
                               q) {
  # parse the variable name
  v_name %<>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.trim = FALSE)
  
  who <-
    devisable_map %>%
    purrr::chuck("who") %>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.trim = FALSE)
  
  who_en <-
    q$who %>%
    purrr::detect(~ .x$value$de == stringr::str_replace(string = who,
                                                        pattern = "\\d+",
                                                        replacement = "{i}")) %>%
    purrr::chuck("value", "en") %>%
    glue::glue(.trim = FALSE)
  
  paste(
    # topic
    devisable_map %>%
      purrr::pluck("topic",
                   .default = "-") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE,
                 .na = "-"),
    # who
    who,
    # question
    devisable_map %>%
      purrr::pluck("question",
                   .default = "-") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE,
                 .na = "-"),
    # multiple answers allowed?
    devisable_map %>%
      purrr::chuck("multiple_answers_allowed") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical() %>%
      purrr::when(isTRUE(.) ~ "ja",
                  ~ "nein"),
    # variable name
    v_name %>%
      wrap_backtick() %>%
      collapse_break(),
    # variable_name_32,
    v_name %>%
      # we set `max_n_char = 30L` to account for additional `time_*` vx which will be shortened to `t_*`, i.e. add 2 additional chars to the original v name
      # (except the special-block vx which won't have `time_*` siblings and certain exceptions which will share a common `time_*` v)
      shorten_v_names(max_n_char = dplyr::if_else(devisable_map$block %in% c("x_publitest", "y_generated", "z_generated")
                                                  || stringr::str_detect(string = .,
                                                                         pattern = rex::rex(start, or(c("agreement_contra_argument_",
                                                                                                        "information_source_",
                                                                                                        "reason_non_participation_",
                                                                                                        "political_occasions_")))),
                                                  32L,
                                                  30L)) %>%
      wrap_backtick() %>%
      collapse_break(),
    # variable label
    devisable_map %>%
      purrr::chuck("variable_label") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE) %>%
      add_who_constraint(who = who_en),
    # response options
    devisable_map %>%
      purrr::pluck("response_options",
                   .default = "-") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      purrr::map(.envir = environment(),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      purrr::when(is_skill_question(v_name) ~ md_emphasize(x = .,
                                                           which = skill_question_answer_nr(canton = canton,
                                                                                            ballot_date = ballot_date,
                                                                                            lvl = fa_v_level(v_name = v_name),
                                                                                            proposal_nr = i,
                                                                                            skill_question_nr = ifelse(has_election(canton = canton,
                                                                                                                                    ballot_date = ballot_date),
                                                                                                                       i,
                                                                                                                       j))),
                  ~ .) %>%
      collapse_break(),
    # variable values
    devisable_map %>%
      purrr::pluck("variable_values",
                   .default = "-") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      purrr::map(.envir = environment(),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      collapse_break(),
    # value labels
    devisable_map %>%
      purrr::pluck("value_labels",
                   .default = "-") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      purrr::map(.envir = environment(),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      collapse_break(),
    # randomize response options?
    devisable_map %>%
      purrr::chuck("randomize_response_options") %>%
      pick_right(canton = canton,
                 ballot_date = ballot_date) %>%
      glue::glue(.trim = FALSE) %>%
      as.logical() %>%
      purrr::when(isTRUE(.) ~ "ja",
                  ~ "nein"),
    sep = " | "
  )
}

assert_devisable_map_complete <- function(devisable_map) {
  
  devisable_map_essential <-
    devisable_map %>%
    purrr::list_modify(i = rlang::zap(),
                       j = rlang::zap(),
                       topic = rlang::zap(),
                       question = rlang::zap(),
                       question_common = rlang::zap(),
                       variable_label_common = rlang::zap(),
                       response_options = rlang::zap(),
                       variable_values = rlang::zap(),
                       value_labels = rlang::zap())
  
  if (devisable_map_essential %>%
      purrr::map_lgl(.f = is.null) %>%
      any()) {
    
    unset_keys <-
      devisable_map_essential %>%
      purrr::keep(.p = is.null) %>%
      names()
    
    cli::cli_abort("{cli::qty(unset_keys)}The key{?s} {unset_keys} {?is/are} not set for variable {.var {purrr::chuck(q, 'variable_name')}}.")
  }
  
  devisable_map
}

complement_devisable <- function(map,
                                 from) {
  names <- names(map)
  
  map %>%
    purrr::map2(.x = names,
                .y = .,
                .f = function(k, v) purrr::pluck(.x = from,
                                                 k,
                                                 .default = v)) %>%
    magrittr::set_names(names)
}

expand_q_tibble <- function(q_tibble) {
  
  # integrity check 1: ensure there are no duplicated topics, variable names and variable labels
  c("topic",
    "variable_name",
    "variable_label") %>%
    purrr::walk(.f = function(v) {
      
      is_dup <- duplicated(q_tibble[[v]])
      
      if (any(is_dup)) {
        
        dup_indices <- which(is_dup)
        
        for (i in dup_indices) {
          
          dup_v <- q_tibble[[v]][i]
          
          cli::cli_warn(paste0("{.var {v}} {.val {dup_v}} is included more than once in the questionnaire. Please fix this and run the script again."))
        }
      }
    })
  
  # integrity check 2: ensure the columns `response_options`, `variable_values` and `value_labels` have the same length and if not, tell which ones don't
  lengths <-
    q_tibble %>%
    dplyr::select(response_options,
                  variable_values,
                  value_labels) %>%
    purrr::map_depth(.depth = 2L,
                     .f = length) %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::flatten_int) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(has_same_length = response_options == variable_values) %>%
    dplyr::mutate(has_same_length = has_same_length & response_options == value_labels)
  
  if (any(!lengths$has_same_length)) {
    
    diff_indices <- which(!lengths$has_same_length)
    
    cli::cli_warn(paste0("The number of {.var {c('response_options', 'variable_values', 'value_labels')}} differs for ",
                         dplyr::if_else(length(diff_indices) > 1L,
                                        "multiple variables. Affected are: {.var {q_tibble$variable_name[diff_indices]}}",
                                        "the variable {.var {q_tibble$variable_name[diff_indices]}}."),
                         "\n\nPlease fix this first and then run the script again."))
  }
  
  # expand questionnaire data to long format ...
  # note that `tidyr::unnest` also performs an implicit integrity check: it ensures that the number of response options, variable values and value labels 
  # for each variable name is either one or of the same length (or otherwise throws an error); obviously this assertion still isn't as strict as integrity
  # check 2 above
  q_tibble %>%
    tidyr::unnest(cols = c(response_options,
                           variable_values,
                           value_labels)) %>%
    # ... and remove footnote references from topic, question and who
    dplyr::mutate(dplyr::across(.cols = c(topic,
                                          question,
                                          who),
                                .fns = stringr::str_remove_all,
                                pattern = "\\[\\^[^\\]]+\\](&nbsp;)?"))
}

gen_table_header <- function() {
  
  tibble::tribble(
    ~name,                                         ~width, ~alignment,
    "\\#",                                         2L,     "left",
    "Thema",                                       5L,     "left",
    "Wer",                                         3L,     "left",
    "Frage",                                       15L,    "left",
    "Mehrfachnennungen",                           3L,     "left",
    "Variablenname",                               5L,     "left",
    "Variablenname (gek\u00fcrzt auf 32 Zeichen)", 5L,     "left",
    "Variablenlabel",                              15L,    "left",
    "Antwortoptionen",                             5L,     "left",
    "Variablenauspr\u00e4gungen",                  5L,     "left",
    "Auspr\u00e4gungslabels",                      5L,     "left",
    "Antwortoptionen in Zufallsreihenfolge",       3L,     "left"
  ) %>%
    dplyr::mutate(separator =
                    purrr::map2_chr(.x = width,
                                    .y = alignment,
                                    .f = ~
                                      rep(x = "-",
                                          times = .x) %>%
                                      paste0(collapse = "") %>%
                                      purrr::when(.y == "left" ~ stringr::str_replace(string = .,
                                                                                      pattern = "^.",
                                                                                      replacement = ":"),
                                                  .y == "right" ~ stringr::str_replace(string = .,
                                                                                       pattern = ".$",
                                                                                       replacement = ":"),
                                                  .y == "center" ~ stringr::str_replace_all(string = .,
                                                                                            pattern = "(^.|.$)",
                                                                                            replacement = ":"),
                                                  ~ .))) %$%
    c(paste0(name, collapse = " | "),
      paste0(separator, collapse = " | "))
}

gen_table_body <- function(q,
                           block,
                           enumeration_start = 1L) {
  # ensure `block` exists
  ensure_block_exists(block = block)
  
  # traverse list `q` recursively to assemble questionnaire body
  body <- assemble_deep(data_q = q[[block]],
                        devisable_map = init_devisable_map(block = block))
  
  if (length(body) > 0L) {
    
    # "unpack" results list
    while (purrr::vec_depth(body) > 2L) {
      body %<>% purrr::flatten()
    }
    body %<>% purrr::flatten_chr()
    
    # get block enumeration prefix
    prefix <- purrr::pluck(.x = q,
                           block, "prefix",
                           .default = 0L)
    
    # enumerate body rows
    body %<>% paste(seq(from = enumeration_start + prefix,
                        to = enumeration_start + prefix + length(.) - 1L,
                        by = 1L), .,
                    sep = " | ")
    
  } else body <- NULL
  
  body
}

ensure_block_exists <- function(block) {
  
  if (is.null(q[[block]])) {
    cli::cli_abort("The block {.field {block}} doesn't exist in {.var q}.")
  }
}

init_devisable_map <- function(block) {
  
  xfun::strict_list(block = block,
                    i = NULL,
                    j = NULL,
                    topic = NULL,
                    who = NULL,
                    question = NULL,
                    question_common = NULL,
                    multiple_answers_allowed = FALSE,
                    variable_label = NULL,
                    variable_label_common = NULL,
                    response_options = NULL,
                    variable_values = NULL,
                    value_labels = NULL,
                    value_scale = "nominal",
                    randomize_response_options = FALSE,
                    ballot_type = "both_referendum_and_election",
                    include = TRUE)
}

process_item <- function(v_name,
                         devisable_map,
                         generate_md = TRUE,
                         ballot_date,
                         canton,
                         q) {
  
  # ensure nothing indispensable is missing
  assert_devisable_map_complete(devisable_map = devisable_map)
  
  # choose correct include iterator and keys and evaluate them
  devisable_map[["include"]] %<>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.trim = FALSE) %>%
    as.logical() %>%
    checkmate::assert_flag(.var.name = "include")
  
  devisable_map[["ballot_type"]] %<>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.trim = FALSE) %>%
    checkmate::assert_string(.var.name = "ballot_type")
  
  devisable_map[["i"]] %<>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.trim = FALSE) %>%
    purrr::when(length(.) == 0L ~ NULL,
                .) %>%
    checkmate::assert_character(any.missing = FALSE,
                                min.len = 0L,
                                .var.name = "i")
  
  devisable_map[["j"]] %<>%
    pick_right(canton = canton,
               ballot_date = ballot_date) %>%
    glue::glue(.trim = FALSE) %>%
    purrr::when(length(.) == 0L ~ NULL,
                .) %>%
    checkmate::assert_character(any.missing = FALSE,
                                min.len = 0L,
                                .var.name = "j")
  
  # return NULL if item isn't included @ ballot date
  if (!devisable_map[["include"]]
      || (devisable_map$ballot_type != "both_referendum_and_election"
          && devisable_map$ballot_type != ballot_type(canton = canton, ballot_date = ballot_date))) {
    
    result <- NULL
    
  } else {
    
    # assemble "normal" questionnaire items
    if (is.null(devisable_map[["i"]]) && is.null(devisable_map[["j"]])) {
      
      if (generate_md) {
        result <- assemble_table_row(v_name = v_name,
                                     devisable_map = devisable_map,
                                     canton = canton,
                                     ballot_date = ballot_date,
                                     q = q)
      } else {
        result <- assemble_subitem(v_name = v_name,
                                   devisable_map = devisable_map,
                                   canton = canton,
                                   ballot_date = ballot_date,
                                   q = q)
      }
    } else if (is.null(devisable_map[["j"]])) {
      
      if (generate_md) {
        result <- purrr::map_chr(.x = devisable_map[["i"]],
                                 .f = assemble_table_row,
                                 v_name = v_name,
                                 devisable_map = devisable_map,
                                 canton = canton,
                                 ballot_date = ballot_date,
                                 q = q)
      } else {
        result <- purrr::map_dfr(.x = devisable_map[["i"]],
                                 .f = assemble_subitem,
                                 v_name = v_name,
                                 devisable_map = devisable_map,
                                 canton = canton,
                                 ballot_date = ballot_date,
                                 q = q)
      }
      
      # validity check
    } else if (is.null(devisable_map[["i"]])) {
      
      # this combo doesn't really make sense and should never occur
      cli::cli_abort("This should not happen ({.var j} set, but {.var i} not set).")
      
      # "template" items resulting in multiple questionnaire items
    } else {
      
      if (generate_md) {
        result <-
          purrr::map(.x = devisable_map[["i"]],
                     .f = function(x) {
                       
                       i <- x
                       purrr::map_chr(i = x,
                                      .x = devisable_map[["j"]],
                                      .f = assemble_table_row,
                                      v_name = v_name,
                                      devisable_map = devisable_map,
                                      canton = canton,
                                      ballot_date = ballot_date,
                                      q = q)
                     }) %>%
          purrr::flatten_chr()
        
      } else {
        result <- purrr::map_dfr(.x = devisable_map[["i"]],
                                 .f = function(x) {
                                   
                                   i <- x
                                   purrr::map_dfr(i = x,
                                                  .x = devisable_map[["j"]],
                                                  .f = assemble_subitem,
                                                  v_name = v_name,
                                                  devisable_map = devisable_map,
                                                  canton = canton,
                                                  ballot_date = ballot_date,
                                                  q = q)
                                 })
      }
    }
  }
  
  result
}

collapse_break <- function(s) {
  
  paste0(s, collapse = "<br>")
}

wrap_backtick <- function(s) {
  
  purrr::map_chr(.x = s,
                 .f = ~ dplyr::if_else(.x == "-" | stringr::str_detect(string = .x,
                                                                       pattern = "^(_.*_|\\*.*\\*)$"),
                                       as.character(.x),
                                       paste0("`", .x, "`")))
}

this_pkg <- utils::packageName()



unicode_checkmark <- "\u2705"
unicode_crossmark <- "\u274C"
unicode_ellipsis  <- "\u2026"

global_cache_lifespan <- "30 days"



















#' List FOKUS-covered ballot dates
#'
#' A vector of ballot dates covered by FOKUS surveys up until `r max(ballot_dates)`.
#'
#' @format `r pkgsnip::return_label("dates")`
#' @seealso [`cantons`][cantons] [`ballot_metadata`][ballot_metadata]
#' @export
"ballot_dates"

#' FOKUS ballot-date-canton metadata
#'
#' A tibble of FOKUS-survey-related ballot-date-canton metadata, valid up until `r max(ballot_dates)`.
#'
#' @format `r pkgsnip::return_label("data")`
#' @seealso [`ballot_dates`][ballot_dates] [`cantons`][cantons]
#' @export
"ballot_metadata"

#' List cantons that are covered in *any* FOKUS survey
#'
#' A vector of cantons that were part of at least one FOKUS survey up until `r max(ballot_dates)`.
#'
#' @format A character vector.
#' @seealso [`ballot_dates`][ballot_dates] [`ballot_metadata`][ballot_metadata]
#' @export
"cantons"

#' Determine ballot type
#'
#' Determines the type of the ballot for the specified canton at the specified date.
#'
#' @param ballot_date A valid FOKUS-covered cantonal ballot date. One of
#' `r pal::as_md_list(paste0('"', ballot_dates, '"'), wrap = '``')`
#' @param canton A valid FOKUS canton. One of
#' `r pal::as_md_list(paste0('"', cantons, '"'), wrap = '``')`
#'
#' @return The ballot type as a character scalar. One of
#'   - `"referendum"`
#'   - `"election"`
#'   - `"both_referendum_and_election"`
#' @family predicate
#' @export
#'
#' @examples
#' fokus::ballot_type(ballot_date = "2018-09-23",
#'                    canton = "aargau")
ballot_type <- function(ballot_date = ballot_dates,
                        canton = cantons) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  has_election <- has_election(canton = canton,
                               ballot_date = ballot_date)
  
  has_referendum <- has_referendum(canton = canton,
                                   ballot_date = ballot_date)
  
  dplyr::case_when(has_election && has_referendum ~ "both_referendum_and_election",
                   has_election ~ "referendum",
                   has_referendum ~ "election")
}

#' Get number of referendum proposals
#'
#' Determines the number of referendum proposals for a canton at the specified ballot date on the specified political level(s).
#'
#' Technically, the number of *federal* proposals is independent from the canton, but this function still expects a valid `canton`. Nonetheless, the returned
#' number of *federal* proposals at a specific ballot date is always the same regardless of `canton`.
#'
#' @inheritParams n_elections
#'
#' @inherit n_elections return
#' @family predicate
#' @export
#'
#' @examples
#' fokus::n_proposals(ballot_date = "2018-09-23",
#'                    canton = "aargau")
n_proposals <- function(ballot_date = ballot_dates,
                        lvl = c("cantonal", "federal"),
                        canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  lvl <- checkmate::assert_subset(lvl,
                                  choices = c("cantonal", "federal"),
                                  empty.ok = FALSE)
  
  data_subset <-
    ballot_metadata %>%
    dplyr::filter(canton == !!canton,
                  ballot_date == !!ballot_date)
  
  glue::glue("n_{lvl}_proposals") %>%
    purrr::map_int(~ data_subset[[.x]]) %>%
    sum()
}

#' Get number of elections
#'
#' Determines the number of elections for a canton at the specified ballot date on the specified political level(s) and of the specified election procedure(s).
#'
#' @inheritParams ballot_type
#' @param lvl The political level(s). One or more of
#'   - `"cantonal"`
#'   - `"federal"`
#' @param prcd The election procedure(s). One or more of
#'   - `"proportional"`
#'   - `"majoritarian"`
#'
#' @return An integer.
#' @family predicate
#' @export
#'
#' @examples
#' fokus::n_elections(ballot_date = "2018-09-23",
#'                    canton = "aargau")
n_elections <- function(ballot_date = ballot_dates,
                        lvl = c("cantonal", "federal"),
                        canton = cantons,
                        prcd = c("proportional", "majoritarian")) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  lvl <- unique(checkmate::assert_subset(lvl,
                                         choices = c("cantonal", "federal"),
                                         empty.ok = FALSE))
  canton <- rlang::arg_match(canton)
  prcd <- unique(checkmate::assert_subset(prcd,
                                          choices = c("proportional", "majoritarian"),
                                          empty.ok = FALSE))
  
  data_subset <-
    ballot_metadata %>%
    dplyr::filter(canton == !!canton,
                  ballot_date == !!ballot_date)
  
  lvl %>%
    purrr::map(function(lvl) {
      glue::glue("n_{lvl}_{prcd}_elections")
    }) %>%
    purrr::flatten_chr() %>%
    purrr::map_int(~ data_subset[[.x]]) %>%
    sum()
}

#' Get number of (officially registered) majoritarian election candidates
#'
#' Determines the number of (officially registered) candidates of a majoritarian election at the specified ballot date on the specified political level.
#'
#' @inheritParams ballot_type
#' @param lvl The political level. One of
#'   - `"cantonal"`
#'   - `"federal"`
#' @param election_nr The election number. A positive integer scalar (in almost all cases `1L`).
#'
#' @return An integer scalar.
#' @family predicate
#' @export
#'
#' @examples
#' fokus::n_election_candidates(ballot_date = "2019-10-20",
#'                              lvl = "cantonal",
#'                              canton = "aargau",
#'                              election_nr = 1)
n_election_candidates <- function(ballot_date = ballot_dates,
                                  lvl = c("cantonal", "federal"),
                                  canton = cantons,
                                  election_nr = 1L) {
  
  q_suppl_election(ballot_date = ballot_date,
                   lvl = lvl,
                   canton = canton,
                   prcd = "majoritarian",
                   election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    length()
}

#' Get number of skill questions
#'
#' Determines the number of skill questions at the specified ballot date on the specified political level.
#'
#' @inheritParams n_election_candidates
#' @param canton A valid FOKUS canton. One of
#' `r pal::as_md_list(paste0('"', cantons, '"'), wrap = '``')`
#' 
#' Only relevant if `lvl = "cantonal"`.
#' @param proposal_nr The proposal number. A positive integer scalar or `NULL`. If `NULL`, the skill questions are considered to be non-proposal-specific 
#'   (the case at elections).
#'
#' @return An integer scalar.
#' @family predicate
#' @export
#'
#' @examples
#' fokus::n_skill_questions(ballot_date = "2018-09-23",
#'                          lvl = "cantonal",
#'                          canton = "aargau",
#'                          proposal_nr = 1)
n_skill_questions <- function(ballot_date = ballot_dates,
                              lvl = c("cantonal", "federal"),
                              canton = cantons,
                              proposal_nr = NULL) {
  
  q_suppl_skill_questions(ballot_date = ballot_date,
                          lvl = lvl,
                          canton = canton,
                          proposal_nr = proposal_nr) %>%
    length()
}

#' Determine whether ballot type includes a referendum
#'
#' Determines whether or not the ballot in the specified canton at the specified date on the specified political level(s) includes a referendum.
#'
#' @inheritParams n_elections
#'
#' @inherit has_election return
#' @family predicate
#' @export
#'
#' @examples
#' fokus::has_referendum(ballot_date = "2018-09-23",
#'                       lvl = "federal",
#'                       canton = "aargau")
has_referendum <- function(ballot_date = ballot_dates,
                           lvl = c("cantonal", "federal"),
                           canton = cantons) {
  
  n_proposals(ballot_date = ballot_date,
              lvl = lvl,
              canton = canton) > 0L
}

#' Determine whether ballot type includes an election
#'
#' Determines whether or not the ballot for the specified canton at the specified date on the specified political level(s) includes an election of the specified
#' election procedure(s).
#'
#' @inheritParams n_elections
#'
#' @return A logical scalar.
#' @family predicate
#' @export
#'
#' @examples
#' fokus::has_election(canton = "aargau",
#'                     ballot_date = "2018-09-23")
has_election <- function(ballot_date = ballot_dates,
                         lvl = c("cantonal", "federal"),
                         canton = cantons,
                         prcd = c("proportional", "majoritarian")) {
  
  n_elections(ballot_date = ballot_date,
              lvl = lvl,
              canton = canton,
              prcd = prcd) > 0L
}

#' Determine whether ballot includes a political level
#'
#' Determines whether or not the ballot in the specified canton at the specified date includes the specified political level.
#'
#' @inheritParams n_elections
#'
#' @inherit has_election return
#' @family predicate
#' @export
#'
#' @examples
#' fokus::has_lvl(ballot_date = "2018-09-23",
#'                lvl = "federal",
#'                canton = "aargau")
has_lvl <- function(ballot_date = ballot_dates,
                    lvl = c("cantonal", "federal"),
                    canton = cantons) {
  
  has_election(ballot_date = ballot_date,
               lvl = lvl,
               canton = canton) ||
    has_referendum(ballot_date = ballot_date,
                   lvl = lvl,
                   canton = canton)
}

#' Get correct skill question answer number
#'
#' Returns the sequential number of the correct answer for the specified skill question.
#'
#' @inheritParams n_skill_questions
#' @param proposal_nr The proposal number. A positive integer scalar or `NULL`. If `NULL`, it is considered to be a non-proposal-specific skill question 
#'   (the case at elections).
#' @param skill_question_nr The skill question number. A positive integer scalar.
#'
#' @return An integer scalar.
#' @family predicate
#' @export
#'
#' @examples
#' fokus::skill_question_answer_nr(ballot_date = "2018-09-23",
#'                                 lvl = "cantonal",
#'                                 canton = "aargau",
#'                                 proposal_nr = 1,
#'                                 skill_question_nr = 2)
skill_question_answer_nr <- function(ballot_date = ballot_dates,
                                     lvl = c("cantonal", "federal"),
                                     canton = cantons,
                                     proposal_nr = NULL,
                                     skill_question_nr) {
  
  q_suppl_skill_question(canton = canton,
                         ballot_date = ballot_date,
                         lvl = lvl,
                         proposal_nr = proposal_nr,
                         skill_question_nr = skill_question_nr) %>%
    purrr::chuck("response_option") %>%
    purrr::map_depth(.depth = 1L,
                     .f = ~ .x$is_correct) %>%
    purrr::flatten_lgl() %>%
    which()
}

#' Get election candidates
#'
#' Returns the name and party of all candidates running for the specified majoritarian election.
#'
#' @inheritParams n_election_candidates
#'
#' @return `r pkgsnip::return_label("data")`
#' @export
#'
#' @examples
#' fokus::election_candidates(ballot_date = "2019-10-20",
#'                            lvl = "cantonal",
#'                            canton = "aargau",
#'                            election_nr = 1)
election_candidates <- function(ballot_date = ballot_dates,
                                lvl = c("cantonal", "federal"),
                                canton = cantons,
                                election_nr = 1L) {
  
  q_suppl_election(ballot_date = ballot_date,
                   lvl = lvl,
                   canton = canton,
                   prcd = "majoritarian",
                   election_nr = election_nr) %>%
    purrr::chuck("candidate") %>%
    purrr::map_dfr(tibble::as_tibble)
}

#' Raw FOKUS questionnaire data
#'
#' A structured list of the raw questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @seealso [`qx_suppl`][qx_suppl] [`q_suppl`][q_suppl] [`q_suppl_lvl`][q_suppl_lvl] [`q_suppl_lvl_canton`][q_suppl_lvl_canton] 
#'   [`q_suppl_proposal`][q_suppl_proposal] [`q_suppl_election`][q_suppl_election] [`q_suppl_skill_questions`][q_suppl_skill_questions]
#'   [`q_suppl_skill_question`][q_suppl_skill_question]
#' @export
"q"

#' Raw supplemental date-specific FOKUS questionnaire data
#'
#' A structured list of raw supplemental date-specific questionnaire data of the FOKUS surveys.
#'
#' @format `r pkgsnip::return_label("strict_list")`
#' @seealso [`q`][q] [`q_suppl`][q_suppl] [`q_suppl_lvl`][q_suppl_lvl] [`q_suppl_lvl_canton`][q_suppl_lvl_canton] [`q_suppl_proposal`][q_suppl_proposal]
#'   [`q_suppl_election`][q_suppl_election] [`q_suppl_skill_questions`][q_suppl_skill_questions] [`q_suppl_skill_question`][q_suppl_skill_question]
#' @export
#'
#' @examples
#' fokus::qx_suppl[["2018-09-23"]]$mode
"qx_suppl"

#' Get raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][qx_suppl] for the specified ballot date.
#'
#' @inheritParams ballot_type
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @seealso Raw questionnaire data [`q`][q] [`qx_suppl`][qx_suppl]
#' @family q_raw
#' @export
#'
#' @examples
#' fokus::q_suppl(ballot_date = "2018-09-23") %$% mode
q_suppl <- function(ballot_date = ballot_dates) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  qx_suppl[[ballot_date]]
}

#' Get a political level's raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data][q_suppl] for the specified ballot date and political level.
#'
#' @inheritParams n_election_candidates
#'
#' @inherit q_suppl return seealso
#' @seealso Raw questionnaire data [`q`][q] [`qx_suppl`][qx_suppl]
#' @family q_raw
#' @export
#'
#' @examples
#' fokus::q_suppl_lvl(ballot_date = "2018-09-23",
#'                    lvl = "cantonal") |>
#'   names()
q_suppl_lvl <- function(ballot_date = ballot_dates,
                        lvl = c("cantonal", "federal")) {
  
  lvl <- rlang::arg_match(lvl)
  
  result <- q_suppl(ballot_date = ballot_date)[[lvl]]
  
  if (is.null(result)) {
    cli::cli_abort("No {.val {lvl}} level present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  result
}

#' Get a canton's political-level-specific raw supplemental date-specific FOKUS questionnaire data
#'
#' Returns a structured list of the [raw supplemental date-specific FOKUS questionnaire data for the specified ballot date and political level][q_suppl_lvl]
#' that applies for the specified canton only.
#'
#' @inheritParams n_election_candidates
#'
#' @inherit q_suppl return
#' @seealso Raw questionnaire data [`q`][q] [`qx_suppl`][qx_suppl]
#' @family q_raw
#' @export
#'
#' @examples
#' fokus::q_suppl_lvl_canton(ballot_date = "2018-09-23",
#'                           lvl = "cantonal",
#'                           canton = "aargau") |>
#'   names()
q_suppl_lvl_canton <- function(ballot_date = ballot_dates,
                               lvl = c("cantonal", "federal"),
                               canton = cantons) {
  
  canton <- rlang::arg_match(canton)
  
  result <- q_suppl_lvl(ballot_date = ballot_date,
                        lvl = lvl)[[canton]]
  
  if (is.null(result)) {
    cli::cli_abort("No {.val {lvl}} supplemental {.val {ballot_date}} FOKUS questionnaire data present for canton {.val {canton}}.")
  }
  
  result
}

#' Get raw proposal questionnaire data
#'
#' Returns a structured list of raw proposal data from the [supplemental date-specific FOKUS questionnaire data][q_suppl].
#'
#' @inheritParams skill_question_answer_nr
#'
#' @inherit q_suppl return
#' @seealso Raw questionnaire data [`q`][q] [`qx_suppl`][qx_suppl]
#' @family q_raw
#' @export
#'
#' @examples
#' fokus::q_suppl_proposal(ballot_date = "2018-09-23",
#'                         lvl = "cantonal",
#'                         canton = "aargau",
#'                         proposal_nr = 1) %$%
#'   gender
q_suppl_proposal <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             proposal_nr) {
  
  lvl <- rlang::arg_match(lvl)
  checkmate::assert_count(proposal_nr,
                          positive = TRUE)
  proposals <-
    lvl %>%
    purrr::when(. == "federal" ~
                  q_suppl_lvl(ballot_date = ballot_date,
                              lvl = .),
                ~ q_suppl_lvl_canton(ballot_date = ballot_date,
                                     lvl = .,
                                     canton = canton)) %>%
    purrr::pluck("proposal")
  
  if (is.null(proposals)) {
    cli::cli_abort("No {.val {lvl}} proposals present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  proposal <- proposals[[proposal_nr]]
  
  if (is.null(proposal)) {
    cli::cli_abort("No {.val {lvl}} proposal {.val {proposal_nr}} present in the supplemental {.val {ballot_date}} FOKUS questionnaire data.")
  }
  
  proposal
}

#' Get raw election questionnaire data
#'
#' Returns a structured list of raw election data from the [canton's political-level-specific raw supplemental date-specific FOKUS questionnaire
#' data][q_suppl_lvl_canton].
#'
#' @inheritParams n_election_candidates
#' @param prcd The election procedure. One of
#'   - `"proportional"`
#'   - `"majoritarian"`
#'
#' @inherit q_suppl return
#' @seealso Raw questionnaire data [`q`][q] [`qx_suppl`][qx_suppl]
#' @family q_raw
#' @export
#'
#' @examples
#' fokus::q_suppl_election(ballot_date = "2019-10-20",
#'                         lvl = "cantonal",
#'                         canton = "aargau",
#'                         prcd = "majoritarian") %$%
#'   n_seats
q_suppl_election <- function(ballot_date = ballot_dates,
                             lvl = c("cantonal", "federal"),
                             canton = cantons,
                             prcd = c("proportional", "majoritarian"),
                             election_nr = 1L) {
  
  checkmate::assert_count(election_nr,
                          positive = TRUE)
  
  result <- q_suppl_lvl_canton(ballot_date = ballot_date,
                               lvl = lvl,
                               canton = canton)[["election"]]
  
  if (is.null(result)) {
    cli::cli_abort(paste0("No elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result %<>% purrr::pluck(prcd)
  
  if (is.null(result)) {
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} elections for canton {.val {canton}} present in the supplemental {.val {ballot_date}} FOKUS ",
                          "questionnaire data."))
  }
  
  result %<>% purrr::pluck(election_nr)
  
  if (is.null(result)) {
    cli::cli_abort(paste0("No {.val {lvl}} {.val {prcd}} election {.val {election_nr}} for canton {.val {canton}} present in the supplemental ",
                          "{.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get raw skill question questionnaire data
#'
#' Returns a structured list of raw skill question data from the [supplemental date-specific FOKUS questionnaire data][q_suppl].
#'
#' @inheritParams skill_question_answer_nr
#' @param proposal_nr The proposal number. A positive integer scalar or `NULL`. If `NULL`, non-proposal-specific skill question data is returned.
#'
#' @inherit q_suppl return
#' @seealso Raw questionnaire data [`q`][q] [`qx_suppl`][qx_suppl]
#' @family q_raw
#' @export
#'
#' @examples
#' fokus::q_suppl_skill_questions(ballot_date = "2018-09-23",
#'                                lvl = "cantonal",
#'                                canton = "aargau",
#'                                proposal_nr = 1) |>
#'   purrr::map_depth(1L, "de") |>
#'   purrr::flatten_chr()
q_suppl_skill_questions <- function(ballot_date = ballot_dates,
                                    lvl = c("cantonal", "federal"),
                                    canton = cantons,
                                    proposal_nr = NULL) {
  lvl <- rlang::arg_match(lvl)
  
  result <-
    lvl %>%
    purrr::when(
      
      # federal non-proposal-specific skill questions (e.g. at federal elections)
      is.null(proposal_nr) && . == "federal" ~
        q_suppl_lvl(ballot_date = ballot_date,
                    lvl = .),
      # cantonal non-proposal-specific skill questions (e.g. at cantonal elections)
      is.null(proposal_nr) && . == "cantonal" ~
        q_suppl_lvl_canton(ballot_date = ballot_date,
                           lvl = .,
                           canton = canton),
      # federal or cantonal proposal-specific skill questions
      ~ q_suppl_proposal(ballot_date = ballot_date,
                         lvl = .,
                         canton = canton,
                         proposal_nr = proposal_nr)) %>%
    purrr::pluck("skill_question")
  
  if (is.null(result)) {
    cli::cli_abort(paste0("No skill questions present",
                          dplyr::if_else(is.null(proposal_nr),
                                         paste0(" on the {.val {lvl}} level", " for {.val {canton}}"[lvl == "cantonal"]),
                                         " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data."))
  }
  
  result
}

#' Get raw questionnaire data of single skill question
#'
#' Returns a structured list of a single skill question's raw data from the [supplemental date-specific FOKUS questionnaire data][q_suppl].
#'
#' @inheritParams skill_question_answer_nr
#'
#' @inherit q_suppl return
#' @seealso Raw questionnaire data [`q`][q] [`qx_suppl`][qx_suppl]
#' @family q_raw
#' @export
#'
#' @examples
#' fokus::q_suppl_skill_question(ballot_date = "2018-09-23",
#'                               lvl = "cantonal",
#'                               canton = "aargau",
#'                               proposal_nr = 1,
#'                               skill_question_nr = 1)
q_suppl_skill_question <- function(ballot_date = ballot_dates,
                                   lvl = c("cantonal", "federal"),
                                   canton = cantons,
                                   proposal_nr = NULL,
                                   skill_question_nr) {
  
  result <- q_suppl_skill_questions(ballot_date = ballot_date,
                                    lvl = lvl,
                                    canton = canton,
                                    proposal_nr = proposal_nr)[[skill_question_nr]]
  
  if (is.null(result)) {
    cli::cli_abort(paste0("No skill question {.val {skill_question_nr}} present",
                          dplyr::if_else(is.null(proposal_nr),
                                         paste0(" on the {.val {lvl}} level", " for {.val {canton}}"[lvl == "cantonal"]),
                                         " for {.val {lvl}} proposal {.val {proposal_nr}}"),
                          " in the supplemental {.val {ballot_date}} FOKUS questionnaire data. Only {length(skill_questions)} skill questions included."))
  }
  
  result
}

#' Generate questionnaire
#'
#' This is the main questionnaire generation interface that's doing all the magic. This function is only called for its side effects, it doesn't return
#' anything.
#'
#' @inheritParams ballot_type
#' @param quiet `r pkgsnip::param_label("quiet")`
#'   
#' Either as a character or a [date][base::Date] scalar.
#'
#' @return `NULL`, invisibly.
#' @family q_gen
#' @seealso [`qx_suppl`][qx_suppl]
#' @export
gen_q <- function(ballot_date = ballot_dates,
                  canton = cantons,
                  quiet = FALSE) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  checkmate::assert_flag(quiet)
  
  # generate questionnaire tibble
  if (!quiet) {
    status_msg <- "Generating questionnaire data..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  q_tibble <- q_tibble(canton = canton,
                       ballot_date = ballot_date)
  
  # expand questionnaire tibble to long data format
  if (!quiet) {
    status_msg <- "Expanding questionnaire data to long format..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  q_tibble %<>% expand_q_tibble()
  
  readr::write_rds(file = path_private(glue::glue("output/data/internal/r/questionnaire_{ballot_date}_{canton}.rds")),
                   compress = "xz",
                   compression = 9L)
  
  # generate Markdown questionnaire
  if (!quiet) {
    status_msg <- "Generating Markdown questionnaire..."
    cli::cli_progress_step(msg = status_msg,
                           msg_done = paste(status_msg, "done"),
                           msg_failed = paste(status_msg, "failed"))
  }
  
  knitr::knit2pandoc(input = path_private("rmd/questionnaire.Rmd"),
                     output = path_private(glue::glue("output/questionnaires/questionnaire_{ballot_date}_{canton}.md")),
                     quiet = TRUE,
                     tangle = FALSE,
                     to = "gfm",
                     encoding = "UTF-8")
  
  invisible(NULL)
}

#' Generate questionnaire tibble
#'
#' @inheritParams ballot_type
#'
#' @return `r pkgsnip::return_label("data")`
#' @family q_gen
#' @seealso [`qx_suppl`][qx_suppl]
#' @export
q_tibble <- function(ballot_date = ballot_dates,
                     canton = cantons) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  q_suppl <- q_suppl(ballot_date = ballot_date)
  
  # initialize across-block item enumerator
  item_enumerator <- 1L
  
  # assemble questionnaire
  questionnaire <-
    purrr::map_dfr(.x = names(q),
                   .f = function(block) {
                     
                     # determine item enumeration prefix
                     prefix <- purrr::pluck(.x = q,
                                            block, "prefix",
                                            .default = 0L)
                     
                     # determine item enumeration start
                     item_enumeration_start <- dplyr::if_else(prefix == 0L,
                                                              item_enumerator,
                                                              1L)
                     
                     # traverse list `q` recursively and assemble items
                     questionnaire <- assemble_deep(data_q = q[[block]],
                                                    devisable_map = init_devisable_map(block = block),
                                                    generate_md = FALSE)
                     
                     # only proceed if it is an actual questionnaire block (i.e. contains table items)
                     if (length(questionnaire)) {
                       
                       questionnaire %<>%
                         # "unpack" results list
                         pal::reduce_df_list() %>%
                         # add item enumeration
                         dplyr::mutate(nr = seq(from = item_enumeration_start + prefix,
                                                to = item_enumeration_start + prefix + nrow(.) - 1L,
                                                by = 1L),
                                       block = block) %>%
                         # reorder cols
                         dplyr::select(nr, block, everything())
                       
                       # update item enumerator
                       if (prefix == 0L) item_enumerator <<- item_enumerator + nrow(questionnaire)
                       
                     } else questionnaire <- NULL
                     
                     questionnaire
                   })
  
  questionnaire
}

#' Generate Markdown questionnaire
#'
#' @inheritParams ballot_type
#'
#' @return A character vector.
#' @family q_gen
#' @seealso [`qx_suppl`][qx_suppl]
#' @export
q_md <- function(ballot_date = ballot_dates,
                 canton = cantons) {
  
  ballot_date %<>% as.character()
  ballot_date <- rlang::arg_match(ballot_date,
                                  values = as.character(ballot_dates))
  canton <- rlang::arg_match(canton)
  
  q_suppl <- qx_suppl[[ballot_date]]
  
  # initialize block enumerator
  block_enumerator <- 1L
  
  # initialize across-block item enumerator
  item_enumerator <- 1L
  
  # traverse list `q` recursively to assemble questionnaire
  purrr::map(.x = names(q),
             .f = function(block) {
               
               # determine item enumeration prefix
               prefix <- purrr::pluck(.x = q,
                                      block, "prefix",
                                      .default = 0L)
               
               # determine item enumeration start
               item_enumeration_start <- dplyr::if_else(prefix == 0L,
                                                        item_enumerator,
                                                        1L)
               
               # generate table body
               table_body <- gen_table_body(q = q,
                                            block = block,
                                            enumeration_start = item_enumeration_start)
               
               # only proceed if it is an actual questionnaire block (i.e. contains table items)
               if (length(table_body)) {
                 
                 # update item enumerator
                 if (prefix == 0L) item_enumerator <<- item_enumerator + length(table_body)
                 
                 # determine block "number"
                 block_nr <-
                   q %>%
                   purrr::pluck(block, "nr") %>%
                   glue::glue(.trim = FALSE)
                 
                 # handle auto-enumeration
                 if (length(block_nr) == 0L) {
                   
                   block_nr <- block_enumerator
                   block_enumerator <<- block_enumerator + 1L
                 }
                 
                 # assemble block header
                 whole_block <-
                   purrr::pluck(q,
                                block, "title") %>%
                   glue::glue(.trim = FALSE) %>%
                   purrr::when(is.null(.) ~ "",
                               ~ paste0(": ", .)) %>%
                   paste0("## Block ", block_nr, ., "\n")
                 
                 # add block intro and table
                 whole_block <-
                   purrr::pluck(q,
                                block, "intro") %>%
                   pick_right(canton = canton,
                              ballot_date = ballot_date) %>%
                   purrr::when(is.null(.) ~ character(),
                               ~ glue::glue(., "\n",
                                            .trim = FALSE)) %>%
                   c(whole_block,
                     .,
                     gen_table_header(),
                     table_body) %>%
                   paste0(collapse = "\n") %>%
                   paste0("\n\n")
                 
                 return(whole_block)
                 
               } else return(NULL)
             }) %>%
    purrr::flatten_chr() %>%
    cat(sep = "\n")
  
  # assemble footnotes
  q$footnote %>%
    purrr::map(.f = assemble_md_ref_item,
               canton = canton,
               ballot_date = ballot_date) %>%
    purrr::flatten_chr() %>%
    cat("",
        sep = "\n\n")
  
  # assemble reference-style links
  q$link %>%
    purrr::map(.f = assemble_md_ref_item,
               canton = canton,
               ballot_date = ballot_date) %>%
    purrr::flatten_chr() %>%
    cat("",
        sep = "\n\n")
}

#' Pick the right value of a certain questionnaire key based on canton and ballot date (recursively)
#'
#' @param l The questionnaire subitem. A list object.
#' @inheritParams ballot_type
#'
#' @return The value of `l` that corresponds to `canton` and `ballot_date`.
#' @family q_gen
#' @seealso [`qx_suppl`][qx_suppl]
#' @export
pick_right <- function(l,
                       ballot_date,
                       canton) {
  
  l <- pick_right_helper(l = l,
                         ballot_date = ballot_date,
                         canton = canton)
  
  if (purrr::vec_depth(l) > 1L) {
    
    result <- pick_right(l,
                         ballot_date = ballot_date,
                         canton = canton)
    
  }
  
  result
}

pick_right_helper <- function(l,
                              ballot_date,
                              canton) {
  
  if (purrr::is_list(l) && (length(l) > 1L || purrr::vec_depth(l) > 1L)) {
    
    # create plain ballot date as in subkeys
    ballot_date_squeezed <- stringr::str_remove_all(string = ballot_date,
                                                    pattern = "-")
    # convert ballot date to type date
    ballot_date %<>% lubridate::as_date()
    
    # handle begin-end date subkeys
    begin_end_subkeys <-
      names(l) %>%
      stringr::str_subset(pattern = "^\\d+_\\d+$")
    
    matches_begin_end_subkeys <-
      begin_end_subkeys %>%
      purrr::map_lgl(function(x) {
        
        begin <- x %>% stringr::str_extract(pattern = "^\\d+") %>% lubridate::as_date()
        end <- x %>% stringr::str_extract(pattern = "\\d+$") %>% lubridate::as_date()
        
        begin <= ballot_date && ballot_date <= end
      })
    
    # integrity check: ensure there aren't any overlapping intervals
    if (length(which(matches_begin_end_subkeys)) > 1L) {
      
      cli::cli_abort("Illegal overlapping interval subkeys found: {.var {begin_end_subkeys[matches_begin_end_subkeys]}}\n\nPlease fix this and run again.")
    }
    
    result <- names(l) %>% purrr::when(
      
      # consider overrides for binary keys
      ballot_date %in% l[["false"]] ~ FALSE,
      ballot_date %in% l[["true"]] ~ TRUE,
      
      # consider overrides for non-binary keys
      ## single date subkey
      ballot_date_squeezed %in% . ~ l[[ballot_date_squeezed]],
      ## begin-end date subkey
      length(which(matches_begin_end_subkeys)) > 0L ~ l[[begin_end_subkeys[matches_begin_end_subkeys]]],
      
      # consider overrides for ballot types
      ballot_type(canton = canton, ballot_date = ballot_date) %in% . ~ l[[ballot_type(canton = canton, ballot_date = ballot_date)]],
      
      # return default value if defined
      "default" %in% . ~ l[["default"]],
      
      # abort in any remaining case
      ~ cli::cli_abort("Invalid subkey {.val {.}} detected for key {l}.")
    )
  } else {
    result <- l
  }
  
  result
}

#' Determine whether variable is skill question
#'
#' Determines whether or not a variable is a skill question. Vectorized.
#'
#' @param v_names A character vector of FOKUS variable names.
#'
#' @return A logical vector.
#' @family variable
#' @export
is_skill_question <- function(v_names) {
  
  stringr::str_detect(string = v_names,
                      pattern = "^skill_question_\\d+_(cantonal|federal)(_proposal_\\d+)?$")
}

#' Get pre-defined variable value labels
#'
#' @param type Variable value type.
#' @param lang Language the labels should be returned in.
#'
#' @return A character vector.
#' @family variable
#' @export
v_val_lbls <- function(type = c("non_material_participants"),
                       lang = c("de", "en")) {
  
  type <- rlang::arg_match(type)
  lang <- rlang::arg_match(lang)
  
  variable_value_labels %>%
    dplyr::filter(type == !!type) %$%
    eval(parse(text = lang)) %>%
    unlist()
}

variable_value_labels <- tibble::tribble(
  
  ~type,
  ~de,
  ~en,
  
  "non_material_participants",
  c("leer eingelegt/nicht abgestimmt",
    "keine (leer eingelegt oder nicht teilgenommen)",
    "niemanden (leer eingelegt oder nicht teilgenommen)"),
  c("empty (blank vote) or not voted")
)

#' Shorten variable names to a maximum length of 32 characters
#'
#' @param v_names A character vector of variable names.
#' @param reverse Whether to apply the inversion of the shortening logic, i.e. to restore original/unshortened variable names.
#' @param max_n_char The maximum allowed number of characters. `NULL` to skip the check or otherwise an integer scalar in which case it is ensured that the
#'   maximum resulting variable name length doesn't exceed it. Doesn't have any influence on the applied shortening logic.
#'
#' @return A character vector of the same length as `v_names`.
#' @family variable
#' @seealso [shorten_colnames()], [restore_colnames()]
#' @export
shorten_v_names <- function(v_names,
                            reverse = FALSE,
                            max_n_char = 32L) {
  
  checkmate::assert_character(v_names,
                              any.missing = FALSE)
  checkmate::assert_flag(reverse)
  checkmate::assert_count(max_n_char)
  rules <- shortening_rules

  if (reverse) colnames(rules) %<>% .[c(2L, 1L, 3L)]
  
  rules %<>% dplyr::mutate(pattern =
                             allowed %>%
                             purrr::map_chr(function(allowed) {
                               
                               allowed %>% purrr::when(. %in% c("begin-middle", "begin-middle-end") ~ "(?<=(^|_))",
                                                       . %in% c("middle", "middle-end") ~ "(?<=_)",
                                                       . %in% c("begin", "begin-end") ~ "^",
                                                       ~ "")
                             }) %>%
                             paste0(string) %>%
                             purrr::map2_chr(.x = allowed,
                                             .f = ~ {
                                               
                                               .x %>% purrr::when(. == "begin" ~ .y,
                                                                  . %in% c("begin-middle-end", "middle-end") ~ paste0(.y, "(?=(_|$))"),
                                                                  . %in% c("begin-middle", "middle") ~ paste0(.y, "(?=_)"),
                                                                  . == "begin-end" ~ paste0(.y, "$"),
                                                                  . == "end" ~ paste0("(?<=_)", .y, "$"),
                                                                  ~ cli::cli_abort("This should not happen."))
                                             }))
  
  pattern_replacement <- rules$replacement
  names(pattern_replacement) <- rules$pattern
  
  v_names_new <- v_names %>% stringr::str_replace_all(pattern = pattern_replacement)
  
  # ensure we did our job
  if (!is.null(max_n_char) && !reverse && any(nchar(v_names_new) > max_n_char)) {
    
    # NOTE: `cli::cli_abort()` doesn't properly print the output of `pal::capture_print()` because:
    #        - it just seems to ignore the output if it includes ANSI escape sequences (this can be worked around by an additional `cli::ansi_strip()`)
    #        - it normalizes whitespace chars **incl. tabs** to a single regular whitespace, thus breaking the formatting
    rlang::abort(glue::glue("There are still variable names left of a length greater than {max_n_char} characters after applying `shorten_v_names()`. ",
                            "Affected are the following (shortened) variable names:\n\n",
                            tibble::tibble(v_name = v_names,
                                           v_name_short = v_names_new,
                                           n_char = nchar(v_names),
                                           n_char_short = nchar(v_names_new)) %>%
                              dplyr::filter(n_char_short > max_n_char) %>%
                              pal::capture_print(collapse = "\n")))
  }
  
  v_names_new
}

#' Shorten column names to a maximum length of 32 characters
#'
#' This is useful for DTA export since Stata has a built-in variable name length limit of [32
#' characters](https://www.stata.com/manuals/r.pdf#rLimits) (see also
#' [here](https://www.statalist.org/forums/forum/general-stata-discussion/general/1452366-number-of-characters-in-variable-names)).
#'
#' @param x `r pkgsnip::param_label("tabular_data")`
#' @inheritParams shorten_v_names
#'
#' @return `x` with column names shortened to a maximum length of 32 characters.
#' @seealso [shorten_v_names()], [restore_colnames()]
#' @export
shorten_colnames <- function(x,
                             max_n_char = 32L) {
  
  x %>% magrittr::set_colnames(value = shorten_v_names(v_names = colnames(x),
                                                       max_n_char = max_n_char))
}

#' Restore original/unshortened column names
#'
#' Applies the inversion of [shorten_colnames()].
#'
#' @inheritParams shorten_colnames
#' @inheritParams shorten_v_names
#'
#' @return `x` with original/unshortened column names restored.
#' @seealso [shorten_v_names()], [shorten_colnames()]
#' @export
restore_colnames <- function(x) {
  
  x %>% magrittr::set_colnames(value = shorten_v_names(v_names = colnames(x),
                                                       reverse = TRUE))
}

#' Abbreviations used in the **fokus** package
#'
#' Returns a [tibble][tibble::tbl_df] listing an opinionated set of abbreviations used in the \R code and documentation of the **fokus** package.
#'
#' @inheritParams pkgsnip::abbreviations
#'
#' @return `r pkgsnip::param_label("data")`
#' @export
abbreviations <- function(expand = FALSE) {
  
  pal::assert_pkg("pkgsnip")
  
  tibble::tribble(
    ~full_expressions, ~abbreviation,
    "google", "g",
    c("proceed","procedure"), "prcd",
    "procedures", "prcds",
    "questionnaire", "q",
    "questionnaires", "qx",
    "statistik aargau", "sa",
    c("supplemental", "supplementary"), "suppl"
  ) %>%
    dplyr::bind_rows(pkgsnip::abbreviations()) %>%
    dplyr::arrange(dplyr::across()) %>%
    purrr::when(expand ~ tidyr::unnest_longer(data = ., 
                                              col = full_expressions,
                                              values_to = "full_expression"), 
                ~.)
}

#' Print expected structure of the private FOKUS directory
#'
#' Returns a textual representation of the expected structure of the private FOKUS directory, formatted as a Markdown [fenced code
#' block](https://pandoc.org/MANUAL.html#extension-fenced_code_blocks).
#'
#' @includeRmd data-raw/snippets/fokus_private_description.Rmd
#'
#' @return A character scalar.
#' @export
print_fokus_private_structure <- function() {
  cat(fokus_private_structure)
}

#' Emphasize xth element of character vector (Markdown)
#'
#' @param x The input as a character vector.
#' @param which The indices of the elements to be emphasized.
#' @param emph The character sequence used for emphasis.
#'
#' @return A character vector of the same length as `x`.
#' @export
md_emphasize <- function(x,
                         which = TRUE,
                         emph = "**") {
  
  x[which] %<>% paste0(emph, ., emph)
  x
}

#' Convert logical vector to Unicode symbols `r unicode_checkmark` and `r unicode_crossmark`
#'
#' @param x A logical vector.
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' fokus::lgl_to_unicode(c(TRUE, TRUE, FALSE, NA))
lgl_to_unicode <- function(x) {
  
  dplyr::if_else(checkmate::assert_logical(x),
                 unicode_checkmark,
                 unicode_crossmark)
}

#' Prettify date
#'
#' Note that this might only work on (Ubuntu) Linux in the current form since locales are one bitchy hell of a PITA...
#'
#' @param date The date to be prettified. A [date][base::Date] or something coercible to.
#' @param locale The locale the date should be prettified for. Currently only `"en"`/`"en-US"` and `"de"`/`"de-CH"` are implemented.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' fokus::prettify_date(lubridate::today())
prettify_date <- function(date,
                          locale = "en-US") {
  
  withr::with_locale(new = c("LC_TIME" = purrr::when(. = locale,
                                                     . %in% c("en", "en-US") ~ "C",
                                                     . %in% c("de", "de-CH") ~ "de_CH.utf8")),
                     code =
                       locale %>%
                       purrr::when(. %in% c("en", "en-US") ~ "%B %d, %Y",
                                   . %in% c("de", "de-CH") ~ "%d. %B %Y",
                                   ~ cli::cli_abort("Specified {.arg locale} not implemented yet.")) %>%
                       format(x = lubridate::as_date(date)))
}

#' Read in and parse a TOML file as a strict list
#'
#' Reads in a file in [Tom's Obvious Minimal Language](https://toml.io/) format and returns its content as a (nested) [strict list][xfun::strict_list()].
#'
#' The file is parsed using [`RcppTOML::parseTOML(escape = FALSE)`][RcppTOML::parseTOML].
#'
#' @param path The path to the TOML file. A character scalar.
#'
#' @return `r pkgsnip::return_label("strict_list")`
#' @export
read_toml <- function(path) {
  
  pal::assert_pkg("RcppTOML")
  
  path %>%
    purrr::when(length(.) > 0L ~ RcppTOML::parseTOML(input = .,
                                                     escape = FALSE),
                ~ NULL) %>%
    xfun::as_strict_list()
}
